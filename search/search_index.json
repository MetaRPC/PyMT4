{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"settings BASE <p>All about low-level methods</p> map Project Map <p>Its complete structure</p> account_tree Architecture <p>The mechanism in action</p> auto_awesome All about Sugar <p>Simplified helpers &amp; patterns</p> layers All entry points <p>Entry points &amp; layout</p> menu_book Glossary <p>Terms used across docs &amp; code</p> science Examples <p>Quick demos &amp; run instructions</p> tune Orchestrator <p>Control loop &amp; scheduling</p> bolt Presets <p>Strategy presets &amp; tuning</p>"},{"location":"ARCHITECTURE/","title":"\ud83c\udfd7\ufe0f Architecture &amp; Data Flow","text":"<p>A practical map of how our Python SDK, gRPC services, and the MT4 terminal talk to each other \u2014 with just enough clarity to keep your margin level above 100%.</p>"},{"location":"ARCHITECTURE/#big-picture","title":"\ud83d\uddfa\ufe0f Big Picture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 MT4 Terminal                  \u2502\n\u2502      (broker login, quotes, trades)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 local/IPC\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      mt4_term_api.* (gRPC server)             \u2502\n\u2502      Services: MarketQuota, Trade, Account... \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 gRPC\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Python SDK (MetaRpcMT4)                  \u2502\n\u2502      MT4Account (package/MetaRpcMT4/...)      \u2502\n\u2502      + generated pb2/pb2_grpc stubs           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 async/await\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Service Layer (app/)                     \u2502\n\u2502      MT4Service, MT4Service_Trade_mod         \u2502\n\u2502      Connection mgmt, retry logic, hooks      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 async/await\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Sugar API (app/MT4Sugar.py)              \u2502\n\u2502      Pip-based ops, auto-calculations         \u2502\n\u2502      User-friendly wrappers                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 async/await\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Strategy Layer (Strategy/)               \u2502\n\u2502      Orchestrators: market_one_shot, etc.     \u2502\n\u2502      Presets: Balanced, MarketEURUSD, etc.    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 async/await\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Your App / Examples                      \u2502\n\u2502      (examples/, main*.py)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You write: high\u2011level <code>await run_market_one_shot(...)</code> or <code>await sugar.buy_market(...)</code> calls. Sugar does: pip\u2194price conversion, lot calculation, parameter validation. Service does: connection management, retries, hooks, rate limiting. SDK does: request building, metadata, deadlines, retries, unwraps <code>.reply.data</code>. Server does: talks to the real MT4 terminal and executes.</p>"},{"location":"ARCHITECTURE/#main-components-by-folders","title":"\u2699\ufe0f Main Components (by folders)","text":""},{"location":"ARCHITECTURE/#sdk-grpc-contracts-client-side","title":"\ud83d\udd29 SDK &amp; gRPC contracts (client side)","text":"<ul> <li><code>package/MetaRpcMT4/mt4_account.py</code> \u2014 MT4Account wrappers (public API).</li> <li><code>package/MetaRpcMT4/mt4_term_api_*.py</code> \u2014 pb2 messages (requests/replies/enums).</li> <li><code>package/MetaRpcMT4/mt4_term_api_*_pb2_grpc.py</code> \u2014 stubs (client bindings).</li> <li><code>package/MetaRpcMT4/mrpc_mt4_error_pb2.py</code> \u2014 errors/retcodes mapping.</li> </ul>"},{"location":"ARCHITECTURE/#service-layer-app","title":"\ud83e\udde0 Service layer (app/)","text":"<ul> <li><code>app/MT4Service.py</code> \u2014 core service wrapper, connection management. \ud83d\udd0c</li> <li><code>app/MT4Service_Trade_mod.py</code> \u2014 trading operations wrapper. \u2622\ufe0f</li> <li><code>app/MT4Sugar.py</code> \u2014 high-level sugar API with pip-based operations. \ud83c\udf6c</li> <li><code>app/Helper/config.py</code> \u2014 settings loader (appsettings.json + env). \u2699\ufe0f</li> <li><code>app/Helper/hooks.py</code> \u2014 event hooks system (pre/post operations). \ud83e\ude9d</li> <li><code>app/Helper/patch_mt4_account.py</code> \u2014 compatibility patches for MT4 quirks. \ud83e\udde9</li> <li><code>app/Helper/rate_limit.py</code> \u2014 API rate limiting protection. \ud83d\udee1\ufe0f</li> <li><code>app/Helper/errors.py</code> \u2014 custom exceptions and error handling. \ud83d\udea8</li> </ul>"},{"location":"ARCHITECTURE/#strategy-layer-strategy","title":"\ud83c\udfad Strategy layer (Strategy/)","text":"<ul> <li><code>Strategy/orchestrator/*.py</code> \u2014 13 ready-to-use trading scenarios.</li> <li><code>Strategy/presets/risk.py</code> \u2014 5 basic risk profiles (Conservative, Balanced, etc.).</li> <li><code>Strategy/presets/risk_atr.py</code> \u2014 3 ATR-based adaptive risk profiles.</li> <li><code>Strategy/presets/risk_profiles.py</code> \u2014 symbol+style combinations.</li> <li><code>Strategy/presets/risk_session.py</code> \u2014 session-based risk management.</li> <li><code>Strategy/presets/strategy_symbols.py</code> \u2014 30+ pre-configured symbols.</li> </ul>"},{"location":"ARCHITECTURE/#documentation-examples","title":"\ud83d\udcda Documentation &amp; Examples","text":"<ul> <li><code>docs/MT4Account/**</code> \u2014 low-level API specs &amp; overviews.</li> <li><code>docs/MT4Sugar/**</code> \u2014 sugar API method documentation.</li> <li><code>docs/Strategy/**</code> \u2014 orchestrators &amp; presets guides.</li> <li><code>examples/**</code> \u2014 runnable demo scripts.</li> <li><code>main*.py</code> \u2014 entry point demos.</li> </ul>"},{"location":"ARCHITECTURE/#data-flow-unary-request","title":"\ud83d\udd00 Data Flow (Unary Request)","text":""},{"location":"ARCHITECTURE/#example-buy-market-order-with-sugar-api","title":"Example: Buy market order with Sugar API","text":"<pre><code># 1. Your code\nawait sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40)\n\n# 2. Sugar API (MT4Sugar.py)\n# - Validates parameters\n# - Converts pips to price (20 pips \u2192 0.0020 for EURUSD)\n# - Builds order request\n# - Calls MT4Service_Trade_mod\n\n# 3. Service Layer (MT4Service_Trade_mod.py)\n# - Checks rate limits\n# - Fires pre-operation hooks\n# - Calls MT4Service.order_send()\n# - Handles retries on failure\n# - Fires post-operation hooks\n\n# 4. Core Service (MT4Service.py)\n# - Ensures connection alive\n# - Adds metadata (login, session)\n# - Sets timeout/deadline\n# - Calls MT4Account.order_send()\n\n# 5. SDK (package/MetaRpcMT4/mt4_account.py)\n# - Builds gRPC Request protobuf\n# - Calls stub: ServiceStub.OrderSend(request, metadata, timeout)\n# - Waits for Reply\n# - Unwraps reply.data\n# - Returns order ticket\n\n# 6. gRPC Server (mt4_term_api)\n# - Receives request\n# - Calls MT4 terminal functions\n# - Executes order\n# - Returns Reply with ticket/retcode\n\n# 7. Result flows back through layers\n# - SDK unwraps reply\n# - Service processes hooks\n# - Sugar returns clean result\n# - Your code gets ticket number\n</code></pre>"},{"location":"ARCHITECTURE/#data-flow-streaming","title":"\ud83d\udd04 Data Flow (Streaming)","text":"<p>Streams keep a channel open and push events. Use cancellation_event and keep handlers non\u2011blocking.</p>"},{"location":"ARCHITECTURE/#example-stream-live-ticks","title":"Example: Stream live ticks","text":"<pre><code>import asyncio\n\nstop_event = asyncio.Event()\n\n# 1. Your code subscribes\nasync for tick in sugar.on_symbol_tick([\"EURUSD\", \"GBPUSD\"], cancellation_event=stop_event):\n    print(f\"{tick.symbol}: {tick.bid}/{tick.ask}\")\n\n    if should_stop():\n        stop_event.set()  # Signal to close stream\n\n# 2. Sugar API\n# - Validates symbols\n# - Calls MT4Service.on_symbol_tick()\n\n# 3. Service Layer\n# - Ensures connection\n# - Calls MT4Account.on_symbol_tick()\n# - Monitors cancellation_event\n\n# 4. SDK\n# - Opens streaming gRPC channel\n# - Yields events as they arrive\n# - Closes on cancellation_event.set()\n\n# 5. Server\n# - Subscribes to terminal tick events\n# - Streams ticks for requested symbols\n# - Closes on client disconnect\n</code></pre> <p>Common streams:</p> <ul> <li><code>on_symbol_tick</code> \u2014 live ticks per symbol. \ud83d\udcc8</li> <li><code>on_trade</code> \u2014 trade execution events (orders filled, positions changed). \ud83d\udcbc</li> <li><code>on_opened_orders_tickets</code> \u2014 stream of open ticket IDs. \ud83c\udfab</li> <li><code>on_opened_orders_profit</code> \u2014 stream of profit updates. \ud83d\udcb0</li> </ul> <p>Links: Streams Overview</p>"},{"location":"ARCHITECTURE/#layer-responsibilities","title":"\ud83e\udde9 Layer Responsibilities","text":""},{"location":"ARCHITECTURE/#layer-1-strategy-orchestrators","title":"Layer 1: Strategy Orchestrators \ud83c\udfad","text":"<p>What: Complete trading workflows (market_one_shot, pending_bracket, spread_guard, etc.)</p> <p>Responsibilities: - Combine multiple operations into scenarios - Implement trading logic (guards, timeouts, automation) - Use presets for configuration - Handle complex flows (wait for fill, activate trailing, etc.)</p> <p>Example: <pre><code>from Strategy.orchestrator.market_one_shot import run_market_one_shot\nfrom Strategy.presets import MarketEURUSD, Balanced\n\nresult = await run_market_one_shot(svc, MarketEURUSD, Balanced)\n</code></pre></p>"},{"location":"ARCHITECTURE/#layer-2-presets","title":"Layer 2: Presets \u2699\ufe0f","text":"<p>What: Reusable configurations (MarketEURUSD, Balanced, Conservative, etc.)</p> <p>Responsibilities: - Define WHAT to trade (symbol, entry type, magic number) - Define HOW MUCH to risk (%, SL, TP, trailing) - Provide consistent configurations - Enable mixing and matching</p> <p>Example: <pre><code>from Strategy.presets import MarketEURUSD, Balanced\n\nstrategy = MarketEURUSD  # WHAT: EURUSD, market entry\nrisk = Balanced          # HOW MUCH: 1% risk, 20 pip SL, 40 pip TP\n</code></pre></p>"},{"location":"ARCHITECTURE/#layer-3-sugar-api","title":"Layer 3: Sugar API \ud83c\udf6c","text":"<p>What: High-level convenience methods (buy_market, modify_sl_tp_by_pips, etc.)</p> <p>Responsibilities: - Pip\u2194price conversions - Auto lot calculation by risk % - Symbol info caching - User-friendly parameter names - Input validation</p> <p>Example: <pre><code>await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40)\n# Converts pips to prices, validates, calls service layer\n</code></pre></p>"},{"location":"ARCHITECTURE/#layer-4-service-wrappers","title":"Layer 4: Service Wrappers \ud83d\udd0c","text":"<p>What: MT4Service, MT4Service_Trade_mod</p> <p>Responsibilities: - Connection management (connect, reconnect, ensure_connected) - Rate limiting (prevent API throttling) - Hook system (pre/post operation events) - Retry logic (handle transient failures) - Session management</p> <p>Example: <pre><code>svc = MT4Service(...)\nawait svc.ensure_connected()\nresult = await svc.order_send(request)\n</code></pre></p>"},{"location":"ARCHITECTURE/#layer-5-sdk-low-level","title":"Layer 5: SDK (Low-level) \ud83d\udd27","text":"<p>What: MT4Account (package/MetaRpcMT4/mt4_account.py)</p> <p>Responsibilities: - gRPC request/response building - Protobuf serialization - Metadata handling - Timeout/deadline management - Reply unwrapping</p> <p>Example: <pre><code>from package.MetaRpcMT4.mt4_account import MT4Account\n\nacct = MT4Account(...)\nticket = await acct.order_send(request)\n</code></pre></p>"},{"location":"ARCHITECTURE/#connection-management","title":"\ud83d\udd0c Connection Management","text":""},{"location":"ARCHITECTURE/#connection-flow","title":"Connection Flow","text":"<pre><code>1. Load config (appsettings.json or env)\n   \u2193\n2. Create MT4Service instance\n   \u2193\n3. Call ensure_connected()\n   \u2193\n4. Try connect_by_server_name()\n   \u2193\n5. If fails, try connect_by_host_port() for each host in \"access\" list\n   \u2193\n6. If all fail, retry with backoff\n   \u2193\n7. Connection established \u2713\n   \u2193\n8. Store session metadata\n   \u2193\n9. Enable rate limiting\n   \u2193\n10. Ready for operations\n</code></pre>"},{"location":"ARCHITECTURE/#connection-states","title":"Connection States","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Disconnected\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u2502 ensure_connected()\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Connecting  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u2502 success\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     transient error\n\u2502  Connected  \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n       \u2502                           \u2502\n       \u2502 operation                 \u2502\n       \u25bc                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     auto-retry     \u2502\n\u2502  Operating  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u2502 disconnect()\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Disconnected\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ARCHITECTURE/#hook-system","title":"\ud83e\ude9d Hook System","text":"<p>Hooks allow you to intercept operations at key points.</p>"},{"location":"ARCHITECTURE/#hook-types","title":"Hook Types","text":"<pre><code>from app.Helper.hooks import HookManager\n\nhooks = HookManager()\n\n# Before operation\n@hooks.before(\"order_send\")\nasync def log_order(request):\n    print(f\"Sending order: {request.symbol} @ {request.volume}\")\n\n# After operation (success)\n@hooks.after(\"order_send\")\nasync def log_success(request, result):\n    print(f\"Order filled: ticket={result.ticket}\")\n\n# After operation (error)\n@hooks.on_error(\"order_send\")\nasync def log_error(request, error):\n    print(f\"Order failed: {error}\")\n</code></pre>"},{"location":"ARCHITECTURE/#common-hook-points","title":"Common Hook Points","text":"<ul> <li><code>order_send</code> \u2014 before/after placing orders</li> <li><code>order_modify</code> \u2014 before/after modifying orders</li> <li><code>order_close</code> \u2014 before/after closing positions</li> <li><code>connect</code> \u2014 before/after connection attempts</li> <li><code>quote</code> \u2014 before/after fetching quotes</li> </ul>"},{"location":"ARCHITECTURE/#rate-limiting","title":"\ud83d\udee1\ufe0f Rate Limiting","text":"<p>Prevents overwhelming the MT4 terminal with requests.</p>"},{"location":"ARCHITECTURE/#configuration","title":"Configuration","text":"<pre><code>from app.Helper.rate_limit import RateLimiter\n\n# Max 10 requests per second\nlimiter = RateLimiter(max_calls=10, period=1.0)\n\nasync def safe_operation():\n    async with limiter:\n        result = await svc.quote(\"EURUSD\")\n    return result\n</code></pre>"},{"location":"ARCHITECTURE/#default-limits","title":"Default Limits","text":"<ul> <li>Market data: 20 req/sec</li> <li>Trading operations: 5 req/sec</li> <li>History queries: 10 req/sec</li> </ul>"},{"location":"ARCHITECTURE/#requestresponse-examples","title":"\ud83d\udcca Request/Response Examples","text":""},{"location":"ARCHITECTURE/#example-1-get-quote","title":"Example 1: Get Quote","text":"<pre><code># High-level (Sugar)\nquote = await sugar.last_quote(\"EURUSD\")\n# Returns: QuoteData(symbol=\"EURUSD\", bid=1.10000, ask=1.10020, time=...)\n\n# Low-level (SDK)\nfrom package.MetaRpcMT4 import mt4_term_api_market_quota_pb2 as mq_pb2\n\nrequest = mq_pb2.QuoteRequest(symbol=\"EURUSD\")\nreply = await acct.quote(request)\n# Returns: QuoteReply.data with bid/ask/time\n</code></pre>"},{"location":"ARCHITECTURE/#example-2-place-market-order","title":"Example 2: Place Market Order","text":"<pre><code># High-level (Sugar)\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40)\n# Sugar converts pips to prices, calls service\n\n# Medium-level (Service)\nresult = await svc.order_send(\n    symbol=\"EURUSD\",\n    order_type=\"market\",\n    volume=0.1,\n    sl=1.09800,  # calculated from pips\n    tp=1.10400,  # calculated from pips\n)\n\n# Low-level (SDK)\nfrom package.MetaRpcMT4 import mt4_term_api_trading_action_pb2 as ta_pb2\n\nrequest = ta_pb2.OrderSendRequest(\n    symbol=\"EURUSD\",\n    order_type=ta_pb2.ORDER_TYPE_BUY,\n    volume=0.1,\n    sl=1.09800,\n    tp=1.10400,\n)\nreply = await acct.order_send(request)\n# Returns: OrderSendReply.data with ticket\n</code></pre>"},{"location":"ARCHITECTURE/#debugging-tips","title":"\ud83d\udd0d Debugging Tips","text":""},{"location":"ARCHITECTURE/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"MT4Service\")\nlogger.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"ARCHITECTURE/#inspect-grpc-calls","title":"Inspect gRPC Calls","text":"<pre><code>from app.Helper import grpc_debug\n\n# Log all gRPC calls\ngrpc_debug.enable()\n\n# Make calls\nawait svc.quote(\"EURUSD\")\n# Logs: Request, Reply, Duration\n\n# Disable logging\ngrpc_debug.disable()\n</code></pre>"},{"location":"ARCHITECTURE/#check-connection-state","title":"Check Connection State","text":"<pre><code>is_connected = await svc.ping()\nif not is_connected:\n    await svc.ensure_connected()\n</code></pre>"},{"location":"ARCHITECTURE/#monitor-rate-limits","title":"Monitor Rate Limits","text":"<pre><code>from app.Helper.rate_limit import get_limiter_stats\n\nstats = get_limiter_stats()\nprint(f\"Requests: {stats.calls} / {stats.limit}\")\nprint(f\"Window resets in: {stats.reset_in}s\")\n</code></pre>"},{"location":"ARCHITECTURE/#performance-optimization","title":"\ud83c\udfaf Performance Optimization","text":""},{"location":"ARCHITECTURE/#1-cache-symbol-info","title":"1. Cache Symbol Info","text":"<pre><code># Bad: fetch every time\nfor i in range(100):\n    digits = await sugar.digits(\"EURUSD\")\n\n# Good: cache once\ndigits = await sugar.digits(\"EURUSD\")  # Automatically cached\nfor i in range(100):\n    # Use cached value\n    pass\n</code></pre>"},{"location":"ARCHITECTURE/#2-batch-quote-requests","title":"2. Batch Quote Requests","text":"<pre><code># Bad: one by one\nquote1 = await sugar.last_quote(\"EURUSD\")\nquote2 = await sugar.last_quote(\"GBPUSD\")\n\n# Good: batch\nquotes = await sugar.quotes([\"EURUSD\", \"GBPUSD\"])\n</code></pre>"},{"location":"ARCHITECTURE/#3-use-streams-for-real-time-data","title":"3. Use Streams for Real-time Data","text":"<pre><code># Bad: poll every second\nwhile True:\n    quote = await sugar.last_quote(\"EURUSD\")\n    await asyncio.sleep(1)\n\n# Good: stream\nasync for tick in sugar.on_symbol_tick([\"EURUSD\"]):\n    # Process tick immediately\n    pass\n</code></pre>"},{"location":"ARCHITECTURE/#4-parallel-operations","title":"4. Parallel Operations","text":"<pre><code>import asyncio\n\n# Execute multiple operations in parallel\nresults = await asyncio.gather(\n    sugar.last_quote(\"EURUSD\"),\n    sugar.last_quote(\"GBPUSD\"),\n    sugar.opened_orders(),\n)\n</code></pre>"},{"location":"ARCHITECTURE/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"ARCHITECTURE/#unit-tests-mock-sdk","title":"Unit Tests (Mock SDK)","text":"<pre><code>from unittest.mock import AsyncMock\n\nacct = AsyncMock()\nacct.quote.return_value = QuoteReply(...)\n\nsvc = MT4Service(acct)\nresult = await svc.quote(\"EURUSD\")\n</code></pre>"},{"location":"ARCHITECTURE/#integration-tests-demo-account","title":"Integration Tests (Demo Account)","text":"<pre><code># Set ENABLE_TRADING=0 for safe testing\nimport os\nos.environ[\"ENABLE_TRADING\"] = \"0\"\n\n# All trading operations will be simulated\nawait sugar.buy_market(\"EURUSD\", lots=0.1)  # No real order\n</code></pre>"},{"location":"ARCHITECTURE/#live-tests-real-account","title":"Live Tests (Real Account)","text":"<pre><code># Set ENABLE_TRADING=1 and use SMALL lots\nos.environ[\"ENABLE_TRADING\"] = \"1\"\n\n# Real trading with minimal risk\nawait sugar.buy_market(\"EURUSD\", lots=0.01, sl_pips=20, tp_pips=40)\n</code></pre>"},{"location":"ARCHITECTURE/#related-documentation","title":"\ud83d\udcd6 Related Documentation","text":"<ul> <li>PROJECT_MAP.md \u2014 Project structure and navigation</li> <li>MT4Account BASE \u2014 Low-level API master overview</li> <li>MT4Sugar API \u2014 High-level API documentation</li> <li>Orchestrators Guide \u2014 Trading workflows</li> <li>Presets Guide \u2014 Configuration presets</li> </ul> <p>\"May your architecture be solid, your data flow clean, and your trades profitable. \ud83c\udfd7\ufe0f\"</p>"},{"location":"GLOSSARY/","title":"\ud83d\udcd6 Glossary \u2014 PyMT4 Trading Terms","text":"<p>Your quick reference for trading terminology, PyMT4 concepts, and SDK-specific terms.</p>"},{"location":"GLOSSARY/#quick-cheat-sheet","title":"\ud83c\udfaf Quick Cheat Sheet","text":"Term Example Meaning Symbol <code>EURUSD</code>, <code>XAUUSD</code>, <code>BTCUSD</code> Trading instrument identifier (currency pair, metal, index, crypto). Lot <code>1.00</code> \u2192 100,000 units Standard trade size. 0.01 = micro lot (1,000 units). Volume <code>0.10</code>, <code>2.50</code> Lots to trade (can be fractional). Pips <code>20 pips</code> = 0.0020 for EURUSD Common distance unit. Sugar API uses pips for SL/TP. Point <code>0.00001</code> (EURUSD 5-digit) Smallest price step for the symbol. Digits <code>5</code> Quote precision; e.g., 1.23456 for 5 digits. Bid <code>1.10000</code> Price to SELL at (what broker pays you). Ask <code>1.10020</code> Price to BUY at (what you pay broker). Spread <code>2 pips</code> = Ask - Bid Cost per trade (broker commission). SL <code>1.09800</code> or <code>20 pips</code> Stop Loss \u2014 protective exit level. TP <code>1.10400</code> or <code>40 pips</code> Take Profit \u2014 target exit level. Ticket <code>12345678</code> Unique order/position ID (int64). Magic <code>771</code> Order identifier (organize by strategy). Range: 771-859. Deviation <code>5 pips</code> Allowed slippage (price can move this much). Slippage <code>3 pips</code> Actual price difference from requested. Margin <code>100.00</code> Funds locked for open position. Equity <code>1000.00</code> Balance \u00b1 floating P/L. Free Margin <code>900.00</code> Equity \u2212 Margin (available for new trades). Balance <code>950.00</code> Account balance (realized P/L only). Profit <code>+50.00</code> Current position P/L (unrealized). Leverage <code>1:500</code> Borrowed funds ratio (500x buying power). Retcode <code>10009</code>, <code>TRADE_RETCODE_DONE</code> Trade server return code (success/error). Enum <code>ORDER_TYPE_BUY</code>, <code>ORDER_TYPE_SELL</code> Strongly-typed constants (no magic numbers). Stream <code>on_symbol_tick()</code>, <code>on_trade()</code> Long-lived server push (events until cancelled). Cancellation <code>asyncio.Event()</code> Cooperative stop signal for streams. Deadline <code>now() + 3s</code> Per-call timeout \u2192 turned into gRPC timeout."},{"location":"GLOSSARY/#trading-concepts","title":"\ud83d\udcca Trading Concepts","text":""},{"location":"GLOSSARY/#order-types","title":"Order Types","text":"Type Symbol Description Use Case Market Order \ud83d\ude80 Execute immediately at current price Fast entry, breakout trading Limit Order \u23f0 Execute at specific price or better Buy dips, sell rallies, better fill Stop Order \ud83e\udde8 Execute when price reaches trigger Breakout entries, stop-out protection Pending Order \u23f8\ufe0f Placed but not yet filled Limit + Stop orders"},{"location":"GLOSSARY/#position-states","title":"Position States","text":"State Description Open Active position, accumulating P/L Pending Order placed but not filled yet Closed Position closed, P/L realized Cancelled Pending order cancelled before fill"},{"location":"GLOSSARY/#risk-management-terms","title":"Risk Management Terms","text":"Term Example Description Risk % <code>1.0%</code> Percentage of equity to risk per trade Risk:Reward (R:R) <code>1:2</code> Ratio of SL distance to TP distance Lot Sizing <code>calc_lot_by_risk()</code> Calculate lot based on risk % and SL distance Breakeven Move SL to entry price Lock in zero loss Trailing Stop SL follows price Protect profits as price moves favorably Circuit Breaker Emergency stop Close all on equity drop threshold"},{"location":"GLOSSARY/#pymt4-specific-terms","title":"\ud83c\udfad PyMT4 Specific Terms","text":""},{"location":"GLOSSARY/#architecture-layers","title":"Architecture Layers","text":"Layer Description Example Orchestrator Complete trading workflow <code>market_one_shot</code>, <code>pending_bracket</code> Preset Reusable configuration <code>Balanced</code>, <code>MarketEURUSD</code> Sugar API High-level convenience methods <code>buy_market()</code>, <code>modify_sl_tp_by_pips()</code> Service Layer Connection management, hooks <code>MT4Service</code>, <code>MT4Service_Trade_mod</code> SDK (Low-level) Direct gRPC wrappers <code>MT4Account.order_send()</code>"},{"location":"GLOSSARY/#strategy-components","title":"Strategy Components","text":"Component File Description StrategyPreset <code>strategy_symbols.py</code> WHAT to trade (symbol, entry type, magic) RiskPreset <code>risk.py</code> HOW MUCH to risk (%, SL, TP, trailing) Orchestrator <code>orchestrator/*.py</code> Complete trading scenario (guards, automation)"},{"location":"GLOSSARY/#key-classes","title":"Key Classes","text":"Class Purpose Location MT4Service Core service wrapper <code>app/MT4Service.py</code> MT4Service_Trade_mod Trading operations wrapper <code>app/MT4Service_Trade_mod.py</code> MT4Sugar High-level API <code>app/MT4Sugar.py</code> MT4Account Low-level SDK <code>package/MetaRpcMT4/mt4_account.py</code> HookManager Event hooks system <code>app/Helper/hooks.py</code> RateLimiter API rate limiting <code>app/Helper/rate_limit.py</code>"},{"location":"GLOSSARY/#sugar-api-concepts","title":"\ud83c\udf6c Sugar API Concepts","text":""},{"location":"GLOSSARY/#pip-based-operations","title":"Pip-Based Operations","text":"<p>Sugar API uses pips as the universal unit:</p> <pre><code># Instead of calculating prices:\nawait sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40)\n\n# Sugar converts:\n# 20 pips \u2192 0.0020 (for 5-digit EURUSD)\n# Sets SL at: current_price - 0.0020\n# Sets TP at: current_price + 0.0040\n</code></pre>"},{"location":"GLOSSARY/#auto-lot-calculation","title":"Auto Lot Calculation","text":"<pre><code># Calculate lot by risk percentage\nlot = await sugar.calc_lot_by_risk(\n    symbol=\"EURUSD\",\n    risk_percent=1.0,    # Risk 1% of equity\n    stop_pips=20         # If SL is 20 pips away\n)\n# Returns: 0.15 (if equity=1000, 1% = $10, 20 pips = 0.15 lot)\n</code></pre>"},{"location":"GLOSSARY/#symbol-info-caching","title":"Symbol Info Caching","text":"<p>Sugar API caches symbol info automatically:</p> <pre><code># First call: fetches from server\ndigits = await sugar.digits(\"EURUSD\")  # \u2192 5\n\n# Subsequent calls: cached\ndigits = await sugar.digits(\"EURUSD\")  # \u2192 5 (instant)\n</code></pre>"},{"location":"GLOSSARY/#orchestrator-concepts","title":"\ud83c\udfad Orchestrator Concepts","text":""},{"location":"GLOSSARY/#guards","title":"Guards","text":"<p>Filters that block trades under certain conditions:</p> Guard Blocks when... Example spread_guard Spread too wide <code>max_spread_pips=2.0</code> session_guard Outside time windows <code>windows=[('08:00', '17:00')]</code> deviation_guard Slippage too high <code>max_deviation_pips=5.0</code> equity_circuit_breaker Equity drop threshold <code>max_drawdown_percent=5.0</code> rollover_avoidance Near swap time <code>avoid_minutes=30</code>"},{"location":"GLOSSARY/#automation-features","title":"Automation Features","text":"Feature Description Trigger Trailing Stop SL follows price Price moves favorably by <code>distance_pips</code> Auto Breakeven Move SL to entry Profit reaches <code>trigger_pips</code> Timeout Cancel pending order Not filled within <code>timeout_s</code> seconds Kill Switch Emergency close all Manual trigger or equity threshold"},{"location":"GLOSSARY/#preset-concepts","title":"\u2699\ufe0f Preset Concepts","text":""},{"location":"GLOSSARY/#risk-preset-properties","title":"Risk Preset Properties","text":"Property Type Description Example risk_percent <code>float</code> % of equity to risk <code>1.0</code> = 1% sl_pips <code>float</code> Stop loss distance <code>20.0</code> tp_pips <code>float</code> Take profit distance <code>40.0</code> trailing_pips <code>float</code> Trailing stop distance <code>15.0</code> be_trigger_pips <code>float</code> Profit to trigger BE <code>20.0</code> be_plus_pips <code>float</code> Extra pips above BE <code>2.0</code>"},{"location":"GLOSSARY/#strategy-preset-properties","title":"Strategy Preset Properties","text":"Property Type Description Example symbol <code>str</code> Trading instrument <code>\"EURUSD\"</code> magic <code>int</code> Order identifier <code>771</code> deviation_pips <code>float</code> Slippage tolerance <code>2.5</code> entry_type <code>str</code> Order type <code>\"market\"</code>, <code>\"limit\"</code>, <code>\"stop\"</code> entry_price <code>float</code> Price for pending orders <code>1.0850</code> comment <code>str</code> Order comment <code>\"Scalp EUR\"</code>"},{"location":"GLOSSARY/#technical-terms","title":"\ud83d\udd27 Technical Terms","text":""},{"location":"GLOSSARY/#grpc-concepts","title":"gRPC Concepts","text":"Term Description Stub Client-side interface to remote service Request Protobuf message sent to server Reply Protobuf message returned from server Metadata Headers sent with request (login, session) Timeout Max time to wait for response Deadline Absolute time when request expires Stream Long-lived channel for continuous data"},{"location":"GLOSSARY/#mt4-server-concepts","title":"MT4 Server Concepts","text":"Term Description Access List of host:port addresses Server Name Broker server identifier (e.g., \"MetaQuotes-Demo\") Login Account number Password Account password Session Active connection state"},{"location":"GLOSSARY/#error-handling","title":"Error Handling","text":"Term Description Retcode Server return code (10009 = success) Retry Automatic re-attempt on failure Backoff Delay between retries (exponential) Cancellation Manual stop of operation/stream Timeout Operation exceeded deadline"},{"location":"GLOSSARY/#market-terms","title":"\ud83d\udcc8 Market Terms","text":""},{"location":"GLOSSARY/#volatility","title":"Volatility","text":"Term Description ATR Average True Range \u2014 volatility indicator Spread Widening Spread increases (news, rollover) Slippage Price difference from requested Gap Large price jump (weekend, news)"},{"location":"GLOSSARY/#sessions","title":"Sessions","text":"Session Time (GMT) Characteristics Tokyo 00:00-08:00 Low volatility, range-bound London 07:00-16:30 High liquidity, major moves New York 12:00-21:00 Highest volume, trending Overlap 12:00-16:30 London+NY, max volatility"},{"location":"GLOSSARY/#order-flow","title":"Order Flow","text":"Term Description Fill Order executed Partial Fill Only part of volume executed Reject Order refused by server Requote Price changed, confirm new price Off Quotes No price available (market closed)"},{"location":"GLOSSARY/#safety-terms","title":"\ud83d\udee1\ufe0f Safety Terms","text":""},{"location":"GLOSSARY/#risk-controls","title":"Risk Controls","text":"Control Description Example Max Lot Maximum position size <code>symbol_params.lot_max</code> Min Lot Minimum position size <code>symbol_params.lot_min</code> Lot Step Lot size increment <code>0.01</code> (micro lots) Max Spread Spread threshold <code>2.0 pips</code> Max Deviation Slippage threshold <code>5.0 pips</code> Stop Level Min distance for SL/TP <code>10.0 pips</code> Freeze Level No modify near market <code>5.0 pips</code>"},{"location":"GLOSSARY/#trade-restrictions","title":"Trade Restrictions","text":"Restriction Description Market Closed No trading outside hours Trading Disabled Symbol not tradeable Long Only Can't open short positions Close Only Can only close existing Margin Call Insufficient margin Stop Out Forced position close"},{"location":"GLOSSARY/#debugging-terms","title":"\ud83d\udd0d Debugging Terms","text":"Term Description Verbose Logging Detailed operation logs gRPC Debug Log all RPC calls Dry Run Test without real trading (<code>ENABLE_TRADING=0</code>) Ping Connection health check Introspection Examine object/method details"},{"location":"GLOSSARY/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>PROJECT_MAP.md \u2014 Project structure guide</li> <li>ARCHITECTURE.md \u2014 System architecture</li> <li>MT4Account BASE \u2014 Low-level API overview</li> <li>MT4Sugar API \u2014 High-level API docs</li> <li>Orchestrators \u2014 Trading workflows</li> <li>Presets \u2014 Configuration presets</li> </ul>"},{"location":"GLOSSARY/#quick-tips","title":"\ud83d\udca1 Quick Tips","text":""},{"location":"GLOSSARY/#converting-between-units","title":"Converting Between Units","text":"<pre><code># Pips to price\nprice_delta = pips * pip_size\n# Example: 20 pips * 0.0001 = 0.0020\n\n# Price to pips\npips = price_delta / pip_size\n# Example: 0.0020 / 0.0001 = 20 pips\n\n# Risk to lot\nlot = (equity * risk_percent / 100) / (sl_pips * pip_value)\n# Example: (1000 * 1.0 / 100) / (20 * 0.10) = 0.50 lot\n</code></pre>"},{"location":"GLOSSARY/#common-conversions","title":"Common Conversions","text":"From To Formula Lot \u2192 Units 1.0 lot = 100,000 units <code>lot * 100000</code> Pips \u2192 Price (EURUSD) 20 pips = 0.0020 <code>pips * 0.0001</code> Spread \u2192 Cost 2 pip spread, 1 lot <code>2 * pip_value * lot</code> % Risk \u2192 $Risk 1% of $1000 <code>1000 * 0.01 = $10</code> <p>\"May your spreads be tight, your fills be clean, and your equity grow steadily. \ud83d\udcd6\"</p>"},{"location":"PROJECT_MAP/","title":"PyMT4 \u2014 Project Map &amp; Layers","text":""},{"location":"PROJECT_MAP/#0-tldr","title":"0) TL;DR","text":"<ul> <li>You edit (green): <code>app/</code>, <code>examples/</code>, <code>Strategy/</code>, <code>docs/</code>, <code>main*.py</code>, <code>appsettings.json</code>.</li> <li>Don't edit (lock): <code>package/MetaRpcMT4/*_pb2*.py</code> (generated gRPC stubs), build artifacts.</li> <li>Start here: <code>main_sugar.py</code> or <code>examples/Call_sugar.py</code> \u2192 verify connection \u2192 then build strategies in <code>Strategy/</code>.</li> <li>Danger zone: everything that can place/modify/close orders \u2014 see <code>app/MT4Service_Trade_mod.py</code>. \u2622\ufe0f</li> </ul> <p>Legend: \ud83d\udfe2 = safe to edit, \ud83d\udd12 = generated/infra, \ud83c\udfad = orchestrators, \u2699\ufe0f = presets, \ud83d\udcda = docs, \ud83e\udde0 = core logic, \ud83d\udd0c = integration, \ud83e\udded = examples, \ud83c\udf6c = sugar API.</p>"},{"location":"PROJECT_MAP/#1-high-level-project-map","title":"1) High-Level Project Map","text":"<pre><code>PyMT4/\n\u251c\u2500\u2500 app/                    \ud83d\udfe2 \ud83e\udde0 Project application code (services, sugar, helpers)\n\u251c\u2500\u2500 Strategy/               \ud83d\udfe2 \ud83c\udfad Trading orchestrators &amp; presets\n\u251c\u2500\u2500 docs/                   \ud83d\udfe2 \ud83d\udcda Documentation (guides, API specs)\n\u251c\u2500\u2500 examples/               \ud83d\udfe2 \ud83e\udded Runnable demo scripts\n\u251c\u2500\u2500 package/                \ud83d\udd12 Published package sources (incl. generated pb2)\n\u251c\u2500\u2500 main*.py                \ud83d\udfe2 Entry points (low_level, sugar, streams, trade_mod)\n\u251c\u2500\u2500 appsettings.json        \ud83d\udfe2 Connection settings\n\u251c\u2500\u2500 settings.json           \ud83d\udfe2 Project settings\n\u251c\u2500\u2500 README.md               \ud83d\udfe2 Project overview\n\u2514\u2500\u2500 mkdocs.yml              \ud83d\udfe2 Docs site config\n</code></pre>"},{"location":"PROJECT_MAP/#11-app-core-sdk-wrappers","title":"1.1 <code>app/</code> (core SDK wrappers)","text":"<pre><code>\ud83d\udfe2 app/\n\u251c\u2500\u2500 Helper/                  Configuration, hooks, patches, rate limiting\n\u2502   \u251c\u2500\u2500 config.py            Settings loader\n\u2502   \u251c\u2500\u2500 errors.py            Custom exceptions\n\u2502   \u251c\u2500\u2500 hooks.py             Event hooks system\n\u2502   \u251c\u2500\u2500 patch_mt4_account.py Compatibility patches\n\u2502   \u251c\u2500\u2500 rate_limit.py        Rate limiting for API calls\n\u2502   \u2514\u2500\u2500 Design/              Architecture notes\n\u251c\u2500\u2500 MT4Service.py            \ud83d\udd0c Core service wrapper (low-level API)\n\u251c\u2500\u2500 MT4Service_Trade_mod.py \u2622\ufe0f Trading-focused service wrapper\n\u251c\u2500\u2500 MT4Sugar.py              \ud83c\udf6c High-level sugar API (pip-based, user-friendly)\n\u2514\u2500\u2500 __init__.py\n</code></pre> <p>Key files:</p> <ul> <li><code>MT4Service.py</code> \u2014 central async client/service wrapper for low-level MT4 API. \ud83d\udd0c</li> <li><code>MT4Service_Trade_mod.py</code> \u2014 trading operations wrapper (market/pending, modify, close). \u2622\ufe0f</li> <li><code>MT4Sugar.py</code> \u2014 high-level API with pip-based operations, auto lot calculation, convenience methods. \ud83c\udf6c</li> <li><code>Helper/config.py</code> \u2014 loads appsettings.json and environment variables. \ud83e\udde0</li> <li><code>Helper/hooks.py</code> \u2014 event system for pre/post operation hooks. \ud83e\udde0</li> <li><code>Helper/patch_mt4_account.py</code> \u2014 compatibility patches for MT4 quirks. \ud83e\udde9</li> <li><code>Helper/rate_limit.py</code> \u2014 prevents API rate limit violations. \ud83d\udee1\ufe0f</li> </ul>"},{"location":"PROJECT_MAP/#12-strategy-orchestrators-presets","title":"1.2 <code>Strategy/</code> (orchestrators &amp; presets)","text":"<pre><code>\ud83c\udfad Strategy/\n\u251c\u2500\u2500 orchestrator/            13 ready-to-use trading scenarios\n\u2502   \u251c\u2500\u2500 market_one_shot.py           \ud83d\ude80 Instant market execution\n\u2502   \u251c\u2500\u2500 pending_bracket.py           \u23f0 Limit order with timeout\n\u2502   \u251c\u2500\u2500 spread_guard.py              \ud83d\udcb0 Cost protection filter\n\u2502   \u251c\u2500\u2500 session_guard.py             \ud83d\udd50 Time window control\n\u2502   \u251c\u2500\u2500 oco_straddle.py              \ud83d\udd00 Two-way breakout entry\n\u2502   \u251c\u2500\u2500 bracket_trailing_activation.py \ud83d\udcc8 Conditional trailing\n\u2502   \u251c\u2500\u2500 equity_circuit_breaker.py    \ud83d\uded1 Drawdown protection\n\u2502   \u251c\u2500\u2500 dynamic_deviation_guard.py   \ud83c\udfaf Adaptive slippage\n\u2502   \u251c\u2500\u2500 rollover_avoidance.py        \ud83d\udcb8 Swap time protection\n\u2502   \u251c\u2500\u2500 grid_dca_common_sl.py        \ud83d\udcca Grid trading with shared SL\n\u2502   \u251c\u2500\u2500 kill_switch_review.py        \ud83d\udd34 Emergency stop\n\u2502   \u251c\u2500\u2500 ladder_builder.py            \ud83e\ude9c Gradual position building\n\u2502   \u2514\u2500\u2500 cleanup.py                   \ud83e\uddf9 Close/cancel all\n\u251c\u2500\u2500 presets/                 40+ pre-configured trading profiles\n\u2502   \u251c\u2500\u2500 risk.py              \ud83c\udfaf Basic risk (Conservative, Balanced, Aggressive, Scalper, Walker)\n\u2502   \u251c\u2500\u2500 risk_atr.py          \ud83d\udcc8 ATR-based adaptive risk\n\u2502   \u251c\u2500\u2500 risk_profiles.py     \ud83c\udfb2 Symbol+style combinations\n\u2502   \u251c\u2500\u2500 risk_session.py      \ud83d\udd50 Session-based risk\n\u2502   \u251c\u2500\u2500 strategy.py          \ud83d\udccb Strategy base classes\n\u2502   \u2514\u2500\u2500 strategy_symbols.py  \ud83d\udcb1 30+ symbol presets (EURUSD, XAUUSD, BTCUSD...)\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"PROJECT_MAP/#13-examples-runnable-scripts","title":"1.3 <code>examples/</code> (runnable scripts)","text":"<pre><code>\ud83e\udded examples/\n\u251c\u2500\u2500 Low_level_call.py        \ud83d\udd27 Low-level API demo (19 methods)\n\u251c\u2500\u2500 Call_sugar.py            \ud83c\udf6c Sugar API demo (~20 methods)\n\u251c\u2500\u2500 Orchestrator_demo.py     \ud83c\udfad Orchestrators demo (4 scenarios)\n\u251c\u2500\u2500 Presets_demo.py          \u2699\ufe0f Presets demo (40+ presets)\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"PROJECT_MAP/#14-mainpy-entry-points","title":"1.4 <code>main*.py</code> (entry points)","text":"<pre><code>\ud83d\udfe2 Root level/\n\u251c\u2500\u2500 main_low_level.py        Entry point for low-level API demos\n\u251c\u2500\u2500 main_sugar.py            Entry point for sugar API demos\n\u251c\u2500\u2500 main_streams.py          Entry point for streaming demos\n\u2514\u2500\u2500 main_trade_mod.py        Entry point for trading operations demos\n</code></pre>"},{"location":"PROJECT_MAP/#15-docs-documentation","title":"1.5 <code>docs/</code> (documentation)","text":"<pre><code>\ud83d\udcda docs/\n\u251c\u2500\u2500 MT4Account/              Low-level API documentation\n\u2502   \u251c\u2500\u2500 BASE.md              \ud83d\uddfa\ufe0f Master overview\n\u2502   \u251c\u2500\u2500 Account_Information/ Account balance/equity/margins\n\u2502   \u251c\u2500\u2500 Market_quota_symbols/ Quotes, symbols, ticks, history\n\u2502   \u251c\u2500\u2500 Orders_Positions_History/ Open positions, tickets\n\u2502   \u251c\u2500\u2500 Trading_Actions/     Order placement, modification, closing\n\u2502   \u2514\u2500\u2500 Streams/             Real-time data streams\n\u251c\u2500\u2500 MT4Sugar/                High-level sugar API docs\n\u2502   \u251c\u2500\u2500 Core_Defaults.md     Connection, defaults management\n\u2502   \u251c\u2500\u2500 Symbols_Quotes.md    Symbol info, quotes (8 methods)\n\u2502   \u251c\u2500\u2500 Market_Data.md       Bars, ticks, price waiting\n\u2502   \u251c\u2500\u2500 Math_Risk.md         Risk calculations, lot sizing (10 methods)\n\u2502   \u251c\u2500\u2500 Order_Management.md  Modify, close operations (7 methods)\n\u2502   \u251c\u2500\u2500 Order_Placement.md   Market, limit, stop orders (7 methods)\n\u2502   \u2514\u2500\u2500 Automation.md        Trailing stops, auto-breakeven\n\u251c\u2500\u2500 Main/                    Entry point documentation\n\u2502   \u251c\u2500\u2500 main_low_level.md    Low-level API guide\n\u2502   \u251c\u2500\u2500 main_streams.md      Streaming API guide\n\u2502   \u251c\u2500\u2500 main_sugar.md        Sugar API guide\n\u2502   \u2514\u2500\u2500 main_trade_mod.md    Trading operations guide\n\u251c\u2500\u2500 Strategy/                Strategy documentation\n\u2502   \u251c\u2500\u2500 All_about_orchestrator.md \ud83c\udfad Orchestrators guide (13 orchestrators)\n\u2502   \u2514\u2500\u2500 All_about_presets.md      \u2699\ufe0f Presets guide (40+ presets)\n\u251c\u2500\u2500 Examples/                Examples documentation\n\u2502   \u2514\u2500\u2500 All_about_examples.md     \ud83d\udcda Examples overview\n\u251c\u2500\u2500 Examples_of_illustrations/    Screenshots (LL.bmp, Sugar.bmp, Stream.bmp, Mod.bmp)\n\u2514\u2500\u2500 PROJECT_MAP.md           \ud83d\uddfa\ufe0f This file\n</code></pre>"},{"location":"PROJECT_MAP/#16-packagemetarpcmt4-generated-stubs-dont-touch","title":"1.6 <code>package/MetaRpcMT4</code> (generated stubs \u2014 don't touch)","text":"<pre><code>\ud83d\udd12 package/MetaRpcMT4/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 mrpc_mt4_error_pb2(.py|_grpc.py)          \ud83d\udd12 Error codes\n\u251c\u2500\u2500 mt4_term_api_*_pb2(.py|_grpc.py)          \ud83d\udd12 Generated request/response messages &amp; service stubs\n\u251c\u2500\u2500 mt4_account.py                             \ud83d\udfe1 Low-level wrapper (avoid editing)\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"PROJECT_MAP/#2-who-edits-what-policy","title":"2) Who edits what (policy)","text":"<ul> <li>\ud83d\udfe2 Edit freely: <code>app/*</code>, <code>Strategy/*</code>, <code>examples/*</code>, <code>main*.py</code>, <code>appsettings.json</code>, <code>docs/*</code>.</li> <li>\ud83d\uded1 Don't edit: <code>package/MetaRpcMT4/*_pb2*.py</code> (regenerate from proto instead).</li> <li>\ud83e\uddea Tests: put local tests in <code>package/tests</code> or add <code>tests/</code> at repo root.</li> </ul>"},{"location":"PROJECT_MAP/#3-project-trees","title":"3) Project Trees","text":""},{"location":"PROJECT_MAP/#31-top-level-depth-1","title":"3.1 Top-level (depth 1)","text":"<pre><code>PyMT4/\n\u251c\u2500\u2500 app/                     Core SDK wrappers\n\u251c\u2500\u2500 Strategy/                Orchestrators &amp; presets\n\u251c\u2500\u2500 docs/                    Documentation\n\u251c\u2500\u2500 examples/                Demo scripts\n\u251c\u2500\u2500 package/                 Generated gRPC stubs\n\u251c\u2500\u2500 main_low_level.py        Low-level API entry\n\u251c\u2500\u2500 main_sugar.py            Sugar API entry\n\u251c\u2500\u2500 main_streams.py          Streaming API entry\n\u251c\u2500\u2500 main_trade_mod.py        Trading operations entry\n\u251c\u2500\u2500 appsettings.json         Connection config\n\u251c\u2500\u2500 settings.json            Project settings\n\u251c\u2500\u2500 mkdocs.yml               Docs config\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"PROJECT_MAP/#32-app-depth-2","title":"3.2 <code>app/</code> (depth 2)","text":"<pre><code>app/\n\u251c\u2500\u2500 Helper/\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 errors.py\n\u2502   \u251c\u2500\u2500 hooks.py\n\u2502   \u251c\u2500\u2500 patch_mt4_account.py\n\u2502   \u251c\u2500\u2500 rate_limit.py\n\u2502   \u2514\u2500\u2500 Design/\n\u251c\u2500\u2500 MT4Service.py\n\u251c\u2500\u2500 MT4Service_Trade_mod.py\n\u251c\u2500\u2500 MT4Sugar.py\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"PROJECT_MAP/#33-strategy-depth-2","title":"3.3 <code>Strategy/</code> (depth 2)","text":"<pre><code>Strategy/\n\u251c\u2500\u2500 orchestrator/\n\u2502   \u251c\u2500\u2500 market_one_shot.py\n\u2502   \u251c\u2500\u2500 pending_bracket.py\n\u2502   \u251c\u2500\u2500 spread_guard.py\n\u2502   \u251c\u2500\u2500 session_guard.py\n\u2502   \u251c\u2500\u2500 oco_straddle.py\n\u2502   \u251c\u2500\u2500 bracket_trailing_activation.py\n\u2502   \u251c\u2500\u2500 equity_circuit_breaker.py\n\u2502   \u251c\u2500\u2500 dynamic_deviation_guard.py\n\u2502   \u251c\u2500\u2500 rollover_avoidance.py\n\u2502   \u251c\u2500\u2500 grid_dca_common_sl.py\n\u2502   \u251c\u2500\u2500 kill_switch_review.py\n\u2502   \u251c\u2500\u2500 ladder_builder.py\n\u2502   \u2514\u2500\u2500 cleanup.py\n\u251c\u2500\u2500 presets/\n\u2502   \u251c\u2500\u2500 risk.py\n\u2502   \u251c\u2500\u2500 risk_atr.py\n\u2502   \u251c\u2500\u2500 risk_profiles.py\n\u2502   \u251c\u2500\u2500 risk_session.py\n\u2502   \u251c\u2500\u2500 strategy.py\n\u2502   \u2514\u2500\u2500 strategy_symbols.py\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"PROJECT_MAP/#34-examples-depth-1","title":"3.4 <code>examples/</code> (depth 1)","text":"<pre><code>examples/\n\u251c\u2500\u2500 Low_level_call.py\n\u251c\u2500\u2500 Call_sugar.py\n\u251c\u2500\u2500 Orchestrator_demo.py\n\u251c\u2500\u2500 Presets_demo.py\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"PROJECT_MAP/#35-docs-structure-key-files","title":"3.5 <code>docs/</code> structure (key files)","text":"<pre><code>docs/\n\u251c\u2500\u2500 MT4Account/BASE.md                        \ud83d\uddfa\ufe0f Low-level API master overview\n\u251c\u2500\u2500 MT4Sugar/*.md                             \ud83c\udf6c Sugar API methods (7 files)\n\u251c\u2500\u2500 Main/*.md                                 \ud83d\udcd6 Entry point guides (4 files)\n\u251c\u2500\u2500 Strategy/All_about_orchestrator.md        \ud83c\udfad Orchestrators guide\n\u251c\u2500\u2500 Strategy/All_about_presets.md             \u2699\ufe0f Presets guide\n\u251c\u2500\u2500 Examples/All_about_examples.md            \ud83d\udcda Examples overview\n\u251c\u2500\u2500 Examples_of_illustrations/*.bmp           \ud83d\uddbc\ufe0f Screenshots\n\u2514\u2500\u2500 PROJECT_MAP.md                            \ud83d\uddfa\ufe0f This file\n</code></pre>"},{"location":"PROJECT_MAP/#4-how-to-build-a-trading-strategy-step-by-step","title":"4) How to build a trading strategy (step-by-step)","text":""},{"location":"PROJECT_MAP/#level-1-quick-start-sugar-api","title":"Level 1: Quick Start (Sugar API)","text":"<pre><code>from app.MT4Sugar import MT4Sugar\n\nsugar = MT4Sugar(...)\nawait sugar.ensure_connected()\n\n# Simple market order with pip-based stops\nawait sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40)\n</code></pre>"},{"location":"PROJECT_MAP/#level-2-using-presets","title":"Level 2: Using Presets","text":"<pre><code>from Strategy.presets import MarketEURUSD, Balanced\nfrom Strategy.orchestrator.market_one_shot import run_market_one_shot\n\n# Combine strategy preset + risk preset\nresult = await run_market_one_shot(svc, MarketEURUSD, Balanced)\n</code></pre>"},{"location":"PROJECT_MAP/#level-3-custom-orchestrator","title":"Level 3: Custom Orchestrator","text":"<pre><code>from Strategy.orchestrator.spread_guard import market_with_spread_guard\nfrom Strategy.orchestrator.session_guard import run_with_session_guard\n\n# Combine multiple orchestrators\nresult = await run_with_session_guard(\n    svc=svc,\n    runner_coro_factory=lambda: market_with_spread_guard(\n        svc, MarketEURUSD, Balanced, max_spread_pips=2.0\n    ),\n    windows=[('08:00', '17:00')],\n    tz='Europe/London'\n)\n</code></pre>"},{"location":"PROJECT_MAP/#level-4-custom-strategy","title":"Level 4: Custom Strategy","text":"<ol> <li>Start with Sugar API \u2014 sketch basic logic in <code>examples/</code></li> <li>Create preset \u2014 define your strategy in <code>Strategy/presets/</code></li> <li>Build orchestrator \u2014 compose complex flows in <code>Strategy/orchestrator/</code></li> <li>Combine \u2014 use multiple guards and automation features</li> </ol>"},{"location":"PROJECT_MAP/#5-api-layers-from-low-to-high","title":"5) API Layers (from low to high)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Strategy Orchestrators &amp; Presets           \u2502 \ud83c\udfad Highest level\n\u2502  (market_one_shot, Balanced, etc.)          \u2502 Ready-to-use scenarios\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MT4Sugar API                               \u2502  \ud83c\udf6c High level\n\u2502  (pip-based, auto-calculation, friendly)    \u2502 User-friendly wrappers\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MT4Service / MT4Service_Trade_mod          \u2502 \ud83d\udd0c Medium level\n\u2502  (service wrappers, connection mgmt)        \u2502 Service orchestration\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  package/MetaRpcMT4/mt4_account.py          \u2502 \ud83d\udd27 Low level\n\u2502  (direct gRPC wrappers)                     \u2502 Generated stubs\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193 gRPC\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MT4 Terminal                               \u2502  \ud83d\udcbb Broker connection\n\u2502  (actual trading platform)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Choose your level: - Orchestrators \u2014 for complete trading strategies (recommended) - Sugar API \u2014 for custom logic with convenience methods - Service wrappers \u2014 for fine control with connection management - Low-level API \u2014 for maximum control (experts only)</p>"},{"location":"PROJECT_MAP/#6-configuration-files","title":"6) Configuration Files","text":""},{"location":"PROJECT_MAP/#appsettingsjson-connection-config","title":"<code>appsettings.json</code> (connection config)","text":"<pre><code>{\n  \"access\": [\"host:port\", \"host:port\"],\n  \"login\": \"12345678\",\n  \"password\": \"your_password\",\n  \"server\": \"MetaQuotes-Demo\"\n}\n</code></pre>"},{"location":"PROJECT_MAP/#environment-variables-override-appsettings","title":"Environment Variables (override appsettings)","text":"<pre><code>MT4_LOGIN=12345678\nMT4_PASSWORD=your_password\nMT4_SERVER=MetaQuotes-Demo\nENABLE_TRADING=1  # Enable real trading (default: 0)\n</code></pre>"},{"location":"PROJECT_MAP/#7-documentation-navigation","title":"7) Documentation Navigation","text":""},{"location":"PROJECT_MAP/#by-role","title":"By Role:","text":"<p>Beginner: 1. Start: Examples Overview 2. Try: <code>python examples/Call_sugar.py</code> 3. Learn: Sugar API docs</p> <p>Intermediate: 1. Read: Orchestrators Guide 2. Read: Presets Guide 3. Try: <code>python examples/Orchestrator_demo.py</code></p> <p>Advanced: 1. Read: MT4Account BASE 2. Study: Low-level API docs 3. Try: <code>python examples/Low_level_call.py</code></p>"},{"location":"PROJECT_MAP/#by-api-level","title":"By API Level:","text":"Level Documentation Examples Code \ud83c\udfad Orchestrators All_about_orchestrator.md <code>Orchestrator_demo.py</code> <code>Strategy/orchestrator/</code> \u2699\ufe0f Presets All_about_presets.md <code>Presets_demo.py</code> <code>Strategy/presets/</code> \ud83c\udf6c Sugar API MT4Sugar/ <code>Call_sugar.py</code>, <code>main_sugar.py</code> <code>app/MT4Sugar.py</code> \ud83d\udd0c Service Main/ <code>main_trade_mod.py</code> <code>app/MT4Service*.py</code> \ud83d\udd27 Low-level MT4Account/ <code>Low_level_call.py</code>, <code>main_low_level.py</code> <code>package/MetaRpcMT4/</code>"},{"location":"PROJECT_MAP/#8-common-workflows","title":"8) Common Workflows","text":""},{"location":"PROJECT_MAP/#workflow-1-test-connection","title":"Workflow 1: Test Connection","text":"<pre><code>python main_sugar.py  # or examples/Call_sugar.py\n</code></pre>"},{"location":"PROJECT_MAP/#workflow-2-run-strategy-with-presets","title":"Workflow 2: Run Strategy with Presets","text":"<pre><code>python examples/Orchestrator_demo.py\n</code></pre>"},{"location":"PROJECT_MAP/#workflow-3-build-custom-strategy","title":"Workflow 3: Build Custom Strategy","text":"<ol> <li>Edit <code>Strategy/presets/strategy_symbols.py</code> \u2014 add your symbol</li> <li>Edit <code>Strategy/presets/risk.py</code> \u2014 customize risk profile</li> <li>Use in orchestrator or create new one in <code>Strategy/orchestrator/</code></li> </ol>"},{"location":"PROJECT_MAP/#workflow-4-debug-low-level-api","title":"Workflow 4: Debug Low-Level API","text":"<pre><code>python examples/Low_level_call.py\npython main_low_level.py\n</code></pre>"},{"location":"PROJECT_MAP/#9-safety-checklist","title":"9) Safety Checklist \u2705","text":"<p>Before live trading:</p> <ul> <li>[ ] Test on demo account first</li> <li>[ ] Set <code>ENABLE_TRADING=0</code> to test syntax (dry run)</li> <li>[ ] Verify <code>appsettings.json</code> credentials</li> <li>[ ] Check connection: <code>await sugar.ping()</code></li> <li>[ ] Test with small lots (0.01)</li> <li>[ ] Set stop losses on all positions</li> <li>[ ] Use <code>Conservative</code> risk preset initially</li> <li>[ ] Enable rate limiting (<code>Helper/rate_limit.py</code>)</li> <li>[ ] Monitor equity circuit breaker</li> <li>[ ] Review logs before production</li> </ul>"},{"location":"PROJECT_MAP/#10-quick-reference","title":"10) Quick Reference","text":""},{"location":"PROJECT_MAP/#key-classes","title":"Key Classes:","text":"<ul> <li><code>MT4Service</code> \u2014 core low-level wrapper</li> <li><code>MT4Service_Trade_mod</code> \u2014 trading operations wrapper</li> <li><code>MT4Sugar</code> \u2014 high-level convenience API</li> <li><code>StrategyPreset</code> \u2014 symbol/entry configuration</li> <li><code>RiskPreset</code> \u2014 risk management configuration</li> </ul>"},{"location":"PROJECT_MAP/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Pips \u2014 universal unit for SL/TP in Sugar API</li> <li>Magic numbers \u2014 organize orders by strategy (771-859 range)</li> <li>Deviation \u2014 slippage tolerance (pips)</li> <li>Orchestrators \u2014 complete trading workflows</li> <li>Presets \u2014 reusable configurations</li> </ul>"},{"location":"PROJECT_MAP/#key-files-to-check","title":"Key Files to Check:","text":"<ul> <li>Connection issues \u2192 <code>app/Helper/config.py</code></li> <li>Trading errors \u2192 <code>app/Helper/errors.py</code></li> <li>API limits \u2192 <code>app/Helper/rate_limit.py</code></li> <li>MT4 quirks \u2192 <code>app/Helper/patch_mt4_account.py</code></li> </ul> <p>\"Wishing you tight spreads, clean fills, and profits that compound. \ud83d\udfe2\"</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#MetaRpcMT4.mt4_account","title":"mt4_account","text":""},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account","title":"MT4Account","text":"Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>class MT4Account:\n    def __init__(self, user: int, password: str, grpc_server: Optional[str] = None, id_: Optional[str] = None):\n        self.user = user\n        self.password = password\n        self.grpc_server = grpc_server or \"mt4.mrpc.pro:443\"   # default server\n        self.id = id_\n\n        # Async gRPC secure channel (TLS)\n        self.channel = grpc.aio.secure_channel(\n            self.grpc_server,\n            grpc.ssl_channel_credentials()\n        )\n\n        # Init stubs directly (like in C#)\n        self.connection_client = connection_pb2_grpc.ConnectionStub(self.channel)\n        self.subscription_client = subscriptions_pb2_grpc.SubscriptionServiceStub(self.channel)\n        self.account_client = account_helper_pb2_grpc.AccountHelperStub(self.channel)\n        self.trade_client = trading_helper_pb2_grpc.TradingHelperStub(self.channel)\n        self.market_info_client = market_info_pb2_grpc.MarketInfoStub(self.channel)\n\n        # Connection state\n        self.host = None\n        self.port = None\n        self.server_name = None\n        self.base_chart_symbol = None\n        self.connect_timeout_seconds = 30\n\n\n    # === Utility: headers ===\n    def get_headers(self):\n        return [(\"id\", self.id)]\n\n    # === Utility: reconnect ===\n    async def reconnect(self, deadline: Optional[datetime] = None):\n        if self.server_name:\n            await self.connect_by_server_name(self.server_name, self.base_chart_symbol or \"EURUSD\",\n                                              True, self.connect_timeout_seconds, deadline)\n        elif self.host:\n            await self.connect_by_host_port(self.host, self.port or 443,\n                                            self.base_chart_symbol or \"EURUSD\", True,\n                                            self.connect_timeout_seconds, deadline)\n\n    # === Core retry wrapper ===\n    async def execute_with_reconnect(\n        self,\n        grpc_call: Callable[[list[tuple[str, str]]], Awaitable[Any]],\n        error_selector: Callable[[Any], Optional[Any]],\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        while cancellation_event is None or not cancellation_event.is_set():\n            headers = self.get_headers()\n            try:\n                res = await grpc_call(headers)\n            except grpc.aio.AioRpcError as ex:\n                if ex.code() == grpc.StatusCode.UNAVAILABLE:\n                    await asyncio.sleep(0.5)\n                    await self.reconnect(deadline)\n                    continue\n                raise\n\n            error = error_selector(res)\n            if error and error.error_code in (\"TERMINAL_INSTANCE_NOT_FOUND\", \"TERMINAL_REGISTRY_TERMINAL_NOT_FOUND\"):\n                await asyncio.sleep(0.5)\n                await self.reconnect(deadline)\n                continue\n\n            if res.HasField(\"error\") and res.error.error_message:\n                raise ApiExceptionMT4(res.error)\n\n            return res\n\n        raise asyncio.CancelledError(\"The operation was canceled by the caller.\")\n\n    # === Connect methods ===\n    async def connect_by_host_port(\n        self,\n        host: str,\n        port: int = 443,\n        base_chart_symbol: str = \"EURUSD\",\n        wait_for_terminal_is_alive: bool = True,\n        timeout_seconds: int = 30,\n        deadline: Optional[datetime] = None,\n    ):\n        #Build connect request (from your proto)\n        request = connection_pb2.ConnectRequest(\n            user=self.user,\n            password=self.password,\n            host=host,\n            port=port,\n            base_chart_symbol=base_chart_symbol,\n            wait_for_terminal_is_alive=wait_for_terminal_is_alive,\n            terminal_readiness_waiting_timeout_seconds=timeout_seconds,\n        )\n\n        headers = []\n        if self.id:\n            headers.append((\"id\", str(self.id)))\n\n        res = await self.connection_client.Connect(\n            request,\n            metadata=headers,\n            timeout=30.0 if deadline is None else (deadline - datetime.utcnow()).total_seconds(),\n        )\n\n        if res.HasField(\"error\") and res.error.error_message:\n            raise ApiExceptionMT4(res.error)\n\n        # Save state\n        self.host = host\n        self.port = port\n        self.base_chart_symbol = base_chart_symbol\n        self.connect_timeout_seconds = timeout_seconds\n        self.id = res.data.terminalInstanceGuid\n\n    async def connect_by_server_name(\n        self,\n        server_name: str,\n        base_chart_symbol: str = \"EURUSD\",\n        wait_for_terminal_is_alive: bool = True,\n        timeout_seconds: int = 30,\n        deadline: Optional[datetime] = None,\n    ):\n        # Build connect request (from your proto)\n        request = connection_pb2.ConnectExRequest(\n            user=self.user,\n            password=self.password,\n            mt_cluster_name=server_name,\n            base_chart_symbol=base_chart_symbol,\n            terminal_readiness_waiting_timeout_seconds=timeout_seconds,\n        )\n\n        headers = []\n        if self.id:\n            headers.append((\"id\", str(self.id)))\n        res = await self.connection_client.ConnectEx(\n            request,\n            metadata=headers,\n            timeout=30.0 if deadline is None else (deadline - datetime.utcnow()).total_seconds(),\n        )\n\n        if res.HasField(\"error\") and res.error.error_message:\n            raise ApiExceptionMT4(res.error)\n\n        # Save state\n        self.server_name = server_name\n        self.base_chart_symbol = base_chart_symbol\n        self.connect_timeout_seconds = timeout_seconds\n        self.id = res.data.terminal_instance_guid\n\n\n#\n#    Account helper --------------------------------------------------------------------------------------------------------\n#    \n\n    async def account_summary(\n        self,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Gets the summary information for a trading account asynchronously.\n\n        Args:\n            deadline (datetime, optional): Deadline after which the request will be canceled\n                if not completed.\n            cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n        Returns:\n            AccountSummaryData: The server's response containing account summary data.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the response.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        \"\"\"\n        if not (self.host or self.server_name):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = account_helper_pb2.AccountSummaryRequest()\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = (deadline - datetime.utcnow()).total_seconds()\n                if timeout &lt; 0:\n                    timeout = 0\n            return await self.account_client.AccountSummary(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n\n        return res.data\n\n    async def opened_orders(\n        self,\n        sort_mode: account_helper_pb2.EnumOpenedOrderSortType = account_helper_pb2.EnumOpenedOrderSortType.SORT_BY_OPEN_TIME_ASC,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Gets the currently opened orders and positions for the connected account asynchronously.\n\n        Args:\n            sort_mode (EnumOpenedOrderSortType): The sort mode for the opened orders\n                (e.g. SORT_BY_OPEN_TIME_ASC, SORT_BY_ORDER_TICKET_ID_DESC).\n            deadline (datetime, optional): Deadline after which the request will be canceled\n                if not completed.\n            cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n        Returns:\n            OpenedOrdersData: The result containing opened orders and positions.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the response.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        # Build request\n        request = account_helper_pb2.OpenedOrdersRequest(sort_type=sort_mode)\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = (deadline - datetime.utcnow()).total_seconds()\n                if timeout &lt; 0:\n                    timeout = 0\n            return await self.account_client.OpenedOrders(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        # Execute with automatic reconnect logic\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n\n        return res.data\n\n\n    async def opened_orders_tickets(\n        self,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Gets the list of tickets for all currently opened orders.\n\n        Returns:\n            OpenedOrdersTicketsData: The result containing the list of tickets.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the response.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = account_helper_pb2.OpenedOrdersTicketsRequest()\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = (deadline - datetime.utcnow()).total_seconds()\n                if timeout &lt; 0:\n                    timeout = 0\n            return await self.account_client.OpenedOrdersTickets(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n\n        return res.data\n\n\n    async def orders_history(\n        self,\n        sort_mode: account_helper_pb2.EnumOrderHistorySortType = account_helper_pb2.EnumOrderHistorySortType.HISTORY_SORT_BY_CLOSE_TIME_DESC,\n        from_time: Optional[datetime] = None,\n        to_time: Optional[datetime] = None,\n        page_number: Optional[int] = None,\n        items_per_page: Optional[int] = None,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Gets the order history for the connected account.\n\n        Args:\n            sort_mode (EnumOrderHistorySortType): Sorting mode for orders.\n            from_time (datetime, optional): Start of the history period.\n            to_time (datetime, optional): End of the history period.\n            page_number (int, optional): Page number for pagination.\n            items_per_page (int, optional): Items per page.\n\n        Returns:\n            OrdersHistoryData: The result containing historical orders.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the response.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        # Convert datetime \u2192 Timestamp (protobuf)\n        ts_from = None\n        ts_to = None\n        if from_time:\n            ts_from = Timestamp()\n            ts_from.FromDatetime(from_time)\n        if to_time:\n            ts_to = Timestamp()\n            ts_to.FromDatetime(to_time)\n\n        request = account_helper_pb2.OrdersHistoryRequest(\n            input_sort_mode=sort_mode,\n            input_from=ts_from,\n            input_to=ts_to,\n            page_number=page_number,\n            items_per_page=items_per_page,\n        )\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = (deadline - datetime.utcnow()).total_seconds()\n                if timeout &lt; 0:\n                    timeout = 0\n            return await self.account_client.OrdersHistory(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n\n        return res.data\n\n\n    async def symbol_params_many(\n        self,\n        symbol_name: Optional[str] = None,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Retrieves symbol parameters (for one or all symbols).\n\n        Args:\n            symbol_name (str, optional): Symbol name. If None, returns all.\n\n        Returns:\n            SymbolParamsManyData: The result containing symbol parameters.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the response.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = account_helper_pb2.SymbolParamsManyRequest(symbol_name=symbol_name or \"\")\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = (deadline - datetime.utcnow()).total_seconds()\n                if timeout &lt; 0:\n                    timeout = 0\n            return await self.account_client.SymbolParamsMany(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n\n        return res.data\n\n\n    async def tick_value_with_size(\n        self,\n        symbol_names: list[str],\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Gets tick value, tick size, and contract size for multiple symbols.\n\n        Args:\n            symbol_names (list[str]): List of symbol names.\n\n        Returns: \n            TickValueWithSizeData: The result containing tick values and sizes.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the response.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = account_helper_pb2.TickValueWithSizeRequest(symbol_names=symbol_names)\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = (deadline - datetime.utcnow()).total_seconds()\n                if timeout &lt; 0:\n                    timeout = 0\n            return await self.account_client.TickValueWithSize(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n\n        return res.data\n\n#\n#    Streams --------------------------------------------------------------------------------------------------------\n#    \n\n    async def execute_stream_with_reconnect(\n        self,\n        request: Any,\n        stream_invoker: Callable[[Any, list[tuple[str, str]]], grpc.aio.StreamStreamCall],\n        get_error: Callable[[Any], Optional[Any]],\n        get_data: Callable[[Any], Any],\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; AsyncGenerator[Any, None]:\n        \"\"\"\n        Executes a gRPC server-streaming call with automatic reconnection logic on recoverable errors.\n\n        Args:\n            request: The request object to initiate the stream with.\n            stream_invoker (Callable): A function that opens the stream. It receives the request and metadata headers,\n                and returns an async streaming call.\n            get_error (Callable): A function that extracts the error object (if any) from a reply.\n                Return an object with .error_code == \"TERMINAL_INSTANCE_NOT_FOUND\" to trigger reconnect,\n                or any non-null error to raise ApiExceptionMT5.\n            get_data (Callable): A function that extracts the data object from a reply. If it returns None, the\n                message is skipped.\n            cancellation_event (asyncio.Event, optional): Event to cancel streaming and reconnection attempts.\n\n        Yields:\n            Extracted data items streamed from the server.\n\n        Raises:\n            ConnectExceptionMT4: If reconnection logic fails due to missing account context.\n            ApiExceptionMT4: When the stream response contains a known API error.\n            grpc.aio.AioRpcError: If a non-recoverable gRPC error occurs.\n        \"\"\"\n        while cancellation_event is None or not cancellation_event.is_set():\n            reconnect_required = False\n            stream = None\n            try:\n                stream = stream_invoker(request, self.get_headers())\n                async for reply in stream:\n                    error = get_error(reply)\n\n                    if error and error.error_code in (\n                        \"TERMINAL_INSTANCE_NOT_FOUND\",\n                        \"TERMINAL_REGISTRY_TERMINAL_NOT_FOUND\",\n                    ):\n                        reconnect_required = True\n                        break\n\n                    if error and getattr(error, \"message\", None):\n                        raise ApiExceptionMT4(error)\n\n                    data = get_data(reply)\n                    if data is not None:\n                        yield data\n\n            except grpc.aio.AioRpcError as ex:\n                if ex.code() == grpc.StatusCode.UNAVAILABLE:\n                    reconnect_required = True\n                else:\n                    raise\n\n            finally:\n                if stream:\n                    stream.cancel()  # close stream properly\n\n            if reconnect_required:\n                await asyncio.sleep(0.5)\n                await self.reconnect()\n            else:\n                break\n\n\n    async def on_symbol_tick(\n        self,\n        symbols: list[str],\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to real-time tick data for specified symbols.\n\n        Args:\n            symbols (list[str]): The symbol names to subscribe to.\n            cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n        Yields:\n            OnSymbolTickData: Async stream of tick data responses.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an error in the stream.\n            grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n        \"\"\"\n        if not self.id:\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = subscriptions_pb2.OnSymbolTickRequest()\n        request.symbol_names.extend(symbols)\n\n        async for data in self.execute_stream_with_reconnect(\n            request=request,\n            stream_invoker=lambda req, headers: self.subscription_client.OnSymbolTick(req, metadata=headers),\n            get_error=lambda reply: reply.error,\n            get_data=lambda reply: reply.data,\n            cancellation_event=cancellation_event,\n        ):\n            yield data\n\n    async def on_trade(\n        self,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to all trade-related events: orders, deals, positions.\n\n        Args:\n            cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n        Yields:\n            OnTradeData: Trade event data.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected.\n            ApiExceptionMT4: If the server returns a known API error.\n            grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n        \"\"\"\n        if not self.id:\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = subscriptions_pb2.OnTradeRequest()\n\n        async for data in self.execute_stream_with_reconnect(\n            request=request,\n            stream_invoker=lambda req, headers: self.subscription_client.OnTrade(req, metadata=headers),\n            get_error=lambda reply: reply.error,\n            get_data=lambda reply: reply.data,\n            cancellation_event=cancellation_event,\n        ):\n            yield data\n\n\n    async def on_opened_orders_tickets(\n        self,\n        pull_interval_milliseconds: int = 500,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to live lists of opened order tickets (positions &amp; pending orders).\n\n        Args:\n            pull_interval_milliseconds (int): Server-side polling interval.\n            cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n        Yields:\n            OnOpenedOrdersTicketsData\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected.\n            ApiExceptionMT4: If the server returns a known API error.\n            grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n        \"\"\"\n        if not self.id:\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = subscriptions_pb2.OnOpenedOrdersTicketsRequest(\n            pull_interval_milliseconds=pull_interval_milliseconds\n        )\n\n        async for data in self.execute_stream_with_reconnect(\n            request=request,\n            stream_invoker=lambda req, headers: self.subscription_client.OnOpenedOrdersTickets(\n                req, metadata=headers\n            ),\n            get_error=lambda reply: reply.error,\n            get_data=lambda reply: reply.data,\n            cancellation_event=cancellation_event,\n        ):\n            yield data\n\n\n    async def on_opened_orders_profit(\n        self,\n        timer_period_milliseconds: int = 1000,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to real-time profit updates for opened orders (plus account snapshot).\n\n        Args:\n            timer_period_milliseconds (int): Server timer period for updates.\n            cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n        Yields:\n            OnOpenedOrdersProfitData\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected.\n            ApiExceptionMT4: If the server returns a known API error.\n            grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n        \"\"\"\n        if not self.id:\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = subscriptions_pb2.OnOpenedOrdersProfitRequest(\n            timer_period_milliseconds=timer_period_milliseconds\n        )\n\n        async for data in self.execute_stream_with_reconnect(\n            request=request,\n            stream_invoker=lambda req, headers: self.subscription_client.OnOpenedOrdersProfit(\n                req, metadata=headers\n            ),\n            get_error=lambda reply: reply.error,\n            get_data=lambda reply: reply.data,\n            cancellation_event=cancellation_event,\n        ):\n            yield data\n\n\n#\n# Trade functions --------------------------------------------------------------------------------------------------------\n#\n    async def order_send(\n        self,\n        symbol: str,\n        operation_type: trading_helper_pb2.OrderSendOperationType,\n        volume: float,\n        price: Optional[float] = None,\n        slippage: Optional[int] = None,\n        stoploss: Optional[float] = None,\n        takeprofit: Optional[float] = None,\n        comment: Optional[str] = None,\n        magic_number: Optional[int] = None,\n        expiration: Optional[datetime] = None,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Opens a new trade order (market or pending).\n\n        Args:\n            symbol (str): Symbol to trade, e.g. \"EURUSD\".\n            operation_type (OrderSendOperationType): Operation type (BUY, SELL, BUYLIMIT, etc.).\n            volume (float): Trade volume in lots.\n            price (float, optional): Open price for pending orders.\n            slippage (int, optional): Allowed price deviation in points.\n            stoploss (float, optional): Stop loss price.\n            takeprofit (float, optional): Take profit price.\n            comment (str, optional): Comment for the order.\n            magic_number (int, optional): Custom magic number to identify the order.\n            expiration (datetime, optional): Expiration time for pending orders.\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n        Returns:\n            OrderSendData: The server's response containing new order details.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        req = trading_helper_pb2.OrderSendRequest(\n            symbol=symbol,\n            operation_type=operation_type,\n            volume=volume,\n        )\n        if price is not None:\n            req.price = price\n        if slippage is not None:\n            req.slippage = slippage\n        if stoploss is not None:\n            req.stoploss = stoploss\n        if takeprofit is not None:\n            req.takeprofit = takeprofit\n        if comment:\n            req.comment = comment\n        if magic_number is not None:\n            req.magic_number = magic_number\n        if expiration:\n            ts = Timestamp()\n            ts.FromDatetime(expiration)\n            req.expiration.CopyFrom(ts)\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.trade_client.OrderSend(req, metadata=headers, timeout=timeout)\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n\n    async def order_modify(\n        self,\n        order_ticket: int,\n        new_price: Optional[float] = None,\n        new_stop_loss: Optional[float] = None,\n        new_take_profit: Optional[float] = None,\n        new_expiration: Optional[datetime] = None,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Modifies an existing order (price, SL/TP, expiration).\n\n        Args:\n            order_ticket (int): Ticket number of the order to modify.\n            new_price (float, optional): New open price.\n            new_stop_loss (float, optional): New stop loss.\n            new_take_profit (float, optional): New take profit.\n            new_expiration (datetime, optional): New expiration time.\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n        Returns:\n            OrderModifyData: The server's response containing modification result.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        req = trading_helper_pb2.OrderModifyRequest(order_ticket=order_ticket)\n        if new_price is not None:\n            req.new_price = new_price\n        if new_stop_loss is not None:\n            req.new_stop_loss = new_stop_loss\n        if new_take_profit is not None:\n            req.new_take_profit = new_take_profit\n        if new_expiration:\n            ts = Timestamp()\n            ts.FromDatetime(new_expiration)\n            req.new_expiration.CopyFrom(ts)\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.trade_client.OrderModify(req, metadata=headers, timeout=timeout)\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n\n    async def order_close_delete(\n        self,\n        order_ticket: int,\n        lots: Optional[float] = None,\n        closing_price: Optional[float] = None,\n        slippage: Optional[int] = None,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Closes or deletes an order (market or pending).\n\n        Args:\n            order_ticket (int): Ticket of the order to close or delete.\n            lots (float, optional): Volume to close (for partial close).\n            closing_price (float, optional): Desired closing price.\n            slippage (int, optional): Allowed price deviation in points.\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n        Returns:\n            OrderCloseDeleteData: The server's response indicating close/delete status.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        req = trading_helper_pb2.OrderCloseDeleteRequest(order_ticket=order_ticket)\n        if lots is not None:\n            req.lots = lots\n        if closing_price is not None:\n            req.closing_price = closing_price\n        if slippage is not None:\n            req.slippage = slippage\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.trade_client.OrderCloseDelete(req, metadata=headers, timeout=timeout)\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n\n    async def order_close_by(\n        self,\n        ticket_to_close: int,\n        opposite_ticket_closing_by: int,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Closes one position by another (close-by operation).\n\n        Args:\n            ticket_to_close (int): Ticket of the order being closed.\n            opposite_ticket_closing_by (int): Opposite ticket to close by.\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n        Returns:\n            OrderCloseByData: The server's response containing close-by result.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        req = trading_helper_pb2.OrderCloseByRequest(\n            ticket_to_close=ticket_to_close,\n            opposite_ticket_closing_by=opposite_ticket_closing_by,\n        )\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.trade_client.OrderCloseBy(req, metadata=headers, timeout=timeout)\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n#\n# Market info --------------------------------------------------------------------------------------------------------\n#\n\n    async def quote(\n        self,\n        symbol: str,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Retrieves the latest quote for a single symbol.\n\n        Args:\n            symbol (str): The symbol name (e.g., \"EURUSD\").\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n        Returns:\n            QuoteData: The latest bid/ask/high/low prices with timestamp.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = market_info_pb2.QuoteRequest(symbol=symbol)\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.market_info_client.Quote(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n\n    async def quote_many(\n        self,\n        symbols: list[str],\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Retrieves quotes for multiple symbols.\n\n        Args:\n            symbols (list[str]): List of symbol names (e.g., [\"EURUSD\", \"GBPUSD\"]).\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n        Returns:\n            QuoteManyData: The response containing quotes for all requested symbols.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = market_info_pb2.QuoteManyRequest(symbols=symbols)\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.market_info_client.QuoteMany(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n\n    async def symbols(\n        self,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Retrieves the full list of tradable symbols from the connected terminal.\n\n        Args:\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n        Returns:\n            SymbolsData: The response containing all available symbol names and indices.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        request = market_info_pb2.SymbolsRequest()\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.market_info_client.Symbols(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n\n\n    async def quote_history(\n        self,\n        symbol: str,\n        timeframe: market_info_pb2.ENUM_QUOTE_HISTORY_TIMEFRAME,\n        from_time: datetime,\n        to_time: datetime,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Retrieves historical OHLC quotes for a symbol within a specified time range.\n\n        Args:\n            symbol (str): The symbol name (e.g., \"EURUSD\").\n            timeframe (ENUM_QUOTE_HISTORY_TIMEFRAME): The timeframe (e.g., QH_PERIOD_H1).\n            from_time (datetime): Start of the requested historical period.\n            to_time (datetime): End of the requested historical period.\n            deadline (datetime, optional): Deadline for the gRPC request.\n            cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n        Returns:\n            QuoteHistoryData: The server's response containing OHLC and volume data.\n\n        Raises:\n            ConnectExceptionMT4: If the account is not connected before calling this method.\n            ApiExceptionMT4: If the server returns an API error.\n            grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n            asyncio.CancelledError: If cancelled via `cancellation_event`.\n        \"\"\"\n        if not (self.host or self.server_name or self.id):\n            raise ConnectExceptionMT4(\"Please call connect method first\")\n\n        ts_from = Timestamp()\n        ts_from.FromDatetime(from_time)\n        ts_to = Timestamp()\n        ts_to.FromDatetime(to_time)\n\n        request = market_info_pb2.QuoteHistoryRequest(\n            symbol=symbol,\n            timeframe=timeframe,\n            fromTime=ts_from,\n            toTime=ts_to,\n        )\n\n        async def grpc_call(headers):\n            timeout = None\n            if deadline:\n                timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n            return await self.market_info_client.QuoteHistory(\n                request,\n                metadata=headers,\n                timeout=timeout,\n            )\n\n        res = await self.execute_with_reconnect(\n            grpc_call=grpc_call,\n            error_selector=lambda r: getattr(r, \"error\", None),\n            deadline=deadline,\n            cancellation_event=cancellation_event,\n        )\n        return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.account_summary","title":"account_summary  <code>async</code>","text":"<pre><code>account_summary(deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Gets the summary information for a trading account asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>deadline</code> <code>datetime</code> <p>Deadline after which the request will be canceled if not completed.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AccountSummaryData</code> <p>The server's response containing account summary data.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the response.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def account_summary(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Gets the summary information for a trading account asynchronously.\n\n    Args:\n        deadline (datetime, optional): Deadline after which the request will be canceled\n            if not completed.\n        cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n    Returns:\n        AccountSummaryData: The server's response containing account summary data.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the response.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n    \"\"\"\n    if not (self.host or self.server_name):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = account_helper_pb2.AccountSummaryRequest()\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = (deadline - datetime.utcnow()).total_seconds()\n            if timeout &lt; 0:\n                timeout = 0\n        return await self.account_client.AccountSummary(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.opened_orders","title":"opened_orders  <code>async</code>","text":"<pre><code>opened_orders(sort_mode: EnumOpenedOrderSortType = account_helper_pb2.EnumOpenedOrderSortType.SORT_BY_OPEN_TIME_ASC, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Gets the currently opened orders and positions for the connected account asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>sort_mode</code> <code>EnumOpenedOrderSortType</code> <p>The sort mode for the opened orders (e.g. SORT_BY_OPEN_TIME_ASC, SORT_BY_ORDER_TICKET_ID_DESC).</p> <code>SORT_BY_OPEN_TIME_ASC</code> <code>deadline</code> <code>datetime</code> <p>Deadline after which the request will be canceled if not completed.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OpenedOrdersData</code> <p>The result containing opened orders and positions.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the response.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def opened_orders(\n    self,\n    sort_mode: account_helper_pb2.EnumOpenedOrderSortType = account_helper_pb2.EnumOpenedOrderSortType.SORT_BY_OPEN_TIME_ASC,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Gets the currently opened orders and positions for the connected account asynchronously.\n\n    Args:\n        sort_mode (EnumOpenedOrderSortType): The sort mode for the opened orders\n            (e.g. SORT_BY_OPEN_TIME_ASC, SORT_BY_ORDER_TICKET_ID_DESC).\n        deadline (datetime, optional): Deadline after which the request will be canceled\n            if not completed.\n        cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n    Returns:\n        OpenedOrdersData: The result containing opened orders and positions.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the response.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    # Build request\n    request = account_helper_pb2.OpenedOrdersRequest(sort_type=sort_mode)\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = (deadline - datetime.utcnow()).total_seconds()\n            if timeout &lt; 0:\n                timeout = 0\n        return await self.account_client.OpenedOrders(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    # Execute with automatic reconnect logic\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.opened_orders_tickets","title":"opened_orders_tickets  <code>async</code>","text":"<pre><code>opened_orders_tickets(deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Gets the list of tickets for all currently opened orders.</p> <p>Returns:</p> Name Type Description <code>OpenedOrdersTicketsData</code> <p>The result containing the list of tickets.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the response.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def opened_orders_tickets(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Gets the list of tickets for all currently opened orders.\n\n    Returns:\n        OpenedOrdersTicketsData: The result containing the list of tickets.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the response.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = account_helper_pb2.OpenedOrdersTicketsRequest()\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = (deadline - datetime.utcnow()).total_seconds()\n            if timeout &lt; 0:\n                timeout = 0\n        return await self.account_client.OpenedOrdersTickets(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.orders_history","title":"orders_history  <code>async</code>","text":"<pre><code>orders_history(sort_mode: EnumOrderHistorySortType = account_helper_pb2.EnumOrderHistorySortType.HISTORY_SORT_BY_CLOSE_TIME_DESC, from_time: Optional[datetime] = None, to_time: Optional[datetime] = None, page_number: Optional[int] = None, items_per_page: Optional[int] = None, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Gets the order history for the connected account.</p> <p>Parameters:</p> Name Type Description Default <code>sort_mode</code> <code>EnumOrderHistorySortType</code> <p>Sorting mode for orders.</p> <code>HISTORY_SORT_BY_CLOSE_TIME_DESC</code> <code>from_time</code> <code>datetime</code> <p>Start of the history period.</p> <code>None</code> <code>to_time</code> <code>datetime</code> <p>End of the history period.</p> <code>None</code> <code>page_number</code> <code>int</code> <p>Page number for pagination.</p> <code>None</code> <code>items_per_page</code> <code>int</code> <p>Items per page.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrdersHistoryData</code> <p>The result containing historical orders.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the response.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def orders_history(\n    self,\n    sort_mode: account_helper_pb2.EnumOrderHistorySortType = account_helper_pb2.EnumOrderHistorySortType.HISTORY_SORT_BY_CLOSE_TIME_DESC,\n    from_time: Optional[datetime] = None,\n    to_time: Optional[datetime] = None,\n    page_number: Optional[int] = None,\n    items_per_page: Optional[int] = None,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Gets the order history for the connected account.\n\n    Args:\n        sort_mode (EnumOrderHistorySortType): Sorting mode for orders.\n        from_time (datetime, optional): Start of the history period.\n        to_time (datetime, optional): End of the history period.\n        page_number (int, optional): Page number for pagination.\n        items_per_page (int, optional): Items per page.\n\n    Returns:\n        OrdersHistoryData: The result containing historical orders.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the response.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    # Convert datetime \u2192 Timestamp (protobuf)\n    ts_from = None\n    ts_to = None\n    if from_time:\n        ts_from = Timestamp()\n        ts_from.FromDatetime(from_time)\n    if to_time:\n        ts_to = Timestamp()\n        ts_to.FromDatetime(to_time)\n\n    request = account_helper_pb2.OrdersHistoryRequest(\n        input_sort_mode=sort_mode,\n        input_from=ts_from,\n        input_to=ts_to,\n        page_number=page_number,\n        items_per_page=items_per_page,\n    )\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = (deadline - datetime.utcnow()).total_seconds()\n            if timeout &lt; 0:\n                timeout = 0\n        return await self.account_client.OrdersHistory(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.symbol_params_many","title":"symbol_params_many  <code>async</code>","text":"<pre><code>symbol_params_many(symbol_name: Optional[str] = None, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Retrieves symbol parameters (for one or all symbols).</p> <p>Parameters:</p> Name Type Description Default <code>symbol_name</code> <code>str</code> <p>Symbol name. If None, returns all.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SymbolParamsManyData</code> <p>The result containing symbol parameters.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the response.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def symbol_params_many(\n    self,\n    symbol_name: Optional[str] = None,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Retrieves symbol parameters (for one or all symbols).\n\n    Args:\n        symbol_name (str, optional): Symbol name. If None, returns all.\n\n    Returns:\n        SymbolParamsManyData: The result containing symbol parameters.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the response.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = account_helper_pb2.SymbolParamsManyRequest(symbol_name=symbol_name or \"\")\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = (deadline - datetime.utcnow()).total_seconds()\n            if timeout &lt; 0:\n                timeout = 0\n        return await self.account_client.SymbolParamsMany(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.tick_value_with_size","title":"tick_value_with_size  <code>async</code>","text":"<pre><code>tick_value_with_size(symbol_names: list[str], deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Gets tick value, tick size, and contract size for multiple symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_names</code> <code>list[str]</code> <p>List of symbol names.</p> required <p>Returns:</p> Name Type Description <code>TickValueWithSizeData</code> <p>The result containing tick values and sizes.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the response.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def tick_value_with_size(\n    self,\n    symbol_names: list[str],\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Gets tick value, tick size, and contract size for multiple symbols.\n\n    Args:\n        symbol_names (list[str]): List of symbol names.\n\n    Returns: \n        TickValueWithSizeData: The result containing tick values and sizes.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the response.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = account_helper_pb2.TickValueWithSizeRequest(symbol_names=symbol_names)\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = (deadline - datetime.utcnow()).total_seconds()\n            if timeout &lt; 0:\n                timeout = 0\n        return await self.account_client.TickValueWithSize(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.execute_stream_with_reconnect","title":"execute_stream_with_reconnect  <code>async</code>","text":"<pre><code>execute_stream_with_reconnect(request: Any, stream_invoker: Callable[[Any, list[tuple[str, str]]], StreamStreamCall], get_error: Callable[[Any], Optional[Any]], get_data: Callable[[Any], Any], cancellation_event: Optional[Event] = None) -&gt; AsyncGenerator[Any, None]\n</code></pre> <p>Executes a gRPC server-streaming call with automatic reconnection logic on recoverable errors.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Any</code> <p>The request object to initiate the stream with.</p> required <code>stream_invoker</code> <code>Callable</code> <p>A function that opens the stream. It receives the request and metadata headers, and returns an async streaming call.</p> required <code>get_error</code> <code>Callable</code> <p>A function that extracts the error object (if any) from a reply. Return an object with .error_code == \"TERMINAL_INSTANCE_NOT_FOUND\" to trigger reconnect, or any non-null error to raise ApiExceptionMT5.</p> required <code>get_data</code> <code>Callable</code> <p>A function that extracts the data object from a reply. If it returns None, the message is skipped.</p> required <code>cancellation_event</code> <code>Event</code> <p>Event to cancel streaming and reconnection attempts.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncGenerator[Any, None]</code> <p>Extracted data items streamed from the server.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If reconnection logic fails due to missing account context.</p> <code>ApiExceptionMT4</code> <p>When the stream response contains a known API error.</p> <code>AioRpcError</code> <p>If a non-recoverable gRPC error occurs.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def execute_stream_with_reconnect(\n    self,\n    request: Any,\n    stream_invoker: Callable[[Any, list[tuple[str, str]]], grpc.aio.StreamStreamCall],\n    get_error: Callable[[Any], Optional[Any]],\n    get_data: Callable[[Any], Any],\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; AsyncGenerator[Any, None]:\n    \"\"\"\n    Executes a gRPC server-streaming call with automatic reconnection logic on recoverable errors.\n\n    Args:\n        request: The request object to initiate the stream with.\n        stream_invoker (Callable): A function that opens the stream. It receives the request and metadata headers,\n            and returns an async streaming call.\n        get_error (Callable): A function that extracts the error object (if any) from a reply.\n            Return an object with .error_code == \"TERMINAL_INSTANCE_NOT_FOUND\" to trigger reconnect,\n            or any non-null error to raise ApiExceptionMT5.\n        get_data (Callable): A function that extracts the data object from a reply. If it returns None, the\n            message is skipped.\n        cancellation_event (asyncio.Event, optional): Event to cancel streaming and reconnection attempts.\n\n    Yields:\n        Extracted data items streamed from the server.\n\n    Raises:\n        ConnectExceptionMT4: If reconnection logic fails due to missing account context.\n        ApiExceptionMT4: When the stream response contains a known API error.\n        grpc.aio.AioRpcError: If a non-recoverable gRPC error occurs.\n    \"\"\"\n    while cancellation_event is None or not cancellation_event.is_set():\n        reconnect_required = False\n        stream = None\n        try:\n            stream = stream_invoker(request, self.get_headers())\n            async for reply in stream:\n                error = get_error(reply)\n\n                if error and error.error_code in (\n                    \"TERMINAL_INSTANCE_NOT_FOUND\",\n                    \"TERMINAL_REGISTRY_TERMINAL_NOT_FOUND\",\n                ):\n                    reconnect_required = True\n                    break\n\n                if error and getattr(error, \"message\", None):\n                    raise ApiExceptionMT4(error)\n\n                data = get_data(reply)\n                if data is not None:\n                    yield data\n\n        except grpc.aio.AioRpcError as ex:\n            if ex.code() == grpc.StatusCode.UNAVAILABLE:\n                reconnect_required = True\n            else:\n                raise\n\n        finally:\n            if stream:\n                stream.cancel()  # close stream properly\n\n        if reconnect_required:\n            await asyncio.sleep(0.5)\n            await self.reconnect()\n        else:\n            break\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.on_symbol_tick","title":"on_symbol_tick  <code>async</code>","text":"<pre><code>on_symbol_tick(symbols: list[str], cancellation_event: Optional[Event] = None)\n</code></pre> <p>Subscribes to real-time tick data for specified symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[str]</code> <p>The symbol names to subscribe to.</p> required <code>cancellation_event</code> <code>Event</code> <p>Event to cancel streaming.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>OnSymbolTickData</code> <p>Async stream of tick data responses.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an error in the stream.</p> <code>AioRpcError</code> <p>If the stream fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def on_symbol_tick(\n    self,\n    symbols: list[str],\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Subscribes to real-time tick data for specified symbols.\n\n    Args:\n        symbols (list[str]): The symbol names to subscribe to.\n        cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n    Yields:\n        OnSymbolTickData: Async stream of tick data responses.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an error in the stream.\n        grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n    \"\"\"\n    if not self.id:\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = subscriptions_pb2.OnSymbolTickRequest()\n    request.symbol_names.extend(symbols)\n\n    async for data in self.execute_stream_with_reconnect(\n        request=request,\n        stream_invoker=lambda req, headers: self.subscription_client.OnSymbolTick(req, metadata=headers),\n        get_error=lambda reply: reply.error,\n        get_data=lambda reply: reply.data,\n        cancellation_event=cancellation_event,\n    ):\n        yield data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.on_trade","title":"on_trade  <code>async</code>","text":"<pre><code>on_trade(cancellation_event: Optional[Event] = None)\n</code></pre> <p>Subscribes to all trade-related events: orders, deals, positions.</p> <p>Parameters:</p> Name Type Description Default <code>cancellation_event</code> <code>Event</code> <p>Event to cancel streaming.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>OnTradeData</code> <p>Trade event data.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected.</p> <code>ApiExceptionMT4</code> <p>If the server returns a known API error.</p> <code>AioRpcError</code> <p>If the stream fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def on_trade(\n    self,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Subscribes to all trade-related events: orders, deals, positions.\n\n    Args:\n        cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n    Yields:\n        OnTradeData: Trade event data.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected.\n        ApiExceptionMT4: If the server returns a known API error.\n        grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n    \"\"\"\n    if not self.id:\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = subscriptions_pb2.OnTradeRequest()\n\n    async for data in self.execute_stream_with_reconnect(\n        request=request,\n        stream_invoker=lambda req, headers: self.subscription_client.OnTrade(req, metadata=headers),\n        get_error=lambda reply: reply.error,\n        get_data=lambda reply: reply.data,\n        cancellation_event=cancellation_event,\n    ):\n        yield data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.on_opened_orders_tickets","title":"on_opened_orders_tickets  <code>async</code>","text":"<pre><code>on_opened_orders_tickets(pull_interval_milliseconds: int = 500, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Subscribes to live lists of opened order tickets (positions &amp; pending orders).</p> <p>Parameters:</p> Name Type Description Default <code>pull_interval_milliseconds</code> <code>int</code> <p>Server-side polling interval.</p> <code>500</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel streaming.</p> <code>None</code> <p>Yields:</p> Type Description <p>OnOpenedOrdersTicketsData</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected.</p> <code>ApiExceptionMT4</code> <p>If the server returns a known API error.</p> <code>AioRpcError</code> <p>If the stream fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def on_opened_orders_tickets(\n    self,\n    pull_interval_milliseconds: int = 500,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Subscribes to live lists of opened order tickets (positions &amp; pending orders).\n\n    Args:\n        pull_interval_milliseconds (int): Server-side polling interval.\n        cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n    Yields:\n        OnOpenedOrdersTicketsData\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected.\n        ApiExceptionMT4: If the server returns a known API error.\n        grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n    \"\"\"\n    if not self.id:\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = subscriptions_pb2.OnOpenedOrdersTicketsRequest(\n        pull_interval_milliseconds=pull_interval_milliseconds\n    )\n\n    async for data in self.execute_stream_with_reconnect(\n        request=request,\n        stream_invoker=lambda req, headers: self.subscription_client.OnOpenedOrdersTickets(\n            req, metadata=headers\n        ),\n        get_error=lambda reply: reply.error,\n        get_data=lambda reply: reply.data,\n        cancellation_event=cancellation_event,\n    ):\n        yield data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.on_opened_orders_profit","title":"on_opened_orders_profit  <code>async</code>","text":"<pre><code>on_opened_orders_profit(timer_period_milliseconds: int = 1000, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Subscribes to real-time profit updates for opened orders (plus account snapshot).</p> <p>Parameters:</p> Name Type Description Default <code>timer_period_milliseconds</code> <code>int</code> <p>Server timer period for updates.</p> <code>1000</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel streaming.</p> <code>None</code> <p>Yields:</p> Type Description <p>OnOpenedOrdersProfitData</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected.</p> <code>ApiExceptionMT4</code> <p>If the server returns a known API error.</p> <code>AioRpcError</code> <p>If the stream fails due to communication or protocol errors.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def on_opened_orders_profit(\n    self,\n    timer_period_milliseconds: int = 1000,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Subscribes to real-time profit updates for opened orders (plus account snapshot).\n\n    Args:\n        timer_period_milliseconds (int): Server timer period for updates.\n        cancellation_event (asyncio.Event, optional): Event to cancel streaming.\n\n    Yields:\n        OnOpenedOrdersProfitData\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected.\n        ApiExceptionMT4: If the server returns a known API error.\n        grpc.aio.AioRpcError: If the stream fails due to communication or protocol errors.\n    \"\"\"\n    if not self.id:\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = subscriptions_pb2.OnOpenedOrdersProfitRequest(\n        timer_period_milliseconds=timer_period_milliseconds\n    )\n\n    async for data in self.execute_stream_with_reconnect(\n        request=request,\n        stream_invoker=lambda req, headers: self.subscription_client.OnOpenedOrdersProfit(\n            req, metadata=headers\n        ),\n        get_error=lambda reply: reply.error,\n        get_data=lambda reply: reply.data,\n        cancellation_event=cancellation_event,\n    ):\n        yield data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.order_send","title":"order_send  <code>async</code>","text":"<pre><code>order_send(symbol: str, operation_type: OrderSendOperationType, volume: float, price: Optional[float] = None, slippage: Optional[int] = None, stoploss: Optional[float] = None, takeprofit: Optional[float] = None, comment: Optional[str] = None, magic_number: Optional[int] = None, expiration: Optional[datetime] = None, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Opens a new trade order (market or pending).</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Symbol to trade, e.g. \"EURUSD\".</p> required <code>operation_type</code> <code>OrderSendOperationType</code> <p>Operation type (BUY, SELL, BUYLIMIT, etc.).</p> required <code>volume</code> <code>float</code> <p>Trade volume in lots.</p> required <code>price</code> <code>float</code> <p>Open price for pending orders.</p> <code>None</code> <code>slippage</code> <code>int</code> <p>Allowed price deviation in points.</p> <code>None</code> <code>stoploss</code> <code>float</code> <p>Stop loss price.</p> <code>None</code> <code>takeprofit</code> <code>float</code> <p>Take profit price.</p> <code>None</code> <code>comment</code> <code>str</code> <p>Comment for the order.</p> <code>None</code> <code>magic_number</code> <code>int</code> <p>Custom magic number to identify the order.</p> <code>None</code> <code>expiration</code> <code>datetime</code> <p>Expiration time for pending orders.</p> <code>None</code> <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderSendData</code> <p>The server's response containing new order details.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def order_send(\n    self,\n    symbol: str,\n    operation_type: trading_helper_pb2.OrderSendOperationType,\n    volume: float,\n    price: Optional[float] = None,\n    slippage: Optional[int] = None,\n    stoploss: Optional[float] = None,\n    takeprofit: Optional[float] = None,\n    comment: Optional[str] = None,\n    magic_number: Optional[int] = None,\n    expiration: Optional[datetime] = None,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Opens a new trade order (market or pending).\n\n    Args:\n        symbol (str): Symbol to trade, e.g. \"EURUSD\".\n        operation_type (OrderSendOperationType): Operation type (BUY, SELL, BUYLIMIT, etc.).\n        volume (float): Trade volume in lots.\n        price (float, optional): Open price for pending orders.\n        slippage (int, optional): Allowed price deviation in points.\n        stoploss (float, optional): Stop loss price.\n        takeprofit (float, optional): Take profit price.\n        comment (str, optional): Comment for the order.\n        magic_number (int, optional): Custom magic number to identify the order.\n        expiration (datetime, optional): Expiration time for pending orders.\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n    Returns:\n        OrderSendData: The server's response containing new order details.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    req = trading_helper_pb2.OrderSendRequest(\n        symbol=symbol,\n        operation_type=operation_type,\n        volume=volume,\n    )\n    if price is not None:\n        req.price = price\n    if slippage is not None:\n        req.slippage = slippage\n    if stoploss is not None:\n        req.stoploss = stoploss\n    if takeprofit is not None:\n        req.takeprofit = takeprofit\n    if comment:\n        req.comment = comment\n    if magic_number is not None:\n        req.magic_number = magic_number\n    if expiration:\n        ts = Timestamp()\n        ts.FromDatetime(expiration)\n        req.expiration.CopyFrom(ts)\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.trade_client.OrderSend(req, metadata=headers, timeout=timeout)\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.order_modify","title":"order_modify  <code>async</code>","text":"<pre><code>order_modify(order_ticket: int, new_price: Optional[float] = None, new_stop_loss: Optional[float] = None, new_take_profit: Optional[float] = None, new_expiration: Optional[datetime] = None, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Modifies an existing order (price, SL/TP, expiration).</p> <p>Parameters:</p> Name Type Description Default <code>order_ticket</code> <code>int</code> <p>Ticket number of the order to modify.</p> required <code>new_price</code> <code>float</code> <p>New open price.</p> <code>None</code> <code>new_stop_loss</code> <code>float</code> <p>New stop loss.</p> <code>None</code> <code>new_take_profit</code> <code>float</code> <p>New take profit.</p> <code>None</code> <code>new_expiration</code> <code>datetime</code> <p>New expiration time.</p> <code>None</code> <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderModifyData</code> <p>The server's response containing modification result.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def order_modify(\n    self,\n    order_ticket: int,\n    new_price: Optional[float] = None,\n    new_stop_loss: Optional[float] = None,\n    new_take_profit: Optional[float] = None,\n    new_expiration: Optional[datetime] = None,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Modifies an existing order (price, SL/TP, expiration).\n\n    Args:\n        order_ticket (int): Ticket number of the order to modify.\n        new_price (float, optional): New open price.\n        new_stop_loss (float, optional): New stop loss.\n        new_take_profit (float, optional): New take profit.\n        new_expiration (datetime, optional): New expiration time.\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n    Returns:\n        OrderModifyData: The server's response containing modification result.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    req = trading_helper_pb2.OrderModifyRequest(order_ticket=order_ticket)\n    if new_price is not None:\n        req.new_price = new_price\n    if new_stop_loss is not None:\n        req.new_stop_loss = new_stop_loss\n    if new_take_profit is not None:\n        req.new_take_profit = new_take_profit\n    if new_expiration:\n        ts = Timestamp()\n        ts.FromDatetime(new_expiration)\n        req.new_expiration.CopyFrom(ts)\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.trade_client.OrderModify(req, metadata=headers, timeout=timeout)\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.order_close_delete","title":"order_close_delete  <code>async</code>","text":"<pre><code>order_close_delete(order_ticket: int, lots: Optional[float] = None, closing_price: Optional[float] = None, slippage: Optional[int] = None, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Closes or deletes an order (market or pending).</p> <p>Parameters:</p> Name Type Description Default <code>order_ticket</code> <code>int</code> <p>Ticket of the order to close or delete.</p> required <code>lots</code> <code>float</code> <p>Volume to close (for partial close).</p> <code>None</code> <code>closing_price</code> <code>float</code> <p>Desired closing price.</p> <code>None</code> <code>slippage</code> <code>int</code> <p>Allowed price deviation in points.</p> <code>None</code> <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderCloseDeleteData</code> <p>The server's response indicating close/delete status.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def order_close_delete(\n    self,\n    order_ticket: int,\n    lots: Optional[float] = None,\n    closing_price: Optional[float] = None,\n    slippage: Optional[int] = None,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Closes or deletes an order (market or pending).\n\n    Args:\n        order_ticket (int): Ticket of the order to close or delete.\n        lots (float, optional): Volume to close (for partial close).\n        closing_price (float, optional): Desired closing price.\n        slippage (int, optional): Allowed price deviation in points.\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n    Returns:\n        OrderCloseDeleteData: The server's response indicating close/delete status.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    req = trading_helper_pb2.OrderCloseDeleteRequest(order_ticket=order_ticket)\n    if lots is not None:\n        req.lots = lots\n    if closing_price is not None:\n        req.closing_price = closing_price\n    if slippage is not None:\n        req.slippage = slippage\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.trade_client.OrderCloseDelete(req, metadata=headers, timeout=timeout)\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.order_close_by","title":"order_close_by  <code>async</code>","text":"<pre><code>order_close_by(ticket_to_close: int, opposite_ticket_closing_by: int, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Closes one position by another (close-by operation).</p> <p>Parameters:</p> Name Type Description Default <code>ticket_to_close</code> <code>int</code> <p>Ticket of the order being closed.</p> required <code>opposite_ticket_closing_by</code> <code>int</code> <p>Opposite ticket to close by.</p> required <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the operation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderCloseByData</code> <p>The server's response containing close-by result.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def order_close_by(\n    self,\n    ticket_to_close: int,\n    opposite_ticket_closing_by: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Closes one position by another (close-by operation).\n\n    Args:\n        ticket_to_close (int): Ticket of the order being closed.\n        opposite_ticket_closing_by (int): Opposite ticket to close by.\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the operation.\n\n    Returns:\n        OrderCloseByData: The server's response containing close-by result.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    req = trading_helper_pb2.OrderCloseByRequest(\n        ticket_to_close=ticket_to_close,\n        opposite_ticket_closing_by=opposite_ticket_closing_by,\n    )\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.trade_client.OrderCloseBy(req, metadata=headers, timeout=timeout)\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.quote","title":"quote  <code>async</code>","text":"<pre><code>quote(symbol: str, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Retrieves the latest quote for a single symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol name (e.g., \"EURUSD\").</p> required <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuoteData</code> <p>The latest bid/ask/high/low prices with timestamp.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def quote(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Retrieves the latest quote for a single symbol.\n\n    Args:\n        symbol (str): The symbol name (e.g., \"EURUSD\").\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n    Returns:\n        QuoteData: The latest bid/ask/high/low prices with timestamp.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = market_info_pb2.QuoteRequest(symbol=symbol)\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.market_info_client.Quote(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.quote_many","title":"quote_many  <code>async</code>","text":"<pre><code>quote_many(symbols: list[str], deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Retrieves quotes for multiple symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[str]</code> <p>List of symbol names (e.g., [\"EURUSD\", \"GBPUSD\"]).</p> required <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuoteManyData</code> <p>The response containing quotes for all requested symbols.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def quote_many(\n    self,\n    symbols: list[str],\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Retrieves quotes for multiple symbols.\n\n    Args:\n        symbols (list[str]): List of symbol names (e.g., [\"EURUSD\", \"GBPUSD\"]).\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n    Returns:\n        QuoteManyData: The response containing quotes for all requested symbols.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = market_info_pb2.QuoteManyRequest(symbols=symbols)\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.market_info_client.QuoteMany(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.symbols","title":"symbols  <code>async</code>","text":"<pre><code>symbols(deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Retrieves the full list of tradable symbols from the connected terminal.</p> <p>Parameters:</p> Name Type Description Default <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SymbolsData</code> <p>The response containing all available symbol names and indices.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def symbols(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Retrieves the full list of tradable symbols from the connected terminal.\n\n    Args:\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n    Returns:\n        SymbolsData: The response containing all available symbol names and indices.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    request = market_info_pb2.SymbolsRequest()\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.market_info_client.Symbols(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"api/#MetaRpcMT4.mt4_account.MT4Account.quote_history","title":"quote_history  <code>async</code>","text":"<pre><code>quote_history(symbol: str, timeframe: ENUM_QUOTE_HISTORY_TIMEFRAME, from_time: datetime, to_time: datetime, deadline: Optional[datetime] = None, cancellation_event: Optional[Event] = None)\n</code></pre> <p>Retrieves historical OHLC quotes for a symbol within a specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol name (e.g., \"EURUSD\").</p> required <code>timeframe</code> <code>ENUM_QUOTE_HISTORY_TIMEFRAME</code> <p>The timeframe (e.g., QH_PERIOD_H1).</p> required <code>from_time</code> <code>datetime</code> <p>Start of the requested historical period.</p> required <code>to_time</code> <code>datetime</code> <p>End of the requested historical period.</p> required <code>deadline</code> <code>datetime</code> <p>Deadline for the gRPC request.</p> <code>None</code> <code>cancellation_event</code> <code>Event</code> <p>Event to cancel the request.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuoteHistoryData</code> <p>The server's response containing OHLC and volume data.</p> <p>Raises:</p> Type Description <code>ConnectExceptionMT4</code> <p>If the account is not connected before calling this method.</p> <code>ApiExceptionMT4</code> <p>If the server returns an API error.</p> <code>AioRpcError</code> <p>If the gRPC call fails due to communication or protocol errors.</p> <code>CancelledError</code> <p>If cancelled via <code>cancellation_event</code>.</p> Source code in <code>package/MetaRpcMT4/mt4_account.py</code> <pre><code>async def quote_history(\n    self,\n    symbol: str,\n    timeframe: market_info_pb2.ENUM_QUOTE_HISTORY_TIMEFRAME,\n    from_time: datetime,\n    to_time: datetime,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    \"\"\"\n    Retrieves historical OHLC quotes for a symbol within a specified time range.\n\n    Args:\n        symbol (str): The symbol name (e.g., \"EURUSD\").\n        timeframe (ENUM_QUOTE_HISTORY_TIMEFRAME): The timeframe (e.g., QH_PERIOD_H1).\n        from_time (datetime): Start of the requested historical period.\n        to_time (datetime): End of the requested historical period.\n        deadline (datetime, optional): Deadline for the gRPC request.\n        cancellation_event (asyncio.Event, optional): Event to cancel the request.\n\n    Returns:\n        QuoteHistoryData: The server's response containing OHLC and volume data.\n\n    Raises:\n        ConnectExceptionMT4: If the account is not connected before calling this method.\n        ApiExceptionMT4: If the server returns an API error.\n        grpc.aio.AioRpcError: If the gRPC call fails due to communication or protocol errors.\n        asyncio.CancelledError: If cancelled via `cancellation_event`.\n    \"\"\"\n    if not (self.host or self.server_name or self.id):\n        raise ConnectExceptionMT4(\"Please call connect method first\")\n\n    ts_from = Timestamp()\n    ts_from.FromDatetime(from_time)\n    ts_to = Timestamp()\n    ts_to.FromDatetime(to_time)\n\n    request = market_info_pb2.QuoteHistoryRequest(\n        symbol=symbol,\n        timeframe=timeframe,\n        fromTime=ts_from,\n        toTime=ts_to,\n    )\n\n    async def grpc_call(headers):\n        timeout = None\n        if deadline:\n            timeout = max((deadline - datetime.utcnow()).total_seconds(), 0)\n        return await self.market_info_client.QuoteHistory(\n            request,\n            metadata=headers,\n            timeout=timeout,\n        )\n\n    res = await self.execute_with_reconnect(\n        grpc_call=grpc_call,\n        error_selector=lambda r: getattr(r, \"error\", None),\n        deadline=deadline,\n        cancellation_event=cancellation_event,\n    )\n    return res.data\n</code></pre>"},{"location":"Examples/All_about_examples/","title":"MT4 API Examples","text":"<p>Examples demonstrating PyMT4 usage across four levels of abstraction.</p>"},{"location":"Examples/All_about_examples/#demo-files","title":"Demo Files","text":""},{"location":"Examples/All_about_examples/#1-low_level_callpy-low-level-api-19-methods","title":"1. Low_level_call.py - Low-Level API (19 methods)","text":"<p>Direct gRPC calls without wrappers, maximum control.</p> <pre><code>python examples/Low_level_call.py\n</code></pre> <p>Demonstrates: - \ud83d\udd0c Connection (2 methods): <code>connect_by_server_name()</code>, <code>connect_by_host_port()</code> - \ud83d\udc64 Account (1 method): <code>account_summary()</code> - \ud83d\udcca Market Data (6 methods): <code>symbols()</code>, <code>quote()</code>, <code>quote_many()</code>, <code>quote_history()</code>, etc. - \ud83d\udccb Orders (3 methods): <code>opened_orders()</code>, <code>orders_history()</code>, etc. - \ud83d\udcbc Trading (4 methods): <code>order_send()</code>, <code>order_modify()</code>, <code>order_close_delete()</code>, <code>order_close_by()</code> - \ud83c\udf0a Streaming (4 methods): <code>on_symbol_tick()</code>, <code>on_trade()</code>, <code>on_opened_orders_tickets()</code>, etc.</p> <p>Features: - \u23f1\ufe0f Enforced timeouts for streams (freezing issue resolved) - \ud83c\udfaf 3-priority connection system - \ud83d\udd12 Trading disabled by default (<code>ENABLE_TRADING=0</code>)</p>"},{"location":"Examples/All_about_examples/#2-call_sugarpy-sugar-api-20-methods","title":"2. Call_sugar.py - Sugar API (~20 methods)","text":"<p>High-level wrappers with convenient interface and pip-based operations.</p> <pre><code>python examples/Call_sugar.py\n</code></pre> <p>Demonstrates: - \ud83d\udd0c Connection: <code>ensure_connected()</code>, <code>ping()</code> - \ud83d\udcd0 Symbol Info: <code>digits()</code>, <code>point()</code>, <code>pip_size()</code>, <code>spread_pips()</code>, <code>mid_price()</code> - \ud83c\udfb2 Risk Management: <code>calc_lot_by_risk()</code>, <code>calc_cash_risk()</code> - \ud83d\udcca Exposure: <code>exposure_summary()</code>, <code>opened_orders()</code> - \ud83d\udcb0 Trading: <code>buy_market()</code>, <code>sell_market()</code>, <code>buy_limit()</code>, <code>sell_stop()</code> - \u2699\ufe0f Order Management: <code>modify_sl_tp_by_pips()</code>, <code>close()</code>, <code>close_partial()</code></p> <p>Features: - \ud83d\udccf All SL/TP specified in pips - \ud83e\udd16 Automatic lot calculation based on risk - \ud83d\udee0\ufe0f Convenient price helpers</p>"},{"location":"Examples/All_about_examples/#3-orchestrator_demopy-strategy-orchestrators","title":"3. Orchestrator_demo.py - Strategy Orchestrators","text":"<p>Modular trading scenarios with presets and guards.</p> <pre><code>python examples/Orchestrator_demo.py\n</code></pre> <p>Demonstrates 4 orchestrators:</p>"},{"location":"Examples/All_about_examples/#1-market_one_shot-market-order-with-automation","title":"1. \ud83c\udfaf <code>market_one_shot</code> - Market order with automation","text":"<pre><code>from Strategy.presets import MarketEURUSD, Balanced\nfrom Strategy.orchestrator.market_one_shot import run_market_one_shot\n\nresult = await run_market_one_shot(svc, MarketEURUSD, Balanced)\n# Opens market order + trailing stop + auto-breakeven\n</code></pre>"},{"location":"Examples/All_about_examples/#2-pending_bracket-pending-order-with-timeout","title":"2. \u23f0 <code>pending_bracket</code> - Pending order with timeout","text":"<pre><code>from Strategy.presets import LimitEURUSD, Conservative\nfrom Strategy.orchestrator.pending_bracket import run_pending_bracket\n\nstrategy = LimitEURUSD(price=1.0850)\nresult = await run_pending_bracket(svc, strategy, Conservative, timeout_s=900)\n# Waits for execution, cancels if not triggered\n</code></pre>"},{"location":"Examples/All_about_examples/#3-spread_guard-spread-filter","title":"3. \ud83d\udcca <code>spread_guard</code> - Spread filter","text":"<pre><code>from Strategy.orchestrator.spread_guard import market_with_spread_guard\n\nresult = await market_with_spread_guard(\n    svc, strategy, risk,\n    max_spread_pips=1.5  # Trades only if spread &lt;= 1.5 pips\n)\n</code></pre>"},{"location":"Examples/All_about_examples/#4-session_guard-trading-windows","title":"4. \ud83d\udd50 <code>session_guard</code> - Trading windows","text":"<pre><code>from Strategy.orchestrator.session_guard import run_with_session_guard\n\nwindows = [('08:00', '11:30'), ('13:00', '17:00')]\nresult = await run_with_session_guard(\n    svc=svc,\n    runner_coro_factory=lambda: run_market_one_shot(svc, strategy, risk),\n    windows=windows,\n    tz='Europe/London',\n    weekdays=[0,1,2,3,4]  # Mon-Fri\n)\n</code></pre> <p>Available presets:</p> <p>\ud83d\udccb Strategy Presets: - <code>MarketEURUSD</code> - market order - <code>LimitEURUSD(price)</code> - limit order - <code>BreakoutBuy(symbol, offset_pips)</code> - level breakout</p> <p>\ud83c\udfb2 Risk Presets: - <code>Conservative</code> - 0.5% risk, SL=25p, TP=50p - <code>Balanced</code> - 1.0% risk, SL=20p, TP=40p - <code>Aggressive</code> - 2.0% risk, SL=15p, TP=30p - <code>Scalper</code> - 1.0% risk, SL=8p, TP=12p, trailing=6p - <code>Walker</code> - 0.75% risk, SL=30p, TP=60p, breakeven=20p+2p</p> <p>\ud83c\udfad Other orchestrators (available in code): - <code>oco_straddle</code> - two-way entry (OCO) - <code>bracket_trailing_activation</code> - conditional trailing activation - <code>equity_circuit_breaker</code> - emergency stop on drawdown - <code>dynamic_deviation_guard</code> - adaptive deviation - <code>rollover_avoidance</code> - swap time avoidance - <code>grid_dca_common_sl</code> - grid with common SL</p>"},{"location":"Examples/All_about_examples/#running-examples","title":"Running Examples","text":""},{"location":"Examples/All_about_examples/#via-appsettingsjson-recommended","title":"Via appsettings.json (recommended)","text":"<pre><code>python examples/Low_level_call.py\npython examples/Call_sugar.py\npython examples/Orchestrator_demo.py\n</code></pre> <p>Scripts automatically read <code>appsettings.json</code> from project root.</p>"},{"location":"Examples/All_about_examples/#via-environment-variables-powershell","title":"Via environment variables (PowerShell)","text":"<pre><code>$env:MT4_LOGIN=\"12345678\"\n$env:MT4_PASSWORD=\"your_password\"\n$env:MT4_SERVER=\"MetaQuotes-Demo\"\npython examples/Low_level_call.py\n</code></pre>"},{"location":"Examples/All_about_examples/#enable-real-trading","title":"Enable real trading","text":"<pre><code>export ENABLE_TRADING=1\npython examples/Call_sugar.py\n</code></pre> <p>WARNING: Trading is disabled by default (<code>ENABLE_TRADING=0</code>) - only syntax demonstration!</p>"},{"location":"Examples/All_about_examples/#level-comparison","title":"Level Comparison","text":"Level File Components Usage Flexibility \ud83d\udd27 Low-Level <code>Low_level_call.py</code> 19 methods Direct gRPC calls Maximum \ud83c\udf6c Sugar <code>Call_sugar.py</code> ~20 methods Convenient wrappers High \ud83c\udfad Orchestrator <code>Orchestrator_demo.py</code> 4+ orchestrators Ready scenarios Modular \u2699\ufe0f Presets <code>Presets_demo.py</code> 40+ presets Configurations Composition"},{"location":"Examples/All_about_examples/#4-presets_demopy-reusable-configurations-40-presets","title":"4. Presets_demo.py - Reusable Configurations (40+ presets)","text":"<p>All available presets for strategies and risk management.</p> <pre><code>python examples/Presets_demo.py\n</code></pre> <p>Demonstrates 5 preset categories:</p>"},{"location":"Examples/All_about_examples/#1-basic-risk-presets-5-profiles","title":"1.  Basic Risk Presets (5 profiles)","text":"<pre><code>from Strategy.presets.risk import Conservative, Balanced, Aggressive, Scalper, Walker\n\nresult = await run_market_one_shot(svc, MarketEURUSD, Balanced)\n</code></pre>"},{"location":"Examples/All_about_examples/#2-atr-based-risk-3-dynamic-profiles","title":"2.  ATR-Based Risk (3 dynamic profiles)","text":"<pre><code>from Strategy.presets.risk_atr import ATR_Scalper, ATR_Balanced, ATR_Swing\n\nrisk = await ATR_Balanced(svc, \"EURUSD\", risk_percent=1.0)\n# SL/TP automatically calculated from ATR (volatility)\n</code></pre>"},{"location":"Examples/All_about_examples/#3-risk-profiles-8-profiles","title":"3.  Risk Profiles (8+ profiles)","text":"<pre><code>from Strategy.presets.risk_profiles import ScalperEURUSD, SwingXAUUSD\n\n# Specialized for symbol and trading style\nresult = await run_market_one_shot(svc, MarketXAUUSD, SwingXAUUSD())\n</code></pre>"},{"location":"Examples/All_about_examples/#4-session-based-risk-4-sessions","title":"4.  Session-Based Risk (4 sessions)","text":"<pre><code>from Strategy.presets.risk_session import session_risk_auto\n\n# Automatic selection by current session\nrisk = await session_risk_auto(svc, \"EURUSD\", tz=\"Europe/London\")\n# Asia / London / NewYork / Overlap\n</code></pre>"},{"location":"Examples/All_about_examples/#5-strategy-symbol-presets-30-symbols","title":"5.  Strategy Symbol Presets (30+ symbols)","text":"<pre><code>from Strategy.presets.strategy_symbols import (\n    MarketEURUSD, MarketXAUUSD, MarketBTCUSD,\n    LimitGBPUSD, BreakoutEURUSD\n)\n\n# Symbols: Forex, Metals, Indices, Crypto\n# Types: Market, Limit, Breakout\n</code></pre> <p>All presets: -  Forex: EURUSD, GBPUSD, USDJPY -  Metals: XAUUSD, XAGUSD -  Indices: US100, US500, GER40 -  Crypto: BTCUSD</p>"},{"location":"Examples/All_about_examples/#examples-structure","title":"\ud83d\udcc1 examples/ Structure","text":"<pre><code>examples/\n\u251c\u2500\u2500 Low_level_call.py          # Low-level API demo (19 methods)\n\u251c\u2500\u2500 Call_sugar.py              # Sugar API demo (~20 methods)\n\u251c\u2500\u2500 Orchestrator_demo.py       # Orchestrators demo (4 orchestrators)\n\u2514\u2500\u2500 Presets_demo.py            # Presets demo (40+ presets)\n</code></pre>"},{"location":"Examples/All_about_examples/#environment-variables","title":"\ud83d\udd27 Environment Variables","text":"Variable Required Default Description <code>MT4_LOGIN</code> \u2713* - MT4 login <code>MT4_PASSWORD</code> \u2713* - MT4 password <code>MT4_SERVER</code> \u2717 MetaQuotes-Demo Server name <code>MT4_HOST</code> \u2717 - Host for direct connection <code>MT4_PORT</code> \u2717 443 Port <code>BASE_SYMBOL</code> \u2717 EURUSD Base symbol <code>SYMBOL</code> \u2717 EURUSD Test symbol <code>ENABLE_TRADING</code> \u2717 0 Enable trading (1=yes) <code>CONNECT_TIMEOUT</code> \u2717 30 Connection timeout <p>*if not set in <code>appsettings.json</code></p>"},{"location":"MT4Account/BASE/","title":"MT4Account \u2014 Master Overview","text":"<p>One page to orient fast: what lives where, how to choose the right API, and jump links to every overview and method spec in this docs set.</p>"},{"location":"MT4Account/BASE/#start-here-section-overviews","title":"\ud83d\udea6 Start here \u2014 Section Overviews","text":"<ul> <li> <p>Account_Information \u2014 Overview   Account balance/equity/margins, summary snapshot.</p> </li> <li> <p>Market_Quota_Symbols \u2014 Overview   Quotes, symbols, ticks, bars history, symbol parameters, tick values.</p> </li> <li> <p>Orders_Positions_History \u2014 Overview   What's open now, tickets, order details.</p> </li> <li> <p>Trading_Actions \u2014 Overview   Place/modify/close orders, close by opposite position.</p> </li> <li> <p>Streams \u2014 Overview   Live streams: ticks, trade events, tickets, profit snapshots.</p> </li> </ul>"},{"location":"MT4Account/BASE/#how-to-pick-an-api","title":"\ud83e\udded How to pick an API","text":"If you need\u2026 Go to\u2026 Typical calls Account snapshot Account_Information <code>account_summary</code> Quotes &amp; market data Market_Quota_Symbols <code>quote</code>, <code>quote_many</code>, <code>quote_history</code>, <code>symbols</code>, <code>symbol_params_many</code> Live positions &amp; tickets Orders.Positions.History <code>opened_orders</code>, <code>opened_orders_tickets</code> Trading actions Trading_Actions <code>order_send</code>, <code>order_modify</code>, <code>order_close_delete</code>, <code>order_close_by</code> Realtime updates Streams <code>on_symbol_tick</code>, <code>on_trade</code>, <code>on_opened_orders_tickets</code>, <code>on_opened_orders_profit</code>"},{"location":"MT4Account/BASE/#usage-pattern-sdk-wrappers","title":"\ud83d\udd0c Usage pattern (SDK wrappers)","text":"<p>Every method follows the same shape:</p> <ul> <li>Service/Method (gRPC): <code>Service.Method(Request) \u2192 Reply</code></li> <li>Low-level stub: <code>ServiceStub.Method(request, metadata, timeout)</code></li> <li>SDK wrapper (what you call): <code>await MT4Account.method_name(..., deadline=None, cancellation_event=None)</code></li> <li>Reply: SDK returns <code>.data</code> payload (already unwrapped) unless otherwise noted.</li> </ul> <p>Timestamps = UTC (<code>google.protobuf.Timestamp</code>). For long\u2011lived streams, pass a <code>cancellation_event</code>.</p>"},{"location":"MT4Account/BASE/#full-index-all-method-specs","title":"\ud83d\udcda Full Index \u00b7 All Method Specs","text":""},{"location":"MT4Account/BASE/#account-information","title":"\ud83d\udcc4 Account Information","text":"<ul> <li>Summary   \u2013 account_summary.md</li> </ul>"},{"location":"MT4Account/BASE/#market-quota-symbols","title":"\ud83d\udcca Market \u00b7 Quota \u00b7 Symbols","text":"<ul> <li>Overview: Market_Quota.Overview.md</li> </ul>"},{"location":"MT4Account/BASE/#quotes","title":"Quotes","text":"<ul> <li>quote.md \u2014 Single symbol quote (bid/ask/time)</li> <li>quote_many.md \u2014 Multiple symbols quotes</li> <li>quote_history.md \u2014 Historical bars/ticks</li> </ul>"},{"location":"MT4Account/BASE/#symbols-inventory","title":"Symbols Inventory","text":"<ul> <li>symbols.md \u2014 Available symbols list</li> <li>symbol_params_many.md \u2014 Symbol properties (digits, point, spread, etc.)</li> </ul>"},{"location":"MT4Account/BASE/#pricing-utils","title":"Pricing Utils","text":"<ul> <li>tick_value_with_size.md \u2014 Tick value/size for lot calculations</li> </ul>"},{"location":"MT4Account/BASE/#orders-positions-history","title":"\ud83d\udce6 Orders \u00b7 Positions \u00b7 History","text":"<ul> <li>Overview: Positions_History_Overview.md</li> </ul>"},{"location":"MT4Account/BASE/#live-now","title":"Live Now","text":"<ul> <li>opened_orders.md \u2014 All open positions (full details)</li> <li>opened_orders_tickets.md \u2014 Open positions tickets only</li> </ul>"},{"location":"MT4Account/BASE/#trading-actions","title":"\ud83d\udee0 Trading Actions","text":"<ul> <li>Overview: Trading_Actions_Overview.md</li> </ul>"},{"location":"MT4Account/BASE/#placement-lifecycle","title":"Placement &amp; Lifecycle","text":"<ul> <li>order_send.md \u2014 Place new order (market/limit/stop)</li> <li>order_modify.md \u2014 Modify SL/TP/price</li> <li>order_close_delete.md \u2014 Close position or delete pending order</li> </ul>"},{"location":"MT4Account/BASE/#advanced","title":"Advanced","text":"<ul> <li>order_close_by.md \u2014 Close by opposite position</li> </ul>"},{"location":"MT4Account/BASE/#streams-subscriptions","title":"\ud83d\udce1 Streams \u00b7 Subscriptions","text":"<ul> <li>Overview: Streams_Overview.md</li> </ul>"},{"location":"MT4Account/BASE/#price-updates","title":"Price Updates","text":"<ul> <li>on_symbol_tick.md \u2014 Real-time tick stream for symbols</li> </ul>"},{"location":"MT4Account/BASE/#trading-events","title":"Trading Events","text":"<ul> <li>on_trade.md \u2014 Trade execution events</li> </ul>"},{"location":"MT4Account/BASE/#positions-snapshots","title":"Positions Snapshots","text":"<ul> <li>on_opened_orders_tickets.md \u2014 Stream of open tickets</li> <li>on_opened_orders_profit.md \u2014 Stream of profit updates</li> </ul>"},{"location":"MT4Account/BASE/#quick-navigation-by-use-case","title":"\ud83c\udfaf Quick Navigation by Use Case","text":"I want to... Use this method Get current account balance/equity account_summary Get current price for EURUSD quote Get prices for multiple symbols quote_many Get historical bars/ticks quote_history List available symbols symbols Get symbol properties (digits, point, spread) symbol_params_many Calculate tick value for lot sizing tick_value_with_size See all open positions opened_orders Get just the ticket numbers opened_orders_tickets Place a market order order_send (type=market) Place a limit order order_send (type=limit) Place a stop order order_send (type=stop) Modify SL/TP order_modify Close a position order_close_delete Delete pending order order_close_delete Close by opposite position order_close_by Stream live prices on_symbol_tick Watch for trade executions on_trade Monitor open tickets on_opened_orders_tickets Monitor profit changes on_opened_orders_profit <p>\"May your pips stack high and your drawdowns stay low.\"</p>"},{"location":"MT4Account/Account_Information/account_summary/","title":"\u2705 Getting an Account Summary","text":"<p>Request: full account summary (<code>AccountSummaryData</code>) from MT4. Fetch all core account metrics in a single call.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>account_summary(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_account_helper_pb2.py</code> \u2014 <code>AccountSummary*</code>, <code>EnumAccountTradeMode</code></li> </ul>"},{"location":"MT4Account/Account_Information/account_summary/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.AccountHelper</code></li> <li>Method: <code>AccountSummary(AccountSummaryRequest) \u2192 AccountSummaryReply</code></li> <li>Low-level client: <code>AccountHelperStub.AccountSummary(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.account_summary(deadline=None, cancellation_event=None) -&gt; AccountSummaryData</code></li> </ul> <p>Request message: <code>AccountSummaryRequest {}</code> Reply message: <code>AccountSummaryReply { data: AccountSummaryData }</code></p>"},{"location":"MT4Account/Account_Information/account_summary/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># High-level (prints formatted summary):\nasync def show_account_summary(acct):\n    s = await acct.account_summary()\n    print(\n        f\"Account Summary: Balance={s.account_balance:.2f}, \"\n        f\"Equity={s.account_equity:.2f}, Currency={s.account_currency}, \"\n        f\"Login={s.account_login}, Leverage={s.account_leverage}, \"\n        f\"Mode={s.account_trade_mode}\"\n    )\n\n# Low-level (returns the proto message):\nsummary = await acct.account_summary()\n# summary: AccountSummaryData\n</code></pre>"},{"location":"MT4Account/Account_Information/account_summary/#method-signature","title":"Method Signature","text":"<pre><code>async def account_summary(\n    self,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; account_helper_pb2.AccountSummaryData\n</code></pre>"},{"location":"MT4Account/Account_Information/account_summary/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A single RPC that returns the account state: balance, equity, currency, leverage, trade mode, and server time.</li> <li>Why you need it. Quick status for UI/CLI; double\u2011check login/currency/leverage; verify terminal responsiveness via <code>server_time</code>.</li> <li>Fast sanity check. If you see <code>account_login</code>, <code>account_currency</code>, <code>account_leverage</code>, <code>account_equity</code> \u2192 the connection is alive and data is flowing.</li> </ul>"},{"location":"MT4Account/Account_Information/account_summary/#input","title":"\ud83d\udd3d Input","text":"<p>No required parameters.</p> Parameter Type Description <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline \u2192 converted to timeout. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for the retry loop."},{"location":"MT4Account/Account_Information/account_summary/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Account_Information/account_summary/#payload-accountsummarydata-from-mt4_term_api_account_helper_pb2py","title":"Payload: <code>AccountSummaryData</code> (from <code>mt4_term_api_account_helper_pb2.py</code>)","text":"Field Proto Type Description <code>account_login</code> <code>int64</code> Trading account login (ID). <code>account_balance</code> <code>double</code> Balance excluding floating P/L. <code>account_equity</code> <code>double</code> Equity = balance + floating P/L. <code>account_user_name</code> <code>string</code> Account holder display name. <code>account_leverage</code> <code>int64</code> Leverage (e.g., <code>100</code> for 1:100). <code>account_trade_mode</code> <code>enum mt4_term_api.EnumAccountTradeMode</code> Account trade mode. <code>account_company_name</code> <code>string</code> Broker/company display name. <code>account_currency</code> <code>string</code> Deposit currency code (e.g., <code>USD</code>). <code>server_time</code> <code>google.protobuf.Timestamp</code> Server time (UTC) at response. <code>account_credit</code> <code>double</code> Credit amount. <code>is_investor</code> <code>bool</code> Investor access flag. <code>utc_server_time_shift_minutes</code> <code>int32</code> Server time offset relative to UTC (in minutes)."},{"location":"MT4Account/Account_Information/account_summary/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Account_Information/account_summary/#enumaccounttrademode","title":"<code>EnumAccountTradeMode</code>","text":"<p>Account trade mode values:</p> <ul> <li><code>ACCOUNT_TRADE_MODE_DEMO = 0</code> \u2014 Demo/practice account</li> <li><code>ACCOUNT_TRADE_MODE_CONTEST = 1</code> \u2014 Contest account</li> <li><code>ACCOUNT_TRADE_MODE_REAL = 2</code> \u2014 Real trading account</li> </ul> <p>Access in Python: <code>account_helper_pb2.EnumAccountTradeMode.ACCOUNT_TRADE_MODE_DEMO</code> Map enum \u2192 label in UI via <code>account_helper_pb2.EnumAccountTradeMode.Name(value)</code>.</p>"},{"location":"MT4Account/Account_Information/account_summary/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to display real\u2011time account state and sanity\u2011check connectivity:</p> <ul> <li>Dashboard/CLI status in one call.</li> <li>Verify free\u2011margin &amp; equity before trading.</li> <li>Terminal heartbeat via <code>server_time</code> and <code>utc_server_time_shift_minutes</code>.</li> </ul>"},{"location":"MT4Account/Account_Information/account_summary/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>The wrapper uses <code>execute_with_reconnect(...)</code> from <code>mt4_account.py</code> to retry transient gRPC errors.</li> <li>Prefer a short per\u2011call timeout (3\u20135s) with retries if the terminal is warming up or syncing symbols.</li> <li><code>is_investor=True</code> \u2192 trading operations may be restricted; reflect that in your UX.</li> </ul> <p>See also: <code>OpenedOrders(...)</code>, <code>OrdersHistory(...)</code>, <code>SymbolParamsMany(...)</code>, <code>TickValueWithSize(...)</code>.</p>"},{"location":"MT4Account/Account_Information/account_summary/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Account_Information/account_summary/#1-percall-deadline","title":"1) Per\u2011call deadline","text":"<pre><code># Enforce a short absolute deadline to avoid hanging calls\nfrom datetime import datetime, timedelta, timezone\n\nsummary = await acct.account_summary(\n    deadline=datetime.now(timezone.utc) + timedelta(seconds=3)\n)\nprint(f\"[deadline] Equity={summary.account_equity:.2f}\")\n</code></pre>"},{"location":"MT4Account/Account_Information/account_summary/#2-cooperative-cancellation-with-asyncioevent","title":"2) Cooperative cancellation (with asyncio.Event)","text":"<pre><code># Pass a cancellation_event to allow a graceful stop from another task\nimport asyncio\nfrom datetime import datetime, timedelta, timezone\n\ncancel_event = asyncio.Event()\n\nsummary = await acct.account_summary(\n    deadline=datetime.now(timezone.utc) + timedelta(seconds=3),\n    cancellation_event=cancel_event,\n)\nprint(f\"[cancel] Currency={summary.account_currency}\")\n</code></pre>"},{"location":"MT4Account/Account_Information/account_summary/#3-compact-status-line-for-uicli","title":"3) Compact status line for UI/CLI","text":"<pre><code># Produce a short, readable one\u2011liner for dashboards/CLI\ns = await acct.account_summary()\nstatus = (\n    f\"Acc {s.account_login} | {s.account_currency} | \"\n    f\"Bal {s.account_balance:.2f} | Eq {s.account_equity:.2f} | \"\n    f\"Lev {s.account_leverage} | Mode {s.account_trade_mode}\"\n)\nprint(status)\n</code></pre>"},{"location":"MT4Account/Account_Information/account_summary/#4-humanreadable-server-time-with-timezone-shift","title":"4) Human\u2011readable server time with timezone shift","text":"<pre><code># Convert server_time (UTC Timestamp) + shift (minutes) to a local server time string\nfrom datetime import timezone, timedelta\n\ns = await acct.account_summary()\nserver_dt_utc = s.server_time.ToDatetime().replace(tzinfo=timezone.utc)\nshift = timedelta(minutes=int(s.utc_server_time_shift_minutes))\nserver_local = server_dt_utc + shift\nprint(f\"Server time: {server_local.isoformat()} (shift {shift})\")\n</code></pre>"},{"location":"MT4Account/Account_Information/account_summary/#5-map-proto-your-dataclass-thin-viewmodel","title":"5) Map proto \u2192 your dataclass (thin view\u2011model)","text":"<pre><code># Keep only the fields you actually use; fast and test\u2011friendly\nfrom dataclasses import dataclass\n\n@dataclass\nclass AccountSummaryView:\n    login: int\n    currency: str\n    balance: float\n    equity: float\n    leverage: int\n    mode: int  # enum numeric; map to label if needed\n    investor: bool\n\n    @staticmethod\n    def from_proto(p):\n        return AccountSummaryView(\n            login=int(p.account_login),\n            currency=str(p.account_currency),\n            balance=float(p.account_balance),\n            equity=float(p.account_equity),\n            leverage=int(p.account_leverage),\n            mode=int(p.account_trade_mode),\n            investor=bool(p.is_investor),\n        )\n\ns = await acct.account_summary()\nview = AccountSummaryView.from_proto(s)\nprint(view)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/","title":"MT4Account \u00b7 Market / Quotes / Symbols \u2014 Overview","text":"<p>Price snapshots, symbol registry, per\u2011symbol trading rules, and historical bars. Use this page to choose the right API for your market data layer.</p>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>quote \u2014 single\u2011symbol snapshot (bid/ask or last, spread, time).</li> <li>quote_many \u2014 batch snapshots for many symbols at once.</li> <li>quote_history \u2014 OHLCV bars for a timeframe and time window.</li> <li>symbols \u2014 list of available symbols from the terminal.</li> <li>symbol_params_many \u2014 per\u2011symbol trading constraints (Digits, Point, VolumeMin/Max/Step, StopsLevel, FreezeLevel, etc.).</li> <li>tick_value_with_size \u2014 monetary value per tick for a given volume.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>quote / quote_many \u2192 your live price feed (pull mode) for UI tiles and sanity checks.</li> <li>symbols \u2192 the server truth list; cache it and validate user inputs against it.</li> <li>symbol_params_many \u2192 the rulebook per symbol: digits, point size, min/max volume, min SL/TP distance.</li> <li>quote_history \u2192 bars for charts, indicators, and backtests.</li> <li>tick_value_with_size \u2192 convert ticks \u2192 money for risk sizing.</li> </ul> <p>Rule of thumb: need now price \u2192 <code>quote*</code>; need allowed volume/SL/TP \u2192 <code>symbol_params_many</code>; need bars \u2192 <code>quote_history</code>.</p>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/#quick-choose","title":"Quick choose","text":"If you need\u2026 Use Returns Key inputs Price for one symbol (UI tile / check) <code>quote</code> <code>QuoteData</code> <code>symbol</code> Prices for many symbols at once <code>quote_many</code> <code>QuoteManyData</code> <code>symbols: list[str]</code> Historical bars for charts/backtests <code>quote_history</code> <code>QuoteHistoryData</code> (OHLCV) <code>symbol</code>, <code>timeframe</code>, <code>from</code>, <code>to</code> Full symbol list from terminal <code>symbols</code> <code>SymbolsData</code> (none) Trading constraints (digits/point/volume/limits) <code>symbol_params_many</code> <code>SymbolParamsManyData</code> <code>symbols: list[str]</code> Monetary tick value for a volume <code>tick_value_with_size</code> <code>TickValueWithSizeData</code> <code>symbol</code>, <code>volume</code>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/#crossrefs-gotchas","title":"\u274c Cross\u2011refs &amp; gotchas","text":"<ul> <li>Cache <code>symbols</code> and <code>symbol_params_many</code>; they rarely change intra\u2011session.</li> <li>Digits vs Point: format prices using <code>Digits</code>, compute deltas using <code>Point</code>.</li> <li>StopsLevel &amp; FreezeLevel: enforce minimum distance for SL/TP and pending prices.</li> <li>UTC everywhere for <code>quote_history</code>; align bar timestamps to timeframe.</li> <li>For large symbol sets, prefer <code>quote_many</code> to reduce round\u2011trips.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code># Validate a user symbol and fetch its quote\ns = await acct.symbols()\nvalid = { e.symbol_name for e in s.SymbolNameInfos }\nif 'EURUSD' in valid:\n    q = await acct.quote('EURUSD')\n</code></pre> <pre><code># Pull constraints and snap a volume\np = (await acct.symbol_params_many(['XAUUSD'])).symbol_infos[0]\ndef snap(vol):\n    vol = max(p.VolumeMin, min(p.VolumeMax, vol))\n    steps = round((vol - p.VolumeMin) / p.VolumeStep)\n    return p.VolumeMin + steps * p.VolumeStep\n</code></pre> <pre><code># Bars for last 7 days (H1)\nfrom datetime import datetime, timedelta, timezone\nend = datetime.now(timezone.utc)\nstart = end - timedelta(days=7)\nbars = await acct.quote_history('EURUSD', timeframe=market_pb2.QH_PERIOD_H1, from_time=start, to_time=end)\n</code></pre> <pre><code># Tick value for risk sizing\nv = (await acct.tick_value_with_size('GBPUSD', volume=0.2)).tick_value\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/Market_Quota.Overview/#see-also","title":"See also","text":"<ul> <li>Streams: <code>on_symbol_tick</code> \u2014 real-time ticks without polling</li> <li>Trading actions: <code>order_send</code>, <code>order_modify</code></li> <li>Live state &amp; history: <code>opened_orders</code>, <code>orders_history</code></li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote/","title":"\u2705 Getting a Quote","text":"<p>Request: retrieve the latest bid/ask + OHLC snapshot for a single symbol as <code>QuoteData</code>. Use it for price displays, quick validation, and point/tick computations.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>quote(symbol, ...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_market_info_pb2.py</code> \u2014 <code>Quote*</code> messages (<code>QuoteRequest</code>, <code>QuoteReply</code>, <code>QuoteData</code>)</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.MarketInfo</code></li> <li>Method: <code>Quote(QuoteRequest) \u2192 QuoteReply</code></li> <li>Low\u2011level client: <code>MarketInfoStub.Quote(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.quote(symbol: str, deadline=None, cancellation_event=None) \u2192 QuoteData</code></li> </ul> <p>Request message: <code>QuoteRequest { symbol: string }</code> Reply message: <code>QuoteReply { data: QuoteData }</code></p>"},{"location":"MT4Account/Market_quota_symbols/quote/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Fetch a fresh price snapshot for a symbol\nq = await acct.quote(\"EURUSD\")\nprint(\n    f\"{q.symbol} bid={q.bid:.5f} ask={q.ask:.5f} \"\n    f\"high={q.high:.5f} low={q.low:.5f} spread={getattr(q,'spread',0)}\"\n)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote/#method-signature","title":"Method Signature","text":"<pre><code>async def quote(\n    self,\n    symbol: str,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; market_info_pb2.QuoteData\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A single\u2011symbol price snapshot (bid/ask + basic OHLC) with a server timestamp.</li> <li>Why. UI price tiles, input validation (SL/TP distances), and point/tick conversions.</li> <li>Consistency. Pair with <code>symbol_params_many(...)</code> to respect digits/point/SL\u2011TP rules.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> Symbol to query (e.g., <code>EURUSD</code>). <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper."},{"location":"MT4Account/Market_quota_symbols/quote/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Market_quota_symbols/quote/#payload-quotedata","title":"Payload: <code>QuoteData</code>","text":"Field Proto Type Description <code>symbol</code> <code>string</code> Symbol name. <code>bid</code> <code>double</code> Best bid price. <code>ask</code> <code>double</code> Best ask price. <code>high</code> <code>double</code> Session high. <code>low</code> <code>double</code> Session low. <code>date_time</code> <code>google.protobuf.Timestamp</code> Server timestamp of the quote (UTC)."},{"location":"MT4Account/Market_quota_symbols/quote/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not use method\u2011specific enums. For historical bars/timeframes see <code>ENUM_QUOTE_HISTORY_TIMEFRAME</code> used by <code>QuoteHistory</code> (separate method).</p>"},{"location":"MT4Account/Market_quota_symbols/quote/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Render price tiles/cards and keep UX responsive.</li> <li>Validate SL/TP/limit distances against current price.</li> <li>Convert points \u2194 price deltas when combined with <code>symbol_params_many(...)</code>.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> for transient gRPC retries.</li> <li>Respect <code>Digits/Point</code> from <code>symbol_params_many(...)</code> when formatting prices.</li> <li>Combine with <code>tick_value_with_size(...)</code> to translate price moves into monetary values.</li> </ul> <p>See also: <code>symbol_params_many(...)</code> \u2014 per\u2011symbol constraints and enums. <code>tick_value_with_size(...)</code> \u2014 tick value/size &amp; contract size for PnL math. <code>quote_history(...)</code> \u2014 historical data (bars) with timeframe enum.</p>"},{"location":"MT4Account/Market_quota_symbols/quote/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Market_quota_symbols/quote/#1-spread-and-mid-price","title":"1) Spread and mid price","text":"<pre><code>q = await acct.quote(\"XAUUSD\")\nmid = (q.bid + q.ask) / 2\nspread_pts = getattr(q, \"spread\", 0)\nprint(f\"mid={mid:.2f} spread_pts={spread_pts}\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote/#2-enforce-sltp-distance-vs-stopslevel","title":"2) Enforce SL/TP distance vs StopsLevel","text":"<pre><code>p = (await acct.symbol_params_many(\"GBPUSD\")).params_info[0]\nq = await acct.quote(\"GBPUSD\")\nmin_pts = max(p.StopsLevel, p.FreezeLevel)\n# Example check for a BUY SL\nmin_price_delta = min_pts * p.Point\nsl_ok = (q.bid - 1.5 * min_price_delta) &gt; 0\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote/#3-price-money-per-tick","title":"3) Price \u2192 money per tick","text":"<pre><code>info = await acct.tick_value_with_size([\"EURUSD\"])  # one symbol\nr = info.items[0]\n# money per 1 tick per 1 lot\nmoney_per_tick = r.TradeTickValue\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_history/","title":"\u2705 Getting Historical Quotes","text":"<p>Request: retrieve OHLCV bars for a symbol and timeframe within a time range as <code>QuoteHistoryData</code>. Use this for charts, backtests, and indicators.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>quote_history(symbol, timeframe, from_time, to_time, ...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_market_info_pb2.py</code> \u2014 <code>QuoteHistory*</code> + <code>ENUM_QUOTE_HISTORY_TIMEFRAME</code></li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.MarketInfo</code></li> <li>Method: <code>QuoteHistory(QuoteHistoryRequest) \u2192 QuoteHistoryReply</code></li> <li>Low\u2011level client: <code>MarketInfoStub.QuoteHistory(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.quote_history(symbol: str, timeframe: ENUM_QUOTE_HISTORY_TIMEFRAME, from_time: datetime, to_time: datetime, deadline=None, cancellation_event=None) \u2192 QuoteHistoryData</code></li> </ul> <p>Request message: <code>QuoteHistoryRequest { symbol: string, timeframe: ENUM_QUOTE_HISTORY_TIMEFRAME, from_time: Timestamp, to_time: Timestamp }</code> Reply message: <code>QuoteHistoryReply { data: QuoteHistoryData }</code></p>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code>from datetime import datetime, timedelta, timezone\nfrom MetaRpcMT4 import mt4_term_api_market_info_pb2 as market_pb2\n\nsymbol = \"EURUSD\"\nend = datetime.now(timezone.utc)\nstart = end - timedelta(days=7)\n\nbars = await acct.quote_history(\n    symbol=symbol,\n    timeframe=market_pb2.QH_PERIOD_H1,\n    from_time=start,\n    to_time=end,\n)\n\n# Print a compact ledger of bars\nfor b in bars.items:  # list[QuoteBar]\n    ts = b.date_time.ToDatetime().replace(tzinfo=timezone.utc)\n    print(f\"{ts.isoformat()} O={b.open:.5f} H={b.high:.5f} L={b.low:.5f} C={b.close:.5f} TV={b.tick_volume}\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#method-signature","title":"Method Signature","text":"<pre><code>async def quote_history(\n    self,\n    symbol: str,\n    timeframe: market_info_pb2.ENUM_QUOTE_HISTORY_TIMEFRAME,\n    from_time: datetime,\n    to_time: datetime,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; market_info_pb2.QuoteHistoryData\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Server\u2011side historical bars (OHLC + volumes) for a symbol/timeframe.</li> <li>Why. Drive charts, compute indicators (MA/RSI), and feed backtests.</li> <li>Windowing. Bars are returned for <code>[from_time, to_time]</code> in UTC.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> Symbol (e.g., <code>EURUSD</code>). <code>timeframe</code> <code>ENUM_QUOTE_HISTORY_TIMEFRAME</code> Bar timeframe (see enum below). <code>from_time</code> <code>datetime</code> (UTC) Start of the requested interval. <code>to_time</code> <code>datetime</code> (UTC) End of the requested interval. <code>deadline</code> <code>datetime                      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event                 | None</code> Cooperative cancel for the retry wrapper."},{"location":"MT4Account/Market_quota_symbols/quote_history/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Market_quota_symbols/quote_history/#payload-quotehistorydata","title":"Payload: <code>QuoteHistoryData</code>","text":"Field Type Description <code>historical_quotes</code> <code>HistoryQuote[]</code> Array of historical bars for the requested period. <p>Each <code>HistoryQuote</code> element contains:</p> Field Proto Type Description <code>symbol</code> <code>string</code> Symbol name. <code>index</code> <code>int32</code> Bar index in the sequence. <code>time</code> <code>google.protobuf.Timestamp</code> Bar timestamp (UTC, aligned to timeframe). <code>open</code> <code>double</code> Open price. <code>high</code> <code>double</code> High price. <code>low</code> <code>double</code> Low price. <code>close</code> <code>double</code> Close price. <code>tick_volume</code> <code>int64</code> Tick volume for the bar. <code>real_volume</code> <code>int64</code> Real volume (if broker provides). <code>spread</code> <code>int32</code> Spread value for the bar."},{"location":"MT4Account/Market_quota_symbols/quote_history/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Market_quota_symbols/quote_history/#enum_quote_history_timeframe","title":"<code>ENUM_QUOTE_HISTORY_TIMEFRAME</code>","text":"<p>Timeframe values:</p> <ul> <li><code>QH_PERIOD_M1 = 0</code> \u2014 1 minute bars</li> <li><code>QH_PERIOD_M5 = 1</code> \u2014 5 minute bars</li> <li><code>QH_PERIOD_M15 = 2</code> \u2014 15 minute bars</li> <li><code>QH_PERIOD_M30 = 3</code> \u2014 30 minute bars</li> <li><code>QH_PERIOD_H1 = 4</code> \u2014 1 hour bars</li> <li><code>QH_PERIOD_H4 = 5</code> \u2014 4 hour bars</li> <li><code>QH_PERIOD_D1 = 6</code> \u2014 Daily bars</li> <li><code>QH_PERIOD_W1 = 7</code> \u2014 Weekly bars</li> <li><code>QH_PERIOD_MN1 = 8</code> \u2014 Monthly bars</li> </ul> <p>Use <code>market_info_pb2.ENUM_QUOTE_HISTORY_TIMEFRAME.Name(value)</code> to map numbers \u2192 labels.</p>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Build charts and compute indicators.</li> <li>Backtest strategies on a bounded window.</li> <li>Export OHLCV for analytics.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> for transient gRPC retries.</li> <li>Ensure <code>from_time &lt; to_time</code> and keep windows reasonably sized to avoid timeouts.</li> <li>Respect symbol <code>Digits/Point</code> for formatting and rounding.</li> <li>Some brokers omit <code>real_volume</code>; rely on <code>tick_volume</code> if so.</li> </ul> <p>See also: <code>quote(...)</code>, <code>quote_many(...)</code> \u2014 live snapshots. <code>symbol_params_many(...)</code> \u2014 symbol constraints (digits/point). <code>tick_value_with_size(...)</code> \u2014 monetary value per tick.</p>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Market_quota_symbols/quote_history/#1-build-a-pandasfriendly-structure","title":"1) Build a pandas\u2011friendly structure","text":"<pre><code>from datetime import datetime, timedelta, timezone\nfrom MetaRpcMT4 import mt4_term_api_market_info_pb2 as market_pb2\n\nbars = await acct.quote_history(\n    symbol=\"XAUUSD\",\n    timeframe=market_pb2.QH_PERIOD_M15,\n    from_time=datetime.now(timezone.utc) - timedelta(days=2),\n    to_time=datetime.now(timezone.utc),\n)\n\nrows = [\n    {\n        \"ts\": b.date_time.ToDatetime().replace(tzinfo=timezone.utc),\n        \"open\": b.open,\n        \"high\": b.high,\n        \"low\": b.low,\n        \"close\": b.close,\n        \"tv\": getattr(b, \"tick_volume\", None),\n        \"rv\": getattr(b, \"real_volume\", None),\n    }\n    for b in bars.items\n]\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#2-rolling-sma-example","title":"2) Rolling SMA example","text":"<pre><code># Compute a simple moving average over the closes\nN = 20\ncloses = [b.close for b in bars.items]\nsma = [sum(closes[i-N:i])/N for i in range(N, len(closes)+1)]\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_history/#3-guardrails-for-big-windows","title":"3) Guardrails for big windows","text":"<pre><code>from datetime import timedelta\n\nMAX_DAYS = 120  # example policy\nif (to_time - from_time) &gt; timedelta(days=MAX_DAYS):\n    raise ValueError(\"Window too large; request in chunks or lower timeframe.\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_many/","title":"\u2705 Getting Multiple Quotes","text":"<p>Request: retrieve the latest price snapshot for multiple symbols at once as <code>QuoteManyData</code>. Fastest way to fill UI tiles or pre\u2011validate orders across several instruments.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>quote_many(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_market_info_pb2.py</code> \u2014 <code>QuoteMany*</code> and <code>QuoteData</code></li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.MarketInfo</code></li> <li>Method: <code>QuoteMany(QuoteManyRequest) \u2192 QuoteManyReply</code></li> <li>Low\u2011level client: <code>MarketInfoStub.QuoteMany(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.quote_many(symbols: list[str], deadline=None, cancellation_event=None) \u2192 QuoteManyData</code></li> </ul> <p>Request message: <code>QuoteManyRequest { symbols: string[] }</code> Reply message: <code>QuoteManyReply { data: QuoteManyData }</code></p>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Fetch quotes for a basket of symbols\nrows = await acct.quote_many([\"EURUSD\", \"GBPUSD\", \"XAUUSD\"])\n\n# rows: QuoteManyData\n# Common patterns (depending on pb schema):\n# 1) If the reply contains .items with QuoteData objects in request order:\nfor q in rows.items:  # list[QuoteData]\n    print(f\"{q.symbol} bid={q.bid:.5f} ask={q.ask:.5f}\")\n\n# 2) If the reply contains name+quote tuples (e.g., SymbolNameInfos):\n# for e in rows.SymbolNameInfos:  # list[ { symbolName, data: QuoteData, index } ]\n#     q = e.data\n#     print(f\"{e.symbolName} bid={q.bid:.5f} ask={q.ask:.5f}\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#method-signature","title":"Method Signature","text":"<pre><code>async def quote_many(\n    self,\n    symbols: list[str],\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; market_info_pb2.QuoteManyData\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A batched quote call that returns bid/ask + OHLC per symbol.</li> <li>Why. Reduces round\u2011trips versus calling <code>quote(...)</code> repeatedly; keeps UI grids snappy.</li> <li>Ordering. Reply typically preserves request order (via <code>index</code> or contiguous list semantics).</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbols</code> <code>list[str]</code> Symbols to fetch, e.g., <code>[\"EURUSD\",\"XAUUSD\"]</code>. <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper."},{"location":"MT4Account/Market_quota_symbols/quote_many/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Market_quota_symbols/quote_many/#payload-quotemanydata","title":"Payload: <code>QuoteManyData</code>","text":"Field Type Description <code>quotes</code> <code>QuoteData[]</code> Array of quotes in the same order as requested. <p>Each <code>QuoteData</code> element contains (from <code>mt4_term_api_market_info_pb2.py</code>):</p> <ul> <li><code>symbol: string</code></li> <li><code>bid: double</code>, <code>ask: double</code></li> <li><code>high: double</code>, <code>low: double</code></li> <li><code>date_time: google.protobuf.Timestamp</code></li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not use method\u2011specific enums. Timeframe enums apply to <code>quote_history(...)</code>, not to <code>quote_many</code>.</p>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Populate price grids/tiles efficiently.</li> <li>Validate SL/TP distances across a basket before submitting multiple orders.</li> <li>Compute mid/spread metrics in bulk.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> for transient gRPC retries.</li> <li>Keep the basket reasonable in hot paths; huge symbol lists will increase payload size and latency.</li> <li>Combine with <code>symbol_params_many(...)</code> for digits/point/SL\u2011TP constraints and with <code>tick_value_with_size(...)</code> for money\u2011per\u2011tick conversions.</li> </ul> <p>See also: <code>quote(...)</code> \u2014 single\u2011symbol snapshot. <code>quote_history(...)</code> \u2014 historical bars with timeframe enum. <code>symbol_params_many(...)</code> \u2014 constraints &amp; trade/margin enums.</p>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Market_quota_symbols/quote_many/#1-compact-grid-printer","title":"1) Compact grid printer","text":"<pre><code>rows = await acct.quote_many([\"EURUSD\",\"USDJPY\",\"XAUUSD\"])\n# Variant A: contiguous items\nfor q in getattr(rows, 'items', []):\n    print(f\"{q.symbol:8} bid={q.bid:.5f} ask={q.ask:.5f}\")\n\n# Variant B: name+quote tuples\nfor e in getattr(rows, 'SymbolNameInfos', []):\n    q = e.data\n    print(f\"{e.symbolName:8} bid={q.bid:.5f} ask={q.ask:.5f}\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#2-mid-spread-per-symbol","title":"2) Mid &amp; spread per symbol","text":"<pre><code>rows = await acct.quote_many([\"EURUSD\",\"GBPUSD\"])  # batch\n\ndef handle_quote(q):\n    mid = (q.bid + q.ask) / 2\n    spread = getattr(q, 'spread', None)\n    return mid, spread\n\nif hasattr(rows, 'items'):\n    stats = { q.symbol: handle_quote(q) for q in rows.items }\nelif hasattr(rows, 'SymbolNameInfos'):\n    stats = { e.symbolName: handle_quote(e.data) for e in rows.SymbolNameInfos }\n\nprint(stats)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/quote_many/#3-validate-sltp-distance-for-all-symbols","title":"3) Validate SL/TP distance for all symbols","text":"<pre><code># For each symbol: fetch params + quote; ensure planned SL distance &gt;= StopsLevel\nsymbols = [\"EURUSD\",\"USDJPY\",\"XAUUSD\"]\nqmany = await acct.quote_many(symbols)\nparams_all = await acct.symbol_params_many()  # beware: heavy; prefer single-symbol calls in hot paths\n\n# Build a dict of StopsLevel/Point by symbol\npmap = { p.Symbol: p for p in params_all.params_info }\n\n# Iterate quotes in either layout\ndef iter_quotes(reply):\n    if hasattr(reply, 'items'):\n        for q in reply.items:\n            yield q.symbol, q\n    else:\n        for e in reply.SymbolNameInfos:\n            yield e.symbolName, e.data\n\nfor sym, q in iter_quotes(qmany):\n    p = pmap.get(sym)\n    if not p:\n        continue\n    min_pts = max(p.StopsLevel, p.FreezeLevel)\n    min_delta = min_pts * p.Point\n    # Example: BUY SL must be at least min_delta below bid\n    # sl_ok = (q.bid - planned_sl_distance) &gt;= min_delta\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/","title":"\u2705 Getting Symbol Parameters","text":"<p>Request: retrieve trading parameters for one symbol or all symbols as a structured payload (<code>SymbolParamsManyData</code>). Ideal for pre\u2011trade validation, UI forms, and margin/risk calculations.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>symbol_params_many(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_account_helper_pb2.py</code> \u2014 <code>SymbolParamsMany*</code> (+ related enums)</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.AccountHelper</code></li> <li>Method: <code>SymbolParamsMany(SymbolParamsManyRequest) \u2192 SymbolParamsManyReply</code></li> <li>Low\u2011level client: <code>AccountHelperStub.SymbolParamsMany(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.symbol_params_many(symbol_name: str | None = None, deadline=None, cancellation_event=None) \u2192 SymbolParamsManyData</code></li> </ul> <p>Request message: <code>SymbolParamsManyRequest { symbol_name? }</code> Reply message: <code>SymbolParamsManyReply { data: SymbolParamsManyData }</code></p>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Fetch params for a single symbol\ninfo = await acct.symbol_params_many(symbol_name=\"EURUSD\")\nfor p in info.params_info:  # list[SymbolParamsManyInfo]\n    print(p.Symbol, p.Digits, p.Point, p.TradeMode)\n\n# Fetch params for all symbols (may be large)\nall_info = await acct.symbol_params_many()\nprint(f\"Symbols returned: {len(all_info.params_info)}\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_params_many(\n    self,\n    symbol_name: str | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; account_helper_pb2.SymbolParamsManyData\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A server\u2011side snapshot of symbol trading parameters (tick size/value, digits, execution mode, volume bounds, etc.).</li> <li>Why. Validate orders (min/max/step), display constraints in UI, compute margin and risk correctly for each symbol.</li> <li>Scope. If <code>symbol_name</code> is <code>None</code>, returns all available symbols; otherwise, only the requested symbol.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol_name</code> <code>str           | None</code> Specific symbol to query; <code>None</code> \u2192 all symbols. <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline (converted to timeout). <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for the retry wrapper."},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#payload-symbolparamsmanydata","title":"Payload: <code>SymbolParamsManyData</code>","text":"Field Type Description <code>symbol_infos</code> <code>SymbolParamsManyInfo[]</code> Array of symbol parameters for each requested symbol. <p>Each <code>SymbolParamsManyInfo</code> element contains (typical fields):</p> Field Proto Type / Enum Description <code>SymbolName</code> <code>string</code> Symbol name (e.g., <code>EURUSD</code>). <code>Digits</code> <code>int32</code> Price digits. <code>Point</code> <code>double</code> Minimal price increment. <code>SpreadFloat</code> <code>bool</code> Whether spread is floating. <code>TradeMode</code> <code>SP_ENUM_SYMBOL_TRADE_MODE</code> Symbol trade mode (enabled/close\u2011only/disabled). <code>TradeExeMode</code> <code>SP_ENUM_SYMBOL_TRADE_EXECUTION</code> Execution mode (Instant/Market/Exchange). <code>TradeCalcMode</code> <code>SP_ENUM_TRADE_CALC_MODE</code> Margin calculation mode (Forex/CFD/Futures\u2026). <code>TradeStopsLevel</code> <code>int32</code> Min distance for SL/TP from current price (points). <code>TradeFreezeLevel</code> <code>int32</code> Freeze level in points. <code>VolumeMin</code> <code>double</code> Minimal volume. <code>VolumeMax</code> <code>double</code> Maximal volume. <code>VolumeStep</code> <code>double</code> Volume step. <code>VolumeLow</code> <code>int64</code> Session low volume metric. <code>volume_high</code> <code>int64</code> Session high volume metric. <code>TradeContractSize</code> <code>double</code> Contract size (e.g., 100000 for FX). <code>TradeTickSize</code> <code>double</code> Minimal tick size. <code>TradeTickValue</code> <code>double</code> Tick value in deposit currency. <code>MarginStop</code> <code>double</code> Margin requirement for Stop orders. <code>MarginStopLimit</code> <code>double</code> Margin requirement for Stop\u2011Limit orders. <code>CurrencyBase</code> <code>string</code> Base currency (e.g., \"EUR\" for EURUSD). <code>CurrencyProfit</code> <code>string</code> Profit currency. <code>CurrencyMargin</code> <code>string</code> Margin currency. <p>Note: Field names use CamelCase as per protobuf schema. Consult <code>mt4_term_api_account_helper_pb2.py</code> for the complete authoritative list.</p>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>These enums are present in the pb and are relevant to <code>symbol_params_many</code>:</p>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#sp_enum_symbol_trade_mode","title":"<code>SP_ENUM_SYMBOL_TRADE_MODE</code>","text":"<p>Describes whether the symbol is tradable:</p> <ul> <li><code>SYMBOL_TRADE_MODE_DISABLED = 0</code> \u2014 Trading disabled</li> <li><code>SYMBOL_TRADE_MODE_LONGONLY = 1</code> \u2014 Only long positions allowed</li> <li><code>SYMBOL_TRADE_MODE_SHORTONLY = 2</code> \u2014 Only short positions allowed</li> <li><code>SYMBOL_TRADE_MODE_CLOSEONLY = 3</code> \u2014 Only closing existing positions allowed</li> <li><code>SYMBOL_TRADE_MODE_FULL = 4</code> \u2014 Full trading enabled</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#sp_enum_symbol_trade_execution","title":"<code>SP_ENUM_SYMBOL_TRADE_EXECUTION</code>","text":"<p>Execution regime for orders on the symbol:</p> <ul> <li><code>SYMBOL_TRADE_EXECUTION_REQUEST = 0</code> \u2014 Request execution</li> <li><code>SYMBOL_TRADE_EXECUTION_INSTANT = 1</code> \u2014 Instant execution</li> <li><code>SYMBOL_TRADE_EXECUTION_MARKET = 2</code> \u2014 Market execution</li> <li><code>SYMBOL_TRADE_EXECUTION_EXCHANGE = 3</code> \u2014 Exchange execution</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#sp_enum_trade_calc_mode","title":"<code>SP_ENUM_TRADE_CALC_MODE</code>","text":"<p>Defines how margin is calculated for the symbol class:</p> <ul> <li><code>SYMBOL_TRADE_MARGINE_CALC_MODE_FOREX = 0</code> \u2014 Forex calculation</li> <li><code>SYMBOL_TRADE_MARGINE_CALC_MODE_FUTURES = 1</code> \u2014 Futures calculation</li> <li><code>SYMBOL_TRADE_MARGINE_CALC_MODE_CFD = 2</code> \u2014 CFD calculation</li> </ul> <p>Use <code>account_helper_pb2.SP_ENUM_SYMBOL_TRADE_MODE.Name(value)</code> to map numeric values \u2192 human\u2011readable labels in your UI.</p>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Validate user input before sending orders (min/max/step, SL/TP distances).</li> <li>Pre\u2011compute margin and risk for order tickets.</li> <li>Populate UI forms with correct constraints per symbol.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> to retry transient gRPC errors.</li> <li>Fetching all symbols can be heavy; prefer single\u2011symbol queries in hot paths.</li> <li>Combine with <code>tick_value_with_size(...)</code> for precise PnL/margin math for a given volume.</li> </ul> <p>See also: <code>quote(...)</code> \u2014 latest price for a symbol. <code>tick_value_with_size(...)</code> \u2014 tick value scaled by volume. <code>opened_orders(...)</code> \u2014 current positions; validate against symbol rules.</p>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#1-enforce-volume-step-bounds-in-ui","title":"1) Enforce volume step &amp; bounds in UI","text":"<pre><code>params = await acct.symbol_params_many(\"XAUUSD\")\np = params.symbol_infos[0]\n\n# Clamp and snap volume to step\ndef snap_volume(vol: float, min_v: float, max_v: float, step: float) -&gt; float:\n    vol = max(min_v, min(max_v, vol))\n    steps = round((vol - min_v) / step)\n    return min_v + steps * step\n\nv_ok = snap_volume(0.27, p.VolumeMin, p.VolumeMax, p.VolumeStep)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#2-check-sltp-distance","title":"2) Check SL/TP distance","text":"<pre><code>p = (await acct.symbol_params_many(\"GBPUSD\")).params_info[0]\nmin_pts = max(p.StopsLevel, p.FreezeLevel)\nprint(f\"Minimum SL/TP distance: {min_pts} points\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbol_params_many/#3-convert-enum-values-to-labels","title":"3) Convert enum values to labels","text":"<pre><code>from MetaRpcMT4 import mt4_term_api_account_helper_pb2 as account_pb2\n\np = (await acct.symbol_params_many(\"EURUSD\")).params_info[0]\ntrade_mode_label = account_pb2.SP_ENUM_SYMBOL_TRADE_MODE.Name(p.TradeMode)\nexe_mode_label = account_pb2.SP_ENUM_SYMBOL_TRADE_EXECUTION.Name(p.TradeExeMode)\ncalc_mode_label = account_pb2.SP_ENUM_TRADE_CALC_MODE.Name(p.TradeCalcMode)\nprint(trade_mode_label, exe_mode_label, calc_mode_label)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbols/","title":"\u2705 Getting All Symbols","text":"<p>Request: retrieve the full list of tradable symbols from the connected terminal as <code>SymbolsData</code>. Use it to populate dropdowns, build watchlists, and validate symbol names.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>symbols(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_market_info_pb2.py</code> \u2014 <code>Symbols*</code> messages (<code>SymbolsRequest</code>, <code>SymbolsReply</code>, <code>SymbolsData</code>)</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbols/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.MarketInfo</code></li> <li>Method: <code>Symbols(SymbolsRequest) \u2192 SymbolsReply</code></li> <li>Low\u2011level client: <code>MarketInfoStub.Symbols(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.symbols(deadline=None, cancellation_event=None) \u2192 SymbolsData</code></li> </ul> <p>Request message: <code>SymbolsRequest {}</code> Reply message: <code>SymbolsReply { data: SymbolsData }</code></p>"},{"location":"MT4Account/Market_quota_symbols/symbols/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Fetch every tradable symbol from the terminal\ns = await acct.symbols()\nfor e in s.SymbolNameInfos:\n    print(e.symbol_name, e.symbol_index)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbols/#method-signature","title":"Method Signature","text":"<pre><code>async def symbols(\n    self,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; market_info_pb2.SymbolsData\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbols/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A terminal\u2011side registry of available symbols.</li> <li>Why. Populate UI lists, validate user input, and drive bulk market calls (<code>quote_many</code>, <code>symbol_params_many</code>).</li> <li>When to call. At startup and then cache; refresh on user demand or daily.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbols/#input","title":"\ud83d\udd3d Input","text":"<p>No required parameters.</p> Parameter Type Description <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper."},{"location":"MT4Account/Market_quota_symbols/symbols/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Market_quota_symbols/symbols/#payload-symbolsdata","title":"Payload: <code>SymbolsData</code>","text":"Field Type Description <code>SymbolNameInfos</code> <code>SymbolNameInfo[]</code> Array of symbols with names and terminal indices. <p>Each <code>SymbolNameInfo</code> element contains:</p> Field Proto Type Description <code>symbol_name</code> <code>string</code> Symbol name (e.g., \"EURUSD\"). <code>symbol_index</code> <code>int32</code> Terminal index for this symbol."},{"location":"MT4Account/Market_quota_symbols/symbols/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not use method\u2011specific enums.</p>"},{"location":"MT4Account/Market_quota_symbols/symbols/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Build autocomplete/watchlists reliably from server truth.</li> <li>Validate symbol inputs before calling order/market RPCs.</li> <li>Map symbol \u2192 index if required by other endpoints.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/symbols/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> for transient gRPC retries.</li> <li>Cache aggressively; the list is large and rarely changes intra\u2011session.</li> <li>If your integration supports hidden/non\u2011tradeable symbols, filter them at UI level.</li> </ul> <p>See also: <code>symbol_params_many(...)</code> \u2014 per\u2011symbol trading constraints and enums. <code>quote_many(...)</code> \u2014 batch price snapshots for multiple symbols. <code>opened_orders(...)</code> \u2014 positions by symbol.</p>"},{"location":"MT4Account/Market_quota_symbols/symbols/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Market_quota_symbols/symbols/#1-build-a-fast-lookup-set","title":"1) Build a fast lookup set","text":"<pre><code>s = await acct.symbols()\nname_set = {e.symbol_name for e in s.SymbolNameInfos}\n\ndef known(sym: str) -&gt; bool:\n    return sym in name_set\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbols/#2-populate-a-dropdown-model-sorted","title":"2) Populate a dropdown model (sorted)","text":"<pre><code>s = await acct.symbols()\nnames = [e.symbol_name for e in s.SymbolNameInfos]\nui_model = sorted(names)  # feed into your UI\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/symbols/#3-refresh-on-demand","title":"3) Refresh on demand","text":"<pre><code># Re-pull on user request or daily schedule\ns = await acct.symbols(deadline=some_deadline)\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/","title":"\u2705 Getting Tick Value &amp; Tick Size","text":"<p>Request: retrieve tick value, tick size, and contract size for one or more symbols as a compact payload (<code>TickValueWithSizeData</code>). Use this for precise PnL, risk, and margin pre\u2011checks.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>tick_value_with_size(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_account_helper_pb2.py</code> \u2014 <code>TickValueWithSize*</code></li> </ul>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.AccountHelper</code></li> <li>Method: <code>TickValueWithSize(TickValueWithSizeRequest) \u2192 TickValueWithSizeReply</code></li> <li>Low\u2011level client: <code>AccountHelperStub.TickValueWithSize(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.tick_value_with_size(symbol_names: list[str], deadline=None, cancellation_event=None) \u2192 TickValueWithSizeData</code></li> </ul> <p>Request message: <code>TickValueWithSizeRequest { symbol_names: string[] }</code> Reply message: <code>TickValueWithSizeReply { data: TickValueWithSizeData }</code></p>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Compute PnL per one tick for several symbols\nresp = await acct.tick_value_with_size([\"EURUSD\", \"XAUUSD\", \"US30.cash\"])\nfor row in resp.items:  # list[TickValueWithSizeInfo]\n    print(\n        f\"{row.symbolName}: tick={row.TradeTickSize:g} value={row.TradeTickValue:.2f} \"\n        f\"contract={row.ContractSize:g} base={row.CurrencyBase} profit={row.CurrencyProfit}\"\n    )\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#method-signature","title":"Method Signature","text":"<pre><code>async def tick_value_with_size(\n    self,\n    symbol_names: list[str],\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; account_helper_pb2.TickValueWithSizeData\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Server\u2011side calculation helper that returns tick metrics for each requested symbol.</li> <li>Why. Required to compute expected PnL per tick and to normalize between instruments with different contract sizes.</li> <li>Batching. Send multiple symbols in one request; reply preserves ordering via an index field.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol_names</code> <code>list[str]</code> Symbols to query. <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper."},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#payload-tickvaluewithsizedata","title":"Payload: <code>TickValueWithSizeData</code>","text":"Field Type Description <code>infos</code> <code>SymbolTickValueWithSizeInfo[]</code> Array of tick value info for requested symbols. <p>Each <code>SymbolTickValueWithSizeInfo</code> element contains:</p> Field Proto Type Description <code>index</code> <code>int32</code> Position in the reply list (maps to request order). <code>symbolName</code> <code>string</code> Symbol name. <code>TradeTickValue</code> <code>double</code> Tick value in deposit currency for 1 contract lot. <code>TradeTickSize</code> <code>double</code> Minimal price increment (tick size). <code>TradeContractSize</code> <code>double</code> Contract size (e.g., 100000 for FX majors)."},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not define method\u2011specific enums.</p> <p>For pricing/margin semantics, combine with enums exposed in symbol parameters (<code>SP_ENUM_*</code> in <code>SymbolParamsMany</code>).</p>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Convert price deltas \u2192 money deltas (per tick) consistently across instruments.</li> <li>Pre\u2011check whether a target PnL (in currency) corresponds to a feasible price move.</li> <li>Build UI tables showing tick metrics next to symbol constraints.</li> </ul>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> for transient gRPC retries.</li> <li>Result values are in deposit currency; if you display in another currency, convert explicitly.</li> <li>Pair with <code>symbol_params_many(...)</code> to enforce volume/step/SL\u2011TP constraints, and with <code>quote(...)</code> to compute value per point vs tick.</li> </ul> <p>See also: <code>symbol_params_many(...)</code> \u2014 symbol constraints and trade/margin enums. <code>quote(...)</code> \u2014 current price snapshot. <code>opened_orders(...)</code> \u2014 verify PnL math against live positions.</p>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#1-compute-monetary-value-of-1-pip-fx","title":"1) Compute monetary value of 1 pip (FX)","text":"<pre><code>from decimal import Decimal\n\nrows = (await acct.tick_value_with_size([\"EURUSD\"]))\nr = rows.items[0]\n# For many brokers: pip = 10 * tick when price has 5 digits\npip_value = Decimal(r.TradeTickValue) * 10\nprint(f\"EURUSD pip value (1 lot): {pip_value:.2f}\")\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#2-pnl-for-n-ticks","title":"2) PnL for N ticks","text":"<pre><code>r = (await acct.tick_value_with_size([\"XAUUSD\"]).items[0])\nvalue = r.TradeTickValue * 12  # money per 12 ticks, 1 lot\n</code></pre>"},{"location":"MT4Account/Market_quota_symbols/tick_value_with_size/#3-show-a-compact-table","title":"3) Show a compact table","text":"<pre><code>symbols = [\"EURUSD\", \"GBPUSD\", \"XAUUSD\"]\ndata = await acct.tick_value_with_size(symbols)\nfor row in data.items:\n    print(f\"{row.symbolName:8} tick={row.TradeTickSize:g} value={row.TradeTickValue:.2f}\")\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/","title":"MT4Account \u00b7 Orders &amp; Positions History \u2014 Overview","text":"<p>Live state snapshots + historical ledgers. Use this page to choose the correct data source for your UI, risk system, or analytics.</p>"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>opened_orders \u2014 current market positions + pending orders with full details.</li> <li>opened_orders_tickets \u2014 only ticket IDs of opened orders/positions (lightweight snapshot).</li> <li>orders_history \u2014 historical orders &amp; deals (closed operations).</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>opened_orders \u2192 \u201cWhat\u2019s live right now?\u201d \u2014 objects you see on the trade tab.</li> <li>opened_orders_tickets \u2192 \u201cDid something open/close?\u201d \u2014 fast change detection.</li> <li>orders_history \u2192 \u201cWhat happened before?\u201d \u2014 time\u2011ranged closed orders/deals ledger.</li> </ul> <p>Rule of thumb: UI or risk needs details now \u2192 <code>opened_orders()</code>. Need just IDs to decide refresh \u2192 <code>opened_orders_tickets()</code>. Need past actions \u2192 <code>orders_history()</code>.</p>"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/#quick-choose","title":"Quick choose","text":"If you need\u2026 Use Returns Key inputs Full details of live positions &amp; pending orders <code>opened_orders</code> <code>OpenedOrdersData</code> <code>sort_mode?</code>, <code>deadline?</code>, <code>cancellation_event?</code> IDs only for open trading objects <code>opened_orders_tickets</code> <code>OpenedOrdersTicketsData</code> optional <code>deadline</code>, <code>cancellation_event</code> Closed orders &amp; deals over period <code>orders_history</code> <code>OrdersHistoryData</code> <code>from</code>, <code>to</code>, <code>sort_mode</code>, paging? (future)"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/#crossrefs-gotchas","title":"\u274c Cross\u2011refs &amp; gotchas","text":"<ul> <li>UTC timestamps everywhere \u2192 convert once.</li> <li>Server\u2011side sorting for <code>opened_orders</code> \u2014 enums drive ordering.</li> <li><code>orders_history</code>: mixed orders &amp; deals \u2014 check which fields are set per row.</li> <li>Filtering by symbol should be done on client side.</li> <li>After reconnects: stream update may arrive first \u2192 pull a fresh snapshot.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code># Count live objects\nod = await acct.opened_orders()\nprint(len(od.order_infos))  # positions + pendings together\n</code></pre> <pre><code># Ticket set for quick diff\ns = await acct.opened_orders_tickets()\nall_tickets = set(s.position_tickets) | set(s.pending_order_tickets)\nprint(all_tickets)\n</code></pre> <pre><code># Last 24h closed records (depends on your history time fields)\nfrom datetime import datetime, timedelta, timezone\nend = datetime.now(timezone.utc)\nstart = end - timedelta(days=1)\nh = await acct.orders_history(start, end)\nprint(len(h.orders_info))\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/Positions_History_Overview/#see-also","title":"See also","text":"<ul> <li>Streams: <code>on_opened_orders_tickets</code>, <code>on_opened_orders_profit</code>, <code>on_trade</code></li> <li>Quotes &amp; symbols: <code>quote</code>, <code>symbol_params_many</code></li> <li>Trading actions: <code>order_send</code></li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/","title":"\u2705 Getting Opened Orders","text":"<p>Request: retrieve the full list of currently opened orders/positions as a single payload (<code>OpenedOrdersData</code>). Filtering and sorting are applied server\u2011side.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>opened_orders(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_account_helper_pb2.py</code> \u2014 <code>OpenedOrders*</code>, <code>EnumOpenedOrderSortType</code>, <code>OpenedOrderType</code></li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.AccountHelper</code></li> <li>Method: <code>OpenedOrders(OpenedOrdersRequest) \u2192 OpenedOrdersReply</code></li> <li>Low\u2011level client: <code>AccountHelperStub.OpenedOrders(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.opened_orders(sort_mode=EnumOpenedOrderSortType.SORT_BY_OPEN_TIME_ASC, deadline=None, cancellation_event=None) \u2192 OpenedOrdersData</code></li> </ul> <p>Request message: <code>OpenedOrdersRequest { sort_type: EnumOpenedOrderSortType }</code> Reply message: <code>OpenedOrdersReply { data: OpenedOrdersData }</code></p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># High-level: fetch + print a compact table\nasync def show_opened_orders(acct):\n    od = await acct.opened_orders()\n    for it in od.items:  # items: list[OpenedOrder]\n        print(\n            f\"#{it.ticket} {it.symbol} {it.order_type} \"\n            f\"lots={it.lots:.2f} open={it.open_price:.5f} \"\n            f\"sl={it.stop_loss or 0:.5f} tp={it.take_profit or 0:.5f} \"\n            f\"profit={it.profit:.2f}\"\n        )\n\n# Low-level: raw proto payload\nod = await acct.opened_orders()\n# od: OpenedOrdersData\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#method-signature","title":"Method Signature","text":"<pre><code>async def opened_orders(\n    self,\n    sort_mode: account_helper_pb2.EnumOpenedOrderSortType = account_helper_pb2.EnumOpenedOrderSortType.SORT_BY_OPEN_TIME_ASC,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; account_helper_pb2.OpenedOrdersData\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A single RPC returning all active positions for the current account, already sorted server\u2011side.</li> <li>Why. UI/CLI listings, risk monitoring, quick portfolio P/L calculations.</li> <li>Sorting. Controlled by <code>sort_mode</code> (see enum below).</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>sort_mode</code> <code>EnumOpenedOrderSortType</code> Sorting mode to apply on the server. <code>deadline</code> <code>datetime                 | None</code> Absolute per\u2011call deadline (converted to timeout). <code>cancellation_event</code> <code>asyncio.Event            | None</code> Cooperative cancel for the retry wrapper. <p>Note: The SDK builds <code>OpenedOrdersRequest(sort_type=sort_mode)</code> and executes via <code>execute_with_reconnect(...)</code>.</p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Orders_Positions_History/opened_orders/#payload-openedordersdata","title":"Payload: <code>OpenedOrdersData</code>","text":"Field Type Description <code>order_infos</code> <code>OpenedOrderInfo[]</code> Array of currently opened orders and positions. <p>Each <code>OpenedOrderInfo</code> element contains:</p> Field Proto Type Description <code>ticket</code> <code>int32</code> Unique ID of the order/position. <code>symbol</code> <code>string</code> Symbol (e.g., <code>EURUSD</code>). <code>order_type</code> <code>enum OpenedOrderType</code> Order type (BUY/SELL/LIMIT/STOP, etc.). <code>lots</code> <code>double</code> Volume in lots. <code>magic_number</code> <code>int32</code> EA magic number. <code>open_price</code> <code>double</code> Entry price. <code>profit</code> <code>double</code> Current floating P/L. <code>stop_loss</code> <code>double</code> Current SL (0 if none). <code>take_profit</code> <code>double</code> Current TP (0 if none). <code>swap</code> <code>double</code> Accumulated swap. <code>commision</code> <code>double</code> Commission charged. <code>comment</code> <code>string</code> Order comment. <code>position_index</code> <code>int32</code> Terminal position index (if applicable). <code>open_time</code> <code>google.protobuf.Timestamp</code> Position open time (UTC). <code>expiration_time</code> <code>google.protobuf.Timestamp</code> Pending order expiration (if set). <code>sort_index</code> <code>int32</code> Sort index for the current sort mode. <code>account_login</code> <code>int64</code> Account login number."},{"location":"MT4Account/Orders_Positions_History/opened_orders/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Orders_Positions_History/opened_orders/#enumopenedordersorttype","title":"<code>EnumOpenedOrderSortType</code>","text":"<p>Sort modes for opened orders:</p> <ul> <li><code>SORT_BY_OPEN_TIME_ASC = 0</code> \u2014 Sort by open time ascending</li> <li><code>SORT_BY_OPEN_TIME_DESC = 1</code> \u2014 Sort by open time descending</li> <li><code>SORT_BY_ORDER_TICKET_ID_ASC = 2</code> \u2014 Sort by ticket ID ascending</li> <li><code>SORT_BY_ORDER_TICKET_ID_DESC = 3</code> \u2014 Sort by ticket ID descending</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#openedordertype","title":"<code>OpenedOrderType</code>","text":"<p>Order/position types:</p> <ul> <li><code>OO_OP_BUY = 0</code> \u2014 Market buy position</li> <li><code>OO_OP_SELL = 1</code> \u2014 Market sell position</li> <li><code>OO_OP_BUYLIMIT = 3</code> \u2014 Buy limit pending order</li> <li><code>OO_OP_BUYSTOP = 4</code> \u2014 Buy stop pending order</li> <li><code>OO_OP_SELLLIMIT = 5</code> \u2014 Sell limit pending order</li> <li><code>OO_OP_SELLSTOP = 6</code> \u2014 Sell stop pending order</li> </ul> <p>Use <code>account_helper_pb2.EnumOpenedOrderSortType.Name(value)</code> or <code>OpenedOrderType.Name(value)</code> to map numeric values \u2192 labels.</p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Render real\u2011time position tables in your UI/CLI.</li> <li>Monitor risk and PnL across the portfolio.</li> <li>Filter/sort by ticket, symbol, or open time without client\u2011side re\u2011sorting.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Uses <code>execute_with_reconnect(...)</code> \u2192 automatic retry on transient gRPC errors.</li> <li>Prefer a short timeout (3\u20135s) with retries for large books.</li> <li>Right after connect, allow a brief warm\u2011up while the terminal syncs positions.</li> </ul> <p>See also:</p> <ul> <li><code>OpenedOrdersTickets(...)</code> \u2014 tickets only.</li> <li><code>on_opened_orders_tickets(...)</code> \u2014 streaming ticket updates.</li> <li><code>on_opened_orders_profit(...)</code> \u2014 streaming aggregated P/L.</li> <li><code>orders_history(...)</code> \u2014 closed orders.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Orders_Positions_History/opened_orders/#1-basic-list","title":"1) Basic list","text":"<pre><code>od = await acct.opened_orders()\nfor it in od.order_infos:\n    print(f\"#{it.ticket} {it.symbol} lots={it.lots:.2f} PnL={it.profit:.2f}\")\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#2-sort-by-ticket-descending","title":"2) Sort by ticket (descending)","text":"<pre><code>from MetaRpcMT4 import mt4_term_api_account_helper_pb2 as account_pb2\n\nod = await acct.opened_orders(\n    sort_mode=account_pb2.EnumOpenedOrderSortType.SORT_BY_ORDER_TICKET_ID_DESC\n)\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#3-deadline-cancellation","title":"3) Deadline + cancellation","text":"<pre><code>from datetime import datetime, timedelta, timezone\nimport asyncio\n\ncancel_event = asyncio.Event()\nod = await acct.opened_orders(\n    deadline=datetime.now(timezone.utc) + timedelta(seconds=3),\n    cancellation_event=cancel_event,\n)\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#4-viewmodel-for-ui","title":"4) View\u2011model for UI","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass OpenedOrderView:\n    ticket: int\n    symbol: str\n    order_type: int\n    lots: float\n    open_price: float\n    sl: float\n    tp: float\n    profit: float\n\n    @staticmethod\n    def from_proto(p):\n        return OpenedOrderView(\n            ticket=int(p.ticket),\n            symbol=str(p.symbol),\n            order_type=int(p.order_type),\n            lots=float(p.lots),\n            open_price=float(p.open_price),\n            sl=float(getattr(p, 'stop_loss', 0.0)),\n            tp=float(getattr(p, 'take_profit', 0.0)),\n            profit=float(p.profit),\n        )\n\nod = await acct.opened_orders()\nrows = [OpenedOrderView.from_proto(p) for p in od.items]\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders/#what-this-teaches","title":"\ud83e\uddea What this teaches","text":"<ul> <li>How to retrieve all open positions efficiently.</li> <li>How to apply server\u2011side sorting via <code>sort_mode</code>.</li> <li>How to make safe, responsive RPC calls using <code>deadline</code> and <code>cancellation_event</code>.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/","title":"\u2705 Getting Opened Order Tickets","text":"<p>Request: retrieve the list of tickets for all currently opened orders/positions as a lightweight payload (<code>OpenedOrdersTicketsData</code>). Fastest way to enumerate active tickets without pulling full order details.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>opened_orders_tickets(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_account_helper_pb2.py</code> \u2014 <code>OpenedOrdersTickets*</code></li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.AccountHelper</code></li> <li>Method: <code>OpenedOrdersTickets(OpenedOrdersTicketsRequest) \u2192 OpenedOrdersTicketsReply</code></li> <li>Low\u2011level client: <code>AccountHelperStub.OpenedOrdersTickets(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.opened_orders_tickets(deadline=None, cancellation_event=None) \u2192 OpenedOrdersTicketsData</code></li> </ul> <p>Request message: <code>OpenedOrdersTicketsRequest {}</code> Reply message: <code>OpenedOrdersTicketsReply { data: OpenedOrdersTicketsData }</code></p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Fetch just the ticket IDs (fast, minimal payload)\nod = await acct.opened_orders_tickets()\nprint(list(od.tickets))  # [1234567, 1234568, ...]\n\n# Use the tickets to drive detail fetches (e.g., order_modify/close)\nfor ticket in od.tickets:\n    # your logic here (e.g., decide which tickets to close/modify)\n    pass\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#method-signature","title":"Method Signature","text":"<pre><code>async def opened_orders_tickets(\n    self,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; account_helper_pb2.OpenedOrdersTicketsData\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A minimal call that returns only the active ticket IDs.</li> <li>Why. Perfect for quick scans, batch operations, or streaming comparisons (<code>on_opened_orders_tickets</code>).</li> <li>When to prefer. Use this instead of <code>opened_orders()</code> when you only need identifiers, not full order data.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#input","title":"\ud83d\udd3d Input","text":"<p>No required parameters.</p> Parameter Type Description <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline \u2192 converted to timeout. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for the retry loop."},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#payload-openedordersticketsdata","title":"Payload: <code>OpenedOrdersTicketsData</code>","text":"Field Proto Type Description <code>tickets</code> <code>int32[]</code> List of ticket IDs for all open positions. <p>This message is intentionally minimal to keep the call fast and bandwidth\u2011light.</p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not define method\u2011specific enums. (No sort/filter in request.)</p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Drive bulk actions (close/modify) using ticket IDs.</li> <li>Implement cheap change\u2011detection by diffing the current ticket set against a cached set.</li> <li>Feed streaming consumers that subscribe to <code>on_opened_orders_tickets</code>.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Wrapper uses <code>execute_with_reconnect(...)</code> for transient gRPC retries.</li> <li>For ultra\u2011low latency loops, keep a short timeout (e.g., 2\u20133s) and backoff on failures.</li> <li>Combine with <code>opened_orders()</code> only when you actually need full details for the selected tickets.</li> </ul> <p>See also: <code>opened_orders(...)</code> \u2014 full order details. <code>on_opened_orders_tickets(...)</code> \u2014 stream ticket updates. <code>order_modify(...)</code>, <code>order_close_delete(...)</code>, <code>order_close_by(...)</code> \u2014 actions by ticket.</p>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#1-basic-print","title":"1) Basic print","text":"<pre><code>od = await acct.opened_orders_tickets()\nprint(f\"Active tickets: {len(od.tickets)} \u2192 {list(od.tickets)[:10]}\")\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#2-check-if-a-specific-ticket-is-still-open","title":"2) Check if a specific ticket is still open","text":"<pre><code>od = await acct.opened_orders_tickets()\nif 1234567 in od.tickets:\n    print(\"Ticket 1234567 is still active\")\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#3-diff-against-a-cached-set","title":"3) Diff against a cached set","text":"<pre><code>prev = {111, 222, 333}\ncur = set(await acct.opened_orders_tickets()).tickets  # or set(od.tickets)\nopened_now = cur - prev\nclosed_now = prev - cur\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/opened_orders_tickets/#4-bulkclose-by-rule","title":"4) Bulk\u2011close by rule","text":"<pre><code>from MetaRpcMT4 import mt4_term_api_trading_helper_pb2 as trade_pb2\n\nod = await acct.opened_orders_tickets()\nfor t in od.tickets:\n    # Example: close all tickets (WARNING: this is just a sketch!)\n    # await acct.order_close_delete(order_ticket=t)\n    pass\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/orders_history/","title":"\u2705 Getting Orders History","text":"<p>Request: retrieve closed orders/positions history as a structured payload (<code>OrdersHistoryData</code>) with optional time range, sorting, and pagination. Use this to build PnL reports, trade logs, and analytics.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>orders_history(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_account_helper_pb2.py</code> \u2014 <code>OrdersHistory*</code>, <code>EnumOrderHistorySortType</code>, <code>OpenedOrderType</code></li> </ul>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.AccountHelper</code></li> <li>Method: <code>OrdersHistory(OrdersHistoryRequest) \u2192 OrdersHistoryReply</code></li> <li>Low\u2011level client: <code>AccountHelperStub.OrdersHistory(request, metadata, timeout)</code></li> <li>SDK wrapper: <code>MT4Account.orders_history(sort_mode=EnumOrderHistorySortType.HISTORY_SORT_BY_CLOSE_TIME_DESC, from_time=None, to_time=None, page_number=None, items_per_page=None, deadline=None, cancellation_event=None) \u2192 OrdersHistoryData</code></li> </ul> <p>Request message: <code>OrdersHistoryRequest { input_sort_mode, input_from?, input_to?, page_number?, items_per_page? }</code> Reply message: <code>OrdersHistoryReply { data: OrdersHistoryData }</code></p>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code>from datetime import datetime, timedelta, timezone\n\n# Last 7 days, newest first\nend = datetime.now(timezone.utc)\nstart = end - timedelta(days=7)\n\nhist = await acct.orders_history(\n    from_time=start,\n    to_time=end,\n)\n\n# Print compact ledger\nfor it in hist.orders_info:  # list[HistoryOrderInfo]\n    print(\n        f\"#{it.ticket} {it.symbol} {it.order_type} lots={it.lots:.2f} \"\n        f\"open={it.open_price:.5f} \u2192 close={it.close_price:.5f} \"\n        f\"PnL={it.profit:.2f} swap={it.swap:.2f}\"\n    )\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#method-signature","title":"Method Signature","text":"<pre><code>async def orders_history(\n    self,\n    sort_mode: account_helper_pb2.EnumOrderHistorySortType = account_helper_pb2.EnumOrderHistorySortType.HISTORY_SORT_BY_CLOSE_TIME_DESC,\n    from_time: datetime | None = None,\n    to_time: datetime | None = None,\n    page_number: int | None = None,\n    items_per_page: int | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; account_helper_pb2.OrdersHistoryData\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A paginable, server\u2011sorted list of closed orders/positions in the requested time window.</li> <li>Why. Perfect for statements, audits, tax exports, and performance analytics.</li> <li>Sorting. Controlled by <code>sort_mode</code> (see enum below). Defaults to most\u2011recent by close time.</li> <li>Windowing. Provide <code>from_time</code> / <code>to_time</code> (UTC <code>datetime</code>) to bound the query; both optional.</li> <li>Pagination. Use <code>page_number</code> + <code>items_per_page</code> to iterate large histories deterministically.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>sort_mode</code> <code>EnumOrderHistorySortType</code> Server\u2011side sorting mode. <code>from_time</code> <code>datetime                  | None</code> Start of time range (UTC). <code>to_time</code> <code>datetime                  | None</code> End of time range (UTC). <code>page_number</code> <code>int                       | None</code> 1\u2011based page index. <code>items_per_page</code> <code>int                       | None</code> Page size (be reasonable to avoid large payloads). <code>deadline</code> <code>datetime                  | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event             | None</code> Cooperative cancel for the retry wrapper. <p>The SDK builds <code>OrdersHistoryRequest(input_sort_mode=..., input_from=..., input_to=..., page_number=..., items_per_page=...)</code> and executes via <code>execute_with_reconnect(...)</code>.</p>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Orders_Positions_History/orders_history/#payload-ordershistorydata","title":"Payload: <code>OrdersHistoryData</code>","text":"Field Type Description <code>orders_info</code> <code>HistoryOrderInfo[]</code> Array of historical orders and positions. <code>total_count</code> <code>int32</code> Total number of records matching query (for pagination). <p>Each <code>HistoryOrderInfo</code> element contains:</p> Field Proto Type Description <code>ticket</code> <code>int32</code> Unique ID of the order/position. <code>symbol</code> <code>string</code> Trading symbol (e.g., <code>EURUSD</code>). <code>order_type</code> <code>enum OpenedOrderType</code> Order type (BUY/SELL/LIMIT/STOP, etc.). <code>lots</code> <code>double</code> Volume in lots. <code>magic_number</code> <code>int32</code> EA magic. <code>open_price</code> <code>double</code> Entry price. <code>close_price</code> <code>double</code> Exit price. <code>profit</code> <code>double</code> Realized P/L. <code>swap</code> <code>double</code> Swap charged/credited. <code>stop_loss</code> <code>double</code> SL at the time of close (if reported). <code>take_profit</code> <code>double</code> TP at the time of close (if reported). <code>position_index</code> <code>int32</code> Terminal position index (if applicable). <code>sort_index</code> <code>int32</code> Index for sorting results. <code>open_time</code> <code>google.protobuf.Timestamp</code> Position open time (UTC). <code>close_time</code> <code>google.protobuf.Timestamp</code> Position close time (UTC). <code>expiration_time</code> <code>google.protobuf.Timestamp</code> Expiration time for pending orders (if set). <code>comment</code> <code>string</code> User/system comment (if any). <code>commision</code> <code>double</code> Commission (spelled as in pb: <code>commision</code>). <code>account_login</code> <code>int64</code> Useful in multi\u2011account contexts. <p>Note the <code>commision</code> spelling mirrors the protobuf field name.</p>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Orders_Positions_History/orders_history/#enumorderhistorysorttype","title":"<code>EnumOrderHistorySortType</code>","text":"<ul> <li><code>HISTORY_SORT_BY_OPEN_TIME_ASC = 0</code> \u2014 Sort by open time ascending</li> <li><code>HISTORY_SORT_BY_OPEN_TIME_DESC = 1</code> \u2014 Sort by open time descending</li> <li><code>HISTORY_SORT_BY_CLOSE_TIME_ASC = 2</code> \u2014 Sort by close time ascending</li> <li><code>HISTORY_SORT_BY_CLOSE_TIME_DESC = 3</code> \u2014 Sort by close time descending</li> <li><code>HISTORY_SORT_BY_ORDER_TICKET_ID_ASC = 4</code> \u2014 Sort by ticket ID ascending</li> <li><code>HISTORY_SORT_BY_ORDER_TICKET_ID_DESC = 5</code> \u2014 Sort by ticket ID descending</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#openedordertype","title":"<code>OpenedOrderType</code>","text":"<ul> <li><code>OO_OP_BUY = 0</code> \u2014 Market buy position</li> <li><code>OO_OP_SELL = 1</code> \u2014 Market sell position</li> <li><code>OO_OP_BUYLIMIT = 3</code> \u2014 Buy limit pending order</li> <li><code>OO_OP_BUYSTOP = 4</code> \u2014 Buy stop pending order</li> <li><code>OO_OP_SELLLIMIT = 5</code> \u2014 Sell limit pending order</li> <li><code>OO_OP_SELLSTOP = 6</code> \u2014 Sell stop pending order</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Build statements and realized PnL reports.</li> <li>Export trade logs for accounting/taxation.</li> <li>Analyze performance by symbol, direction, holding time, etc.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Uses <code>execute_with_reconnect(...)</code> \u2192 automatic retry on transient gRPC errors.</li> <li>Prefer pagination for large histories; avoid massive single\u2011page pulls.</li> <li>Align your <code>from_time</code>/<code>to_time</code> with broker server time if needed; the reply also includes <code>open_time</code>/<code>close_time</code> in UTC.</li> </ul> <p>See also:</p> <ul> <li><code>opened_orders(...)</code> \u2014 current active positions.</li> <li><code>opened_orders_tickets(...)</code> \u2014 ticket IDs only.</li> <li>Trading actions: <code>order_close_delete(...)</code>, <code>order_close_by(...)</code>, <code>order_modify(...)</code>.</li> </ul>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Orders_Positions_History/orders_history/#1-last-month-newest-first","title":"1) Last month, newest first","text":"<pre><code>from datetime import datetime, timedelta, timezone\n\nend = datetime.now(timezone.utc)\nstart = end - timedelta(days=30)\n\nhist = await acct.orders_history(from_time=start, to_time=end)\nprint(f\"Closed trades: {len(hist.orders_info)}\")\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#2-paginate-through-large-history","title":"2) Paginate through large history","text":"<pre><code>page = 1\npage_size = 200\nall_rows = []\nwhile True:\n    h = await acct.orders_history(page_number=page, items_per_page=page_size)\n    all_rows.extend(h.orders_info)\n    if len(h.orders_info) &lt; page_size:\n        break\n    page += 1\n</code></pre>"},{"location":"MT4Account/Orders_Positions_History/orders_history/#3-aggregate-realized-pnl-by-symbol","title":"3) Aggregate realized PnL by symbol","text":"<pre><code>from collections import defaultdict\npnl = defaultdict(float)\nfor it in (await acct.orders_history()).orders_info:\n    pnl[it.symbol] += it.profit\nprint(sorted(pnl.items(), key=lambda kv: kv[1], reverse=True)[:10])\n</code></pre>"},{"location":"MT4Account/Streams/Streams_Overview/","title":"MT4Account \u00b7 Streams \u2014 Overview","text":"<p>Real\u2011time APIs for live ticks and trade state. Use this page to pick the right stream fast; links jump to detailed specs.</p>"},{"location":"MT4Account/Streams/Streams_Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>on_symbol_tick \u2014 server-stream of real-time ticks for one or more symbols (bid/ask/last, timestamp).</li> <li>on_trade \u2014 unified stream of trade events (orders, deals, positions) for the current account.</li> <li>on_opened_orders_tickets \u2014 lightweight stream of the current ticket set (IDs only; detect opens/closes).</li> <li>on_opened_orders_profit \u2014 stream of order profit updates and account state.</li> </ul>"},{"location":"MT4Account/Streams/Streams_Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>on_symbol_tick \u2192 your price wire. Keeps tiles and signal logic fed without polling.</li> <li>on_trade \u2192 the trade newsfeed (opens, modifies, closes, fills, position updates).</li> <li>on_opened_orders_tickets \u2192 the change detector. Cheap way to know when set of tickets changed.</li> <li>on_opened_orders_profit \u2192 the KPI ticker. Live order profit updates and account state for dashboards and risk alerts.</li> </ul> <p>Rule of thumb: need prices \u2192 <code>on_symbol_tick</code>; need what changed in trading \u2192 <code>on_trade</code>; need to refresh only on structural changes \u2192 <code>on_opened_orders_tickets</code>; need running P/L and account info \u2192 <code>on_opened_orders_profit</code>.</p>"},{"location":"MT4Account/Streams/Streams_Overview/#quick-choose","title":"Quick choose","text":"If you need\u2026 Use Yields Key inputs / notes Live ticks for symbols <code>on_symbol_tick</code> <code>OnSymbolTickData</code> <code>symbols: list[str]</code>, optional <code>cancellation_event</code> All trade events (orders/deals/positions) <code>on_trade</code> <code>OnTradeData</code> (mixed subtypes) optional <code>cancellation_event</code> Detect open/close via ticket set changes <code>on_opened_orders_tickets</code> <code>OnOpenedOrdersTicketsData</code> optional <code>cancellation_event</code> Live order profit and account state <code>on_opened_orders_profit</code> <code>OnOpenedOrdersProfitData</code> optional <code>cancellation_event</code>"},{"location":"MT4Account/Streams/Streams_Overview/#crossrefs-gotchas","title":"\u274c Cross\u2011refs &amp; gotchas","text":"<ul> <li>Reconnects happen. Wrappers use retry/reconnect under the hood; make handlers idempotent.</li> <li>Snapshots after reconnect. For UI consistency, pull <code>opened_orders()</code> and/or <code>orders_history()</code> once streams resume.</li> <li>Nested structures. All stream messages have nested data (e.g., <code>symbol_tick</code>, <code>event_data</code>, <code>account_info</code>).</li> <li>Keep symbol lists small in <code>on_symbol_tick</code> for latency; use <code>quote_many(...)</code> for bulk refills.</li> <li>Totals vs details. <code>on_opened_orders_profit</code> gives account info with profit; use <code>opened_orders()</code> when you need full order details.</li> </ul>"},{"location":"MT4Account/Streams/Streams_Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code># on_symbol_tick \u2014 debounce UI updates\nfrom time import monotonic\nlast_ui = 0\nDEBOUNCE = 0.25\nasync for t in acct.on_symbol_tick([\"EURUSD\", \"XAUUSD\"]):\n    now = monotonic()\n    if now - last_ui &gt;= DEBOUNCE:\n        last_ui = now\n        tick = t.symbol_tick\n        print(f\"{tick.symbol}: {tick.bid}/{tick.ask}\")\n</code></pre> <pre><code># on_trade \u2014 check for new orders\nasync for ev in acct.on_trade():\n    if ev.type == 1 and ev.event_data.new_orders:  # OrderUpdate with new orders\n        order = ev.event_data.new_orders\n        print(f\"New order: {order.symbol} ticket={order.ticket}\")\n    # Check account state\n    if ev.account_info:\n        print(f\"Balance: {ev.account_info.balance}, Equity: {ev.account_info.equity}\")\n</code></pre> <pre><code># on_opened_orders_tickets \u2014 diff and refresh details on change\nprev_positions = set()\nprev_pendings = set()\nasync for s in acct.on_opened_orders_tickets():\n    cur_pos = set(s.position_tickets)\n    cur_pend = set(s.pending_order_tickets)\n    if cur_pos != prev_positions or cur_pend != prev_pendings:\n        details = await acct.opened_orders()\n        # update UI list from details\n    prev_positions = cur_pos\n    prev_pendings = cur_pend\n</code></pre> <pre><code># on_opened_orders_profit \u2014 threshold alert\nTHRESH = -100.0\nasync for p in acct.on_opened_orders_profit():\n    if p.account_info and p.account_info.profit &lt;= THRESH:\n        # trigger alert / hedge action\n        print(f\"Alert! Profit: {p.account_info.profit}\")\n</code></pre>"},{"location":"MT4Account/Streams/Streams_Overview/#see-also","title":"See also","text":"<ul> <li>Snapshots: <code>opened_orders</code>, <code>orders_history</code></li> <li>Quotes &amp; symbols: <code>quote</code>, <code>quote_many</code>, <code>symbols</code></li> <li>Trading actions: <code>order_send</code>, <code>order_modify</code>, <code>order_close_delete</code>, <code>order_close_by</code></li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_profit/","title":"\u2705 Streaming Aggregated P/L","text":"<p>Stream: subscribe to real\u2011time aggregated profit/loss for the current set of opened orders/positions. Yields <code>OnOpenedOrdersProfitData</code> messages continuously until cancelled.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>on_opened_orders_profit(cancellation_event=None)</code></li> <li><code>MetaRpcMT4/mt4_term_api_subscriptions_pb2.py</code> \u2014 <code>OnOpenedOrdersProfit*</code> (request/reply/data)</li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.Subscriptions</code></li> <li>Method (server\u2011streaming): <code>OnOpenedOrdersProfit(OnOpenedOrdersProfitRequest) \u2192 stream OnOpenedOrdersProfitReply</code></li> <li>Low\u2011level client: <code>SubscriptionsStub.OnOpenedOrdersProfit(request, metadata)</code> (async stream)</li> <li>SDK wrapper: <code>MT4Account.on_opened_orders_profit(cancellation_event=None) \u2192 AsyncIterator[OnOpenedOrdersProfitData]</code></li> </ul> <p>Request message: <code>OnOpenedOrdersProfitRequest {}</code> Reply message: <code>OnOpenedOrdersProfitReply { data: OnOpenedOrdersProfitData }</code> (streamed)</p>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Consume aggregated P/L updates with graceful cancellation\nimport asyncio\n\nasync def watch_pnl(acct):\n    stop = asyncio.Event()\n    async for msg in acct.on_opened_orders_profit(cancellation_event=stop):\n        d = msg  # OnOpenedOrdersProfitData\n        total = getattr(d, 'total_profit', None)\n        by_sym = getattr(d, 'profit_by_symbol', None)  # map-like field in some builds\n        ts = getattr(d, 'date_time', None)\n        print(\"TOTAL PnL:\", total, \"at\", ts)\n        if by_sym:\n            # e.g., {\"EURUSD\": 12.34, \"XAUUSD\": -5.67}\n            print(\"By symbol:\", dict(by_sym))\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#method-signature","title":"Method Signature","text":"<pre><code>async def on_opened_orders_profit(\n    self,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; AsyncIterator[subscriptions_pb2.OnOpenedOrdersProfitData]\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A lightweight stream of totals: current aggregated floating P/L for all open positions.</li> <li>Why. Drive header KPIs, risk dashboards, and alerting without polling full order lists.</li> <li>Complement to tickets. Pair with <code>on_opened_orders_tickets(...)</code> to detect structural changes (opens/closes) while keeping a live P/L number.</li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#input","title":"\ud83d\udd3d Input","text":"<p>No request fields.</p> Parameter Type Description <code>cancellation_event</code> <code>asyncio.Event | None</code> Signal to stop the stream gracefully."},{"location":"MT4Account/Streams/on_opened_orders_profit/#output-streamed","title":"\u2b06\ufe0f Output (streamed)","text":""},{"location":"MT4Account/Streams/on_opened_orders_profit/#message-onopenedordersprofitdata","title":"Message: <code>OnOpenedOrdersProfitData</code>","text":"Field Proto Type Description <code>type</code> <code>enum</code> Event type (0 = OrderProfit, 1 = OrderUpdate). <code>opened_orders_with_profit_updated</code> <code>OnOpenedOrdersProfitOrderInfo</code> Order with updated profit information. <code>account_info</code> <code>OnEventAccountInfo</code> Account state snapshot (balance, equity, etc.). <code>terminal_instance_guid_id</code> <code>string</code> Terminal instance identifier."},{"location":"MT4Account/Streams/on_opened_orders_profit/#nested-onopenedordersprofitorderinfo","title":"Nested: <code>OnOpenedOrdersProfitOrderInfo</code>","text":"Field Proto Type Description <code>index</code> <code>int32</code> Order index. <code>ticket</code> <code>int32</code> Order/position ticket. <code>symbol</code> <code>string</code> Trading symbol. <code>type</code> <code>enum</code> Order type (SUB_OP_BUY, SUB_OP_SELL, etc.). <code>lots</code> <code>double</code> Volume in lots. <code>open_price</code> <code>double</code> Entry price. <code>stop_loss</code> <code>double</code> Stop loss level. <code>take_profit</code> <code>double</code> Take profit level. <code>open_time</code> <code>google.protobuf.Timestamp</code> Order open time (UTC). <code>expiration</code> <code>google.protobuf.Timestamp</code> Pending order expiration (if set). <code>magic_number</code> <code>int32</code> EA magic number. <code>order_profit</code> <code>double</code> Current/realized profit. <code>swap</code> <code>double</code> Swap charged/credited. <code>commission</code> <code>double</code> Commission. <code>comment</code> <code>string</code> Order comment."},{"location":"MT4Account/Streams/on_opened_orders_profit/#nested-oneventaccountinfo","title":"Nested: <code>OnEventAccountInfo</code>","text":"Field Proto Type Description <code>login</code> <code>int64</code> Account login number. <code>balance</code> <code>double</code> Account balance. <code>credit</code> <code>double</code> Credit amount. <code>equity</code> <code>double</code> Current equity. <code>margin</code> <code>double</code> Used margin. <code>free_margin</code> <code>double</code> Free margin available. <code>profit</code> <code>double</code> Total floating profit (use this for total P/L). <code>margin_level</code> <code>double</code> Margin level percentage. <p>Total profit/loss is available in <code>account_info.profit</code>. Individual order profit is in <code>opened_orders_with_profit_updated.order_profit</code>.</p>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This stream does not use method\u2011specific enums.</p>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this stream to:</p> <ul> <li>Show live P/L at the top of your UI.</li> <li>Trigger alerts (e.g., equity drawdown thresholds) without heavy polling.</li> <li>Recompute risk metrics on each update.</li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>The wrapper uses <code>execute_stream_with_reconnect(...)</code> and will retry on transient disconnects.</li> <li>Expect the first message to be the current aggregate (not a delta).</li> <li>Combine with snapshots after reconnect: <code>opened_orders()</code> to re\u2011sync details.</li> </ul> <p>See also: <code>on_opened_orders_tickets(...)</code> \u2014 set of open tickets. <code>opened_orders(...)</code> \u2014 detailed snapshot of positions. <code>account_summary(...)</code> \u2014 account\u2011level health (balance/equity/credit).</p>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Streams/on_opened_orders_profit/#1-simple-kpi-widget","title":"1) Simple KPI widget","text":"<pre><code>async for p in acct.on_opened_orders_profit():\n    total = getattr(p, 'total_profit', 0.0)\n    print(f\"Floating P/L: {total:+.2f}\")\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#2-alert-when-total-pl-crosses-threshold","title":"2) Alert when total P/L crosses threshold","text":"<pre><code>THRESH = -100.0\nasync for p in acct.on_opened_orders_profit():\n    if getattr(p, 'total_profit', 0.0) &lt;= THRESH:\n        # trigger your alert / hedge action\n        ...\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_profit/#3-merge-with-tickets-stream","title":"3) Merge with tickets stream","text":"<pre><code>import asyncio\n\nasync def run(acct):\n    tickets_cur = set()\n    pnl_cur = 0.0\n\n    async def t_stream():\n        nonlocal tickets_cur\n        async for s in acct.on_opened_orders_tickets():\n            tickets_cur = set(getattr(s, 'tickets', []))\n\n    async def p_stream():\n        nonlocal pnl_cur\n        async for p in acct.on_opened_orders_profit():\n            pnl_cur = getattr(p, 'total_profit', 0.0)\n\n    await asyncio.gather(t_stream(), p_stream())\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/","title":"\u2705 Streaming Opened Order Tickets","text":"<p>Stream: subscribe to real\u2011time updates of the set of opened order/position tickets. Yields <code>OnOpenedOrdersTicketsData</code> messages continuously until cancelled.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>on_opened_orders_tickets(cancellation_event=None)</code></li> <li><code>MetaRpcMT4/mt4_term_api_subscriptions_pb2.py</code> \u2014 <code>OnOpenedOrdersTickets*</code> (request/reply/data)</li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.Subscriptions</code></li> <li>Method (server\u2011streaming): <code>OnOpenedOrdersTickets(OnOpenedOrdersTicketsRequest) \u2192 stream OnOpenedOrdersTicketsReply</code></li> <li>Low\u2011level client: <code>SubscriptionsStub.OnOpenedOrdersTickets(request, metadata)</code> (async stream)</li> <li>SDK wrapper: <code>MT4Account.on_opened_orders_tickets(cancellation_event=None) \u2192 AsyncIterator[OnOpenedOrdersTicketsData]</code></li> </ul> <p>Request message: <code>OnOpenedOrdersTicketsRequest { pull_interval_ms?: int32 }</code> Reply message: <code>OnOpenedOrdersTicketsReply { data: OnOpenedOrdersTicketsData }</code> (streamed)</p> <p><code>pull_interval_ms</code> (if present in your pb) controls the server\u2011side polling cadence for generating ticket snapshots.</p>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Consume ticket-set updates and diff against previous\nimport asyncio\n\nasync def watch_tickets(acct):\n    stop = asyncio.Event()\n    prev = set()\n\n    async for msg in acct.on_opened_orders_tickets(cancellation_event=stop):\n        data = msg  # OnOpenedOrdersTicketsData\n        cur = set(getattr(data, 'tickets', []))\n        opened = cur - prev\n        closed = prev - cur\n        if opened:\n            print(\"Opened now:\", sorted(opened))\n        if closed:\n            print(\"Closed now:\", sorted(closed))\n        prev = cur\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#method-signature","title":"Method Signature","text":"<pre><code>async def on_opened_orders_tickets(\n    self,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; AsyncIterator[subscriptions_pb2.OnOpenedOrdersTicketsData]\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A lightweight stream that tells you when the ticket set changes (opens/closes) without sending full order details.</li> <li>Why. Trigger refreshes (e.g., refetch <code>opened_orders()</code>), drive notifications, or maintain a live set for risk logic.</li> <li>Efficient. Much cheaper than streaming full orders; perfect for UI badges and counters.</li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#input","title":"\ud83d\udd3d Input","text":"<p>No required parameters. (Some builds expose <code>pull_interval_ms</code>.)</p> Parameter Type Description <code>cancellation_event</code> <code>asyncio.Event | None</code> Signal to stop the stream gracefully."},{"location":"MT4Account/Streams/on_opened_orders_tickets/#output-streamed","title":"\u2b06\ufe0f Output (streamed)","text":""},{"location":"MT4Account/Streams/on_opened_orders_tickets/#message-onopenedordersticketsdata","title":"Message: <code>OnOpenedOrdersTicketsData</code>","text":"Field Proto Type Description <code>position_tickets</code> <code>int32[]</code> Array of current market position tickets. <code>pending_order_tickets</code> <code>int32[]</code> Array of current pending order tickets. <code>server_time</code> <code>google.protobuf.Timestamp</code> Server timestamp of this snapshot (UTC). <code>terminal_instance_guid_id</code> <code>string</code> Terminal instance identifier."},{"location":"MT4Account/Streams/on_opened_orders_tickets/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This stream does not use method\u2011specific enums.</p>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this stream to:</p> <ul> <li>Detect opens/closes instantly and refresh detail views lazily.</li> <li>Maintain a live set for quick membership checks before modify/close actions.</li> <li>Drive UI counters (e.g., number of open positions).</li> </ul>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>After reconnect, expect the full current set (not a delta). Diff against your cache.</li> <li>For full details (symbol, lots, P/L), call <code>opened_orders()</code> once a change is detected.</li> <li>Combine with <code>on_opened_orders_profit(...)</code> to update totals without pulling full lists.</li> </ul> <p>See also: <code>opened_orders_tickets(...)</code> \u2014 snapshot endpoint (single call). <code>opened_orders(...)</code> \u2014 full opened orders with details. <code>on_opened_orders_profit(...)</code> \u2014 stream aggregated P/L.</p>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Streams/on_opened_orders_tickets/#1-ui-badge-with-count","title":"1) UI badge with count","text":"<pre><code>async for s in acct.on_opened_orders_tickets():\n    count = len(getattr(s, 'tickets', []))\n    print(f\"Open positions: {count}\")\n</code></pre>"},{"location":"MT4Account/Streams/on_opened_orders_tickets/#2-trigger-snapshot-refresh-on-change","title":"2) Trigger snapshot refresh on change","text":"<pre><code>prev = set()\nasync for s in acct.on_opened_orders_tickets():\n    cur = set(getattr(s, 'tickets', []))\n    if cur != prev:\n        details = await acct.opened_orders()\n        # update UI list\n    prev = cur\n</code></pre>"},{"location":"MT4Account/Streams/on_symbol_tick/","title":"\u2705 Streaming Ticks","text":"<p>Stream: subscribe to real\u2011time ticks for one or more symbols. Yields <code>OnSymbolTickData</code> messages continuously until cancelled.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>on_symbol_tick(symbols, cancellation_event=None)</code></li> <li><code>MetaRpcMT4/mt4_term_api_subscriptions_pb2.py</code> \u2014 <code>OnSymbolTick*</code> (request/reply/data)</li> </ul>"},{"location":"MT4Account/Streams/on_symbol_tick/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.Subscriptions</code></li> <li>Method (server\u2011streaming): <code>OnSymbolTick(OnSymbolTickRequest) \u2192 stream OnSymbolTickReply</code></li> <li>Low\u2011level client: <code>SubscriptionsStub.OnSymbolTick(request, metadata)</code> (async stream)</li> <li>SDK wrapper: <code>MT4Account.on_symbol_tick(symbols: list[str], cancellation_event=None) \u2192 AsyncIterator[OnSymbolTickData]</code></li> </ul> <p>Request message: <code>OnSymbolTickRequest { symbol_names: string[] }</code> Reply message: <code>OnSymbolTickReply { data: OnSymbolTickData }</code> (streamed)</p>"},{"location":"MT4Account/Streams/on_symbol_tick/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Consume tick stream with graceful cancellation\nimport asyncio\n\nasync def consume_ticks(acct, symbols):\n    cancel = asyncio.Event()\n\n    async def stopper():\n        await asyncio.sleep(10)   # demo: stop after 10s\n        cancel.set()\n\n    asyncio.create_task(stopper())\n\n    async for msg in acct.on_symbol_tick(symbols, cancellation_event=cancel):\n        tick = msg.symbol_tick  # OnSymbolMqlTickInfo\n        print(f\"{tick.symbol}: bid={tick.bid}, ask={tick.ask}, last={tick.last}, time={tick.time}\")\n</code></pre>"},{"location":"MT4Account/Streams/on_symbol_tick/#method-signature","title":"Method Signature","text":"<pre><code>async def on_symbol_tick(\n    self,\n    symbols: list[str],\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; AsyncIterator[subscriptions_pb2.OnSymbolTickData]\n</code></pre>"},{"location":"MT4Account/Streams/on_symbol_tick/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A server\u2011stream of ticks for the requested symbols.</li> <li>Why. Drive live price tiles, trigger signal logic, or maintain in\u2011memory quote caches.</li> <li>Stop policy. Provide <code>cancellation_event</code> to terminate cooperatively; the wrapper handles reconnects.</li> </ul>"},{"location":"MT4Account/Streams/on_symbol_tick/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbols</code> <code>list[str]</code> Symbols to subscribe to. <code>cancellation_event</code> <code>asyncio.Event | None</code> Signal to stop the stream gracefully."},{"location":"MT4Account/Streams/on_symbol_tick/#output-streamed","title":"\u2b06\ufe0f Output (streamed)","text":""},{"location":"MT4Account/Streams/on_symbol_tick/#message-onsymboltickdata","title":"Message: <code>OnSymbolTickData</code>","text":"Field Proto Type Description <code>symbol_tick</code> <code>OnSymbolMqlTickInfo</code> Tick information for the symbol. <code>terminal_instance_guid_id</code> <code>string</code> Terminal instance identifier."},{"location":"MT4Account/Streams/on_symbol_tick/#nested-onsymbolmqltickinfo","title":"Nested: <code>OnSymbolMqlTickInfo</code>","text":"Field Proto Type Description <code>symbol</code> <code>string</code> Symbol name. <code>time</code> <code>google.protobuf.Timestamp</code> Tick server timestamp (UTC). <code>bid</code> <code>double</code> Best bid price. <code>ask</code> <code>double</code> Best ask price. <code>last</code> <code>double</code> Last traded price (if broker supplies). <code>volume</code> <code>uint64</code> Volume for the tick. <code>time_msc</code> <code>int64</code> Tick timestamp in milliseconds."},{"location":"MT4Account/Streams/on_symbol_tick/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This stream does not use method\u2011specific enums.</p>"},{"location":"MT4Account/Streams/on_symbol_tick/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this stream to:</p> <ul> <li>Keep real\u2011time UI tiles in sync.</li> <li>Update in\u2011memory caches backing <code>quote(...)</code> fallbacks.</li> <li>Fire signals (cross/threshold rules) without polling.</li> </ul>"},{"location":"MT4Account/Streams/on_symbol_tick/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>The wrapper calls <code>execute_stream_with_reconnect(...)</code> \u2192 it will retry on transient network errors.</li> <li>Keep the symbol list compact for low latency; use <code>quote_many(...)</code> for snapshot refills.</li> <li>When back\u2011pressure grows, consider sampling or debouncing on the client side.</li> </ul> <p>See also: <code>quote(...)</code> / <code>quote_many(...)</code> \u2014 on\u2011demand snapshots. <code>on_opened_orders_tickets(...)</code> \u2014 stream of position ticket changes. <code>on_opened_orders_profit(...)</code> \u2014 stream of aggregated P/L.</p>"},{"location":"MT4Account/Streams/on_symbol_tick/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Streams/on_symbol_tick/#1-debounced-ui-updates","title":"1) Debounced UI updates","text":"<pre><code>from time import monotonic\n\nlast_ui = 0\nDEBOUNCE = 0.25\nasync for t in acct.on_symbol_tick([\"EURUSD\",\"XAUUSD\"]):\n    now = monotonic()\n    if now - last_ui &gt;= DEBOUNCE:\n        last_ui = now\n        # push a UI snapshot assembled from latest tick per symbol\n</code></pre>"},{"location":"MT4Account/Streams/on_symbol_tick/#2-maintain-a-live-cache-for-midspread","title":"2) Maintain a live cache for mid/spread","text":"<pre><code>cache = {}\nasync for t in acct.on_symbol_tick([\"EURUSD\",\"GBPUSD\"]):\n    sym = getattr(t, 'symbol', getattr(t, 'symbolName', None))\n    bid = getattr(t, 'bid', None)\n    ask = getattr(t, 'ask', None)\n    if sym and bid and ask:\n        cache[sym] = {\"mid\": (bid+ask)/2, \"bid\": bid, \"ask\": ask}\n</code></pre>"},{"location":"MT4Account/Streams/on_symbol_tick/#3-cooperative-shutdown","title":"3) Cooperative shutdown","text":"<pre><code>stop = asyncio.Event()\nasyncio.get_event_loop().call_later(5.0, stop.set)\nasync for _ in acct.on_symbol_tick([\"USDJPY\"], cancellation_event=stop):\n    pass\n</code></pre>"},{"location":"MT4Account/Streams/on_trade/","title":"\u2705 Streaming Trade Events","text":"<p>Stream: subscribe to all trade\u2011related events (orders, deals, positions) for the current account. Yields <code>OnTradeData</code> messages continuously until cancelled.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>on_trade(cancellation_event=None)</code></li> <li><code>MetaRpcMT4/mt4_term_api_subscriptions_pb2.py</code> \u2014 <code>OnTrade*</code> (request/reply/data), enums</li> </ul>"},{"location":"MT4Account/Streams/on_trade/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.Subscriptions</code></li> <li>Method (server\u2011streaming): <code>OnTrade(OnTradeRequest) \u2192 stream OnTradeReply</code></li> <li>Low\u2011level client: <code>SubscriptionsStub.OnTrade(request, metadata)</code> (async stream)</li> <li>SDK wrapper: <code>MT4Account.on_trade(cancellation_event=None) \u2192 AsyncIterator[OnTradeData]</code></li> </ul> <p>Request message: <code>OnTradeRequest {}</code> Reply message: <code>OnTradeReply { data: OnTradeData }</code> (streamed)</p>"},{"location":"MT4Account/Streams/on_trade/#code-example","title":"\ud83d\udd17 Code Example","text":"<pre><code># Consume trade events and route by subtype\nimport asyncio\n\nasync def consume_trades(acct):\n    stop = asyncio.Event()\n    # example: stop after some time\n    # asyncio.get_event_loop().call_later(15.0, stop.set)\n\n    async for ev in acct.on_trade(cancellation_event=stop):\n        # OnTradeData may wrap one of: order/deal/position/update blocks\n        # Common fields (presence depends on subtype):\n        acc  = getattr(ev, 'account_login', None)\n        kind = getattr(ev, 'type', None)  # SUB_ORDER_OPERATION_TYPE enum value\n\n        # Order info\n        if hasattr(ev, 'order_ticket') or hasattr(ev, 'open_price'):\n            sym = getattr(ev, 'symbol', None)\n            ticket = getattr(ev, 'order_ticket', None)\n            lots = getattr(ev, 'lots', None)\n            print(f\"ORDER event: {sym} ticket={ticket} lots={lots}\")\n            continue\n\n        # Deal info (execution)\n        if hasattr(ev, 'deal_ticket') or hasattr(ev, 'price'):\n            sym = getattr(ev, 'symbol', None)\n            price = getattr(ev, 'price', None)\n            pnl = getattr(ev, 'order_profit', None)\n            print(f\"DEAL event: {sym} price={price} pnl={pnl}\")\n            continue\n\n        # Position info (aggregation)\n        if hasattr(ev, 'position_id'):\n            sym = getattr(ev, 'symbol', None)\n            swap = getattr(ev, 'swap', None)\n            print(f\"POSITION event: {sym} swap={swap}\")\n</code></pre>"},{"location":"MT4Account/Streams/on_trade/#method-signature","title":"Method Signature","text":"<pre><code>async def on_trade(\n    self,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; AsyncIterator[subscriptions_pb2.OnTradeData]\n</code></pre>"},{"location":"MT4Account/Streams/on_trade/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A unified trade event stream: order placement/modification/close, executions (deals), and position updates.</li> <li>Why. Drive UI notifications, audit logs, position widgets, and reactive risk management.</li> <li>Stop policy. Pass <code>cancellation_event</code> to terminate cooperatively; the wrapper auto\u2011reconnects on transient errors.</li> </ul>"},{"location":"MT4Account/Streams/on_trade/#input","title":"\ud83d\udd3d Input","text":"<p>No request fields (server subscribes for the current account).</p> Parameter Type Description <code>cancellation_event</code> <code>asyncio.Event | None</code> Signal to stop the stream gracefully"},{"location":"MT4Account/Streams/on_trade/#output-streamed","title":"\u2b06\ufe0f Output (streamed)","text":""},{"location":"MT4Account/Streams/on_trade/#message-ontradedata","title":"Message: <code>OnTradeData</code>","text":"Field Proto Type Description <code>type</code> <code>enum</code> Event type (0 = OrderProfit, 1 = OrderUpdate). <code>event_data</code> <code>OnTadeEventData</code> Trade event details (orders, updates, removals). <code>account_info</code> <code>OnEventAccountInfo</code> Account state snapshot (balance, equity, etc.). <code>terminal_instance_guid_id</code> <code>string</code> Terminal instance identifier."},{"location":"MT4Account/Streams/on_trade/#nested-ontadeeventdata","title":"Nested: <code>OnTadeEventData</code>","text":"Field Type Description <code>new_orders</code> <code>OnTradeOrderInfo</code> Newly created orders/positions. <code>updated_orders</code> <code>OnTradeUpdatedOrderInfo</code> Modified orders (previous/current). <code>removed_orders</code> <code>OnTradeOrderInfo</code> Closed/deleted orders. <code>new_history_orders</code> <code>OnTradeOrderInfo</code> New historical orders."},{"location":"MT4Account/Streams/on_trade/#nested-ontradeorderinfo","title":"Nested: <code>OnTradeOrderInfo</code>","text":"Field Proto Type Description <code>index</code> <code>int32</code> Order index. <code>ticket</code> <code>int32</code> Order/position ticket. <code>is_history</code> <code>bool</code> True if historical order. <code>symbol</code> <code>string</code> Trading symbol. <code>type</code> <code>enum</code> Order type (SUB_OP_BUY, SUB_OP_SELL, etc.). <code>lots</code> <code>double</code> Volume in lots. <code>open_price</code> <code>double</code> Entry price. <code>close_price</code> <code>double</code> Exit price (if closed). <code>stop_loss</code> <code>double</code> Stop loss level. <code>take_profit</code> <code>double</code> Take profit level. <code>open_time</code> <code>google.protobuf.Timestamp</code> Order open time (UTC). <code>close_time</code> <code>google.protobuf.Timestamp</code> Order close time (UTC, if closed). <code>expiration</code> <code>google.protobuf.Timestamp</code> Pending order expiration (if set). <code>magic_number</code> <code>int32</code> EA magic number. <code>order_profit</code> <code>double</code> Current/realized profit. <code>swap</code> <code>double</code> Swap charged/credited. <code>commission</code> <code>double</code> Commission. <code>comment</code> <code>string</code> Order comment. <code>account_login</code> <code>int64</code> Account login number."},{"location":"MT4Account/Streams/on_trade/#nested-ontradeupdatedorderinfo","title":"Nested: <code>OnTradeUpdatedOrderInfo</code>","text":"Field Type Description <code>previous</code> <code>OnTradeOrderInfo</code> Order state before update. <code>current</code> <code>OnTradeOrderInfo</code> Order state after update."},{"location":"MT4Account/Streams/on_trade/#nested-oneventaccountinfo","title":"Nested: <code>OnEventAccountInfo</code>","text":"Field Proto Type Description <code>login</code> <code>int64</code> Account login number. <code>balance</code> <code>double</code> Account balance. <code>credit</code> <code>double</code> Credit amount. <code>equity</code> <code>double</code> Current equity. <code>margin</code> <code>double</code> Used margin. <code>free_margin</code> <code>double</code> Free margin available. <code>profit</code> <code>double</code> Total floating profit. <code>margin_level</code> <code>double</code> Margin level percentage. <p>The SDK yields <code>reply.data</code> directly as <code>OnTradeData</code> with nested structures for different event types.</p>"},{"location":"MT4Account/Streams/on_trade/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Streams/on_trade/#order-type-in-ontradeorderinfotype","title":"Order Type (in <code>OnTradeOrderInfo.type</code>)","text":"<ul> <li><code>SUB_OP_BUY = 0</code> \u2014 Market buy position</li> <li><code>SUB_OP_SELL = 1</code> \u2014 Market sell position</li> <li><code>SUB_OP_BUYLIMIT = 2</code> \u2014 Buy limit pending order</li> <li><code>SUB_OP_SELLLIMIT = 3</code> \u2014 Sell limit pending order</li> <li><code>SUB_OP_BUYSTOP = 4</code> \u2014 Buy stop pending order</li> <li><code>SUB_OP_SELLSTOP = 5</code> \u2014 Sell stop pending order</li> </ul>"},{"location":"MT4Account/Streams/on_trade/#event-type-in-ontradedatatype","title":"Event Type (in <code>OnTradeData.type</code>)","text":"<ul> <li><code>OrderProfit = 0</code> \u2014 Profit/account state update</li> <li><code>OrderUpdate = 1</code> \u2014 Order state change (new/updated/removed orders)</li> </ul>"},{"location":"MT4Account/Streams/on_trade/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this stream to:</p> <ul> <li>Update positions and orders in real time without polling.</li> <li>Build audit trails and notify the user of fills/modifies/closes.</li> <li>Trigger risk controls on specific event types.</li> </ul>"},{"location":"MT4Account/Streams/on_trade/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Keep handlers idempotent \u2014 reconnections may resend the last event.</li> <li>If you only need price ticks, prefer <code>on_symbol_tick(...)</code>.</li> <li>For bulk state refresh after reconnect, combine with snapshots: <code>opened_orders(...)</code>, <code>orders_history(...)</code>.</li> </ul> <p>See also: <code>on_opened_orders_tickets(...)</code> \u2014 stream of ticket set changes. <code>on_opened_orders_profit(...)</code> \u2014 stream of aggregated P/L updates. <code>opened_orders(...)</code>, <code>orders_history(...)</code> \u2014 snapshot endpoints.</p>"},{"location":"MT4Account/Streams/on_trade/#usage-examples","title":"Usage Examples","text":""},{"location":"MT4Account/Streams/on_trade/#1-route-by-operation-type","title":"1) Route by operation type","text":"<pre><code>from MetaRpcMT4 import mt4_term_api_subscriptions_pb2 as sub_pb\n\nasync for ev in acct.on_trade():\n    op = getattr(ev, 'type', None)\n    if op is None:\n        continue\n    name = sub_pb.SUB_ORDER_OPERATION_TYPE.Name(op)\n    if name.startswith('OP_OPEN'):\n        ...  # created\n    elif name.startswith('OP_MODIFY'):\n        ...  # modified\n    elif name.startswith('OP_CLOSE'):\n        ...  # closed\n</code></pre>"},{"location":"MT4Account/Streams/on_trade/#2-reconcile-with-snapshots-after-reconnect","title":"2) Reconcile with snapshots after reconnect","text":"<pre><code># After stream resumes, pull fresh snapshots to resync UI\nod = await acct.opened_orders()\nhist = await acct.orders_history()\n</code></pre>"},{"location":"MT4Account/Trading_Actions/Trading_Actions_Overview/","title":"MT4Account \u00b7 Trading Actions \u2014 Overview","text":"<p>Entry / exit operations for live trading on MT4 accounts. Use this page to choose the correct action quickly.</p>"},{"location":"MT4Account/Trading_Actions/Trading_Actions_Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>order_send \u2014 place market or pending order (with optional SL/TP, expiration).</li> <li>order_modify \u2014 update SL/TP, pending price, and expiration.</li> <li>order_close_delete \u2014 close market position (full/partial) or delete pending order.</li> <li>order_close_by \u2014 close one hedge position by another opposite one (same symbol) \u2192 netting.</li> </ul>"},{"location":"MT4Account/Trading_Actions/Trading_Actions_Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>order_send \u2192 Enter the market or schedule a pending entry.</li> <li>order_modify \u2192 Adjust protection or re-price pending order.</li> <li>order_close_delete \u2192 Exit or cancel waiting order.</li> <li>order_close_by \u2192 Fast de-hedge: match BUY vs SELL to reduce costs.</li> </ul> <p>Rule of thumb: \u2705 You want to enter \u2192 <code>order_send()</code> \u2705 You want to exit or cancel \u2192 <code>order_close_delete()</code> \u2705 You want to tweak SL/TP or pending \u2192 <code>order_modify()</code> \u2705 Hedge account and you want clean netting \u2192 <code>order_close_by()</code></p>"},{"location":"MT4Account/Trading_Actions/Trading_Actions_Overview/#quick-choose","title":"Quick choose","text":"If you need\u2026 Use Works on Key inputs Safety notes Market entry or pending order <code>order_send</code> BUY / SELL / LIMIT / STOP symbol, op_type, volume, SL/TP Check StopsLevel / FreezeLevel Update SL/TP / pending price / expiration <code>order_modify</code> Market or pending ticket, new_sl/tp, new_price Only pendings accept new_price Close position or delete pending <code>order_close_delete</code> Market or pending ticket, lots?, slippage? Respect volume step; slippage only for market Close one hedge position by another <code>order_close_by</code> Hedge accounts only two tickets Same symbol, opposite side only"},{"location":"MT4Account/Trading_Actions/Trading_Actions_Overview/#cross-refs-gotchas","title":"\u274c Cross-refs &amp; Gotchas","text":"<ul> <li>Volume rules: snap to <code>VolumeMin/Max/Step</code> (<code>symbol_params_many</code>)</li> <li>Protection distance: <code>StopsLevel</code> + <code>FreezeLevel</code> must be respected</li> <li>Expiration only applies to pending orders</li> <li>Partial close only through <code>order_close_delete</code></li> <li>Close By not available on netting accounts</li> <li>On retry (reconnect) events may duplicate \u2014 keep UI actions idempotent</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_by/","title":"\u2705 Close by Opposite Position","text":"<p>Request: close one open position using an opposite position on the same symbol (MT4 Close By operation). This reduces commissions/swaps vs two separate closes and can net residual volume automatically.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>order_close_by(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_trading_helper_pb2.py</code> \u2014 <code>OrderCloseBy*</code> messages (request/reply/data)</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_by/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.TradingHelper</code></li> <li>Method: <code>OrderCloseBy(OrderCloseByRequest) \u2192 OrderCloseByReply</code></li> <li>Low\u2011level client: <code>TradingHelperStub.OrderCloseBy(request, metadata, timeout)</code></li> <li>SDK wrapper:</li> </ul> <pre><code>MT4Account.order_close_by(\n    ticket_to_close: int,\n    opposite_ticket_closing_by: int,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderCloseByData\n</code></pre> <p>Request message: <code>OrderCloseByRequest { ticket_to_close, opposite_ticket_closing_by }</code> Reply message: <code>OrderCloseByReply { data: OrderCloseByData }</code></p>"},{"location":"MT4Account/Trading_Actions/order_close_by/#code-examples","title":"\ud83d\udd17 Code Examples","text":"<pre><code># 1) Close a BUY by an opposite SELL on the same symbol\nawait acct.order_close_by(\n    ticket_to_close=buy_ticket,\n    opposite_ticket_closing_by=sell_ticket,\n)\n\n# 2) After close-by, reconcile residuals (if volumes differed)\nod = await acct.opened_orders()\n# If one side had bigger lots, you'll still see a reduced position remaining\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_by/#method-signature","title":"Method Signature","text":"<pre><code>async def order_close_by(\n    self,\n    ticket_to_close: int,\n    opposite_ticket_closing_by: int,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderCloseByData\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_by/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. MT4 \"Close By\": match two opposite positions on the same symbol; broker nets them and closes both (or leaves a residual).</li> <li>Why. Save commissions/swaps vs closing both separately; perform clean netting operations on hedge accounts.</li> <li>Volumes. If volumes differ, the smaller is closed against the larger; the remainder stays open.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_by/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>ticket_to_close</code> <code>int</code> Ticket of the position you consider the primary close target. <code>opposite_ticket_closing_by</code> <code>int</code> Ticket of the opposite position used to close by. <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper. <p>The wrapper does not accept <code>lots</code>/<code>slippage</code> \u2014 the server nets the volumes directly according to MT4 rules.</p>"},{"location":"MT4Account/Trading_Actions/order_close_by/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Trading_Actions/order_close_by/#payload-orderclosebydata","title":"Payload: <code>OrderCloseByData</code>","text":"Field Proto Type Description <code>close_price</code> <code>double</code> Close price of the operation. <code>profit</code> <code>double</code> Profit/loss from the close-by operation. <code>close_time</code> <code>google.protobuf.Timestamp</code> Server timestamp of the operation."},{"location":"MT4Account/Trading_Actions/order_close_by/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not use method\u2011specific enums.</p>"},{"location":"MT4Account/Trading_Actions/order_close_by/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Net two hedge positions efficiently (BUY vs SELL on the same symbol).</li> <li>Reduce costs when de\u2011hedging grids or martingale legs.</li> <li>Keep audit trails cleaner (single close by event instead of two closes).</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_by/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Works on hedge accounts; not applicable to netting/FIFO modes.</li> <li>Ensure same symbol and opposite sides; broker will reject otherwise.</li> <li>After reconnection, pull <code>opened_orders()</code> to verify that any residual was handled correctly.</li> <li>If you need explicit partials on a single position, use <code>order_close_delete(...)</code> instead.</li> </ul> <p>See also: <code>order_close_delete(...)</code> \u2014 partial/full close or delete pending. <code>opened_orders(...)</code> \u2014 snapshot to verify residuals. <code>on_trade(...)</code> \u2014 stream to observe the resulting trade events.</p>"},{"location":"MT4Account/Trading_Actions/order_close_by/#usage-snippets","title":"Usage Snippets","text":""},{"location":"MT4Account/Trading_Actions/order_close_by/#1-find-an-opposite-ticket-by-symbol","title":"1) Find an opposite ticket by symbol","text":"<pre><code>od = await acct.opened_orders()\n# suppose we want to close BUY by any SELL on the same symbol\nbuy = next(o for o in od.items if o.order_type == ORDER_TYPE_BUY)\nsell = next(o for o in od.items if o.symbol == buy.symbol and o.order_type == ORDER_TYPE_SELL)\nawait acct.order_close_by(buy.ticket, sell.ticket)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_by/#2-postcheck-residual-position","title":"2) Post\u2011check residual position","text":"<pre><code>after = await acct.opened_orders()\nleft = [o for o in after.items if o.symbol == buy.symbol]\n# If any remain, volumes were unequal; update your UI or risk accordingly\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_delete/","title":"\u2705 Closing / Deleting an Order","text":"<p>Request: close a market position (full or partial) or delete a pending order by ticket. Thin wrapper over TradingHelper RPC with deadline + cooperative cancellation.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>order_close_delete(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_trading_helper_pb2.py</code> \u2014 <code>OrderCloseDelete*</code> messages</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.TradingHelper</code></li> <li>Method: <code>OrderCloseDelete(OrderCloseDeleteRequest) \u2192 OrderCloseDeleteReply</code></li> <li>Low\u2011level client: <code>TradingHelperStub.OrderCloseDelete(request, metadata, timeout)</code></li> <li>SDK wrapper:</li> </ul> <pre><code>MT4Account.order_close_delete(\n    order_ticket: int,\n    lots: float | None = None,           # partial close for market positions\n    closing_price: float | None = None,  # optional target price (market close)\n    slippage: int | None = None,         # max deviation in points (market close)\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderCloseDeleteData\n</code></pre> <p>Request message: <code>OrderCloseDeleteRequest { order_ticket, lots?, closing_price?, slippage?, comment? }</code> Reply message: <code>OrderCloseDeleteReply { data: OrderCloseDeleteData }</code></p> <p>Field names reflect your pb (<code>mt4_term_api_trading_helper_pb2.py</code>). Some builds expose <code>lots</code> as <code>volume</code>; <code>closing_price</code> may be optional/ignored for delete.</p>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#code-examples","title":"\ud83d\udd17 Code Examples","text":"<pre><code># 1) Close a full market position by ticket\nawait acct.order_close_delete(order_ticket=123456)\n\n# 2) Partial close 0.20 lots\nawait acct.order_close_delete(order_ticket=123456, lots=0.20)\n\n# 3) Delete a pending order (no price/slippage needed)\nawait acct.order_close_delete(order_ticket=789012)\n\n# 4) Close with tight slippage guard\nawait acct.order_close_delete(order_ticket=123456, slippage=10)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#method-signature","title":"Method Signature","text":"<pre><code>async def order_close_delete(\n    self,\n    order_ticket: int,\n    lots: float | None = None,\n    closing_price: float | None = None,\n    slippage: int | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderCloseDeleteData\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A single call to close an open position (optionally partially) or delete a pending order.</li> <li>Why. Core action for exits, scaling out, or cancelling unfilled entries.</li> <li>Deviation control. <code>slippage</code> applies to market closes to avoid unfavorable fills.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>order_ticket</code> <code>int</code> Ticket to close/delete. <code>lots</code> <code>float         | None</code> Partial close volume; omit to close all. <code>closing_price</code> <code>float         | None</code> Target close price (market); server may ignore if incompatible. <code>slippage</code> <code>int           | None</code> Max permitted deviation in points for market close. <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper."},{"location":"MT4Account/Trading_Actions/order_close_delete/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Trading_Actions/order_close_delete/#payload-orderclosedeletedata","title":"Payload: <code>OrderCloseDeleteData</code>","text":"Field Proto Type Description <code>mode</code> <code>enum</code> Operation mode (0 = OCD_MARKET_ORDER closed, 1 = OCD_PENDING_ORDER deleted). <code>history_order_comment</code> <code>string</code> Comment from the historical order after close/delete."},{"location":"MT4Account/Trading_Actions/order_close_delete/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Trading_Actions/order_close_delete/#mode-enum","title":"Mode Enum","text":"<ul> <li><code>OCD_MARKET_ORDER = 0</code> \u2014 Market order/position was closed</li> <li><code>OCD_PENDING_ORDER = 1</code> \u2014 Pending order was deleted</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Exit positions fully or partially (scaling out).</li> <li>Cancel unfilled pending orders.</li> <li>Enforce slippage caps on market exits.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>For partial close, ensure <code>lots</code> respects <code>VolumeMin/Step</code> from <code>symbol_params_many(...)</code>.</li> <li>If you need to close one hedge position by another, use <code>order_close_by(...)</code> instead.</li> <li>On transient network errors, the wrapper retries; make handlers idempotent to avoid double UI updates.</li> </ul> <p>See also: <code>order_send(...)</code> \u2014 place new orders with SL/TP. <code>order_modify(...)</code> \u2014 adjust SL/TP/expiration. <code>order_close_by(...)</code> \u2014 close with an opposite position (hedge accounts).</p>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#usage-snippets","title":"Usage Snippets","text":""},{"location":"MT4Account/Trading_Actions/order_close_delete/#1-scaleout-helper-50","title":"1) Scale\u2011out helper (50%)","text":"<pre><code>def half_volume(p):\n    return max(p.VolumeMin, round(p.lots / 2 / p.VolumeStep) * p.VolumeStep)\n\npos = next(it for it in (await acct.opened_orders()).items if it.ticket == 123456)\np = (await acct.symbol_params_many(pos.symbol)).params_info[0]\nawait acct.order_close_delete(order_ticket=pos.ticket, lots=half_volume(p))\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_close_delete/#2-close-with-guard-rails","title":"2) Close with guard rails","text":"<pre><code># If spread is too wide, skip close and alert\nq = await acct.quote(\"EURUSD\")\nspread_ok = getattr(q, 'spread', 0) &lt;= 30\nif spread_ok:\n    await acct.order_close_delete(order_ticket=ticket, slippage=10)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_modify/","title":"\u2705 Modifying an Order","text":"<p>Request: modify an existing market position or pending order \u2014 change price (for pendings), SL/TP, and/or expiration. Safe wrapper over TradingHelper RPC with deadline + cooperative cancellation.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>order_modify(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_trading_helper_pb2.py</code> \u2014 <code>OrderModify*</code> messages</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_modify/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.TradingHelper</code></li> <li>Method: <code>OrderModify(OrderModifyRequest) \u2192 OrderModifyReply</code></li> <li>Low\u2011level client: <code>TradingHelperStub.OrderModify(request, metadata, timeout)</code></li> <li>SDK wrapper:</li> </ul> <pre><code>MT4Account.order_modify(\n    order_ticket: int,\n    new_price: float | None = None,\n    new_stop_loss: float | None = None,\n    new_take_profit: float | None = None,\n    new_expiration: datetime | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderModifyData\n</code></pre> <p>Request message: <code>OrderModifyRequest { order_ticket, new_price?, new_stop_loss?, new_take_profit?, new_expiration? }</code> Reply message: <code>OrderModifyReply { data: OrderModifyData }</code></p>"},{"location":"MT4Account/Trading_Actions/order_modify/#code-examples","title":"\ud83d\udd17 Code Examples","text":"<pre><code># 1) Tighten SL and move TP on an existing position\nawait acct.order_modify(\n    order_ticket=123456,\n    new_stop_loss=1.0825,\n    new_take_profit=1.0890,\n)\n\n# 2) Adjust pending order price and set expiration\nfrom datetime import datetime, timedelta, timezone\nawait acct.order_modify(\n    order_ticket=789012,\n    new_price=1.0830,\n    new_expiration=datetime.now(timezone.utc) + timedelta(hours=4),\n)\n\n# 3) Clear only the expiration (set a new future time)\nawait acct.order_modify(\n    order_ticket=789012,\n    new_expiration=datetime.now(timezone.utc) + timedelta(days=1),\n)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_modify/#method-signature","title":"Method Signature","text":"<pre><code>async def order_modify(\n    self,\n    order_ticket: int,\n    new_price: float | None = None,\n    new_stop_loss: float | None = None,\n    new_take_profit: float | None = None,\n    new_expiration: datetime | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderModifyData\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_modify/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Change pending price, SL/TP, and/or expiration on an existing ticket.</li> <li>Why. Manage risk, trail protection, or re\u2011price pending entries.</li> <li>Selective updates. Pass only the fields you want to change; others remain unchanged.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_modify/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>order_ticket</code> <code>int</code> Target ticket to modify. <code>new_price</code> <code>float         | None</code> Pending orders only \u2014 new entry price. <code>new_stop_loss</code> <code>float         | None</code> New SL (raw price). <code>new_take_profit</code> <code>float         | None</code> New TP (raw price). <code>new_expiration</code> <code>datetime      | None</code> New expiration (UTC). <code>deadline</code> <code>datetime      | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event | None</code> Cooperative cancel for retry wrapper. <p>Prices are raw; convert from points/pips with <code>Point</code> from <code>symbol_params_many(...)</code>.</p>"},{"location":"MT4Account/Trading_Actions/order_modify/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Trading_Actions/order_modify/#payload-ordermodifydata","title":"Payload: <code>OrderModifyData</code>","text":"Field Proto Type Description <code>order_was_modified</code> <code>bool</code> Whether the server applied a change. <p>On error, the wrapper raises per <code>error_selector</code> inside <code>execute_with_reconnect(...)</code>.</p>"},{"location":"MT4Account/Trading_Actions/order_modify/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":"<p>This RPC does not use method\u2011specific enums.</p>"},{"location":"MT4Account/Trading_Actions/order_modify/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Trail SL/TP after breakouts.</li> <li>Re\u2011quote pending orders to new levels and extend expiry.</li> <li>Normalize SL/TP to broker\u2011approved grid (step) via server response.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_modify/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Always respect StopsLevel/FreezeLevel (<code>symbol_params_many</code>) when moving SL/TP.   Example for BUY: <code>(new_price - new_stop_loss) \u2265 StopsLevel * Point</code>.</li> <li>Ensure <code>new_price</code> is only used for pending orders; modifying market position price is not applicable.</li> <li>Use UTC for <code>new_expiration</code>; compare against <code>account_summary().server_time</code> if needed.</li> <li>For bulk updates, rate\u2011limit calls or stagger to avoid broker throttling.</li> </ul> <p>See also: <code>order_send(...)</code> \u2014 create orders. <code>order_close_delete(...)</code> \u2014 close a market position / delete a pending order. <code>order_close_by(...)</code> \u2014 close one position by another (hedge accounts).</p>"},{"location":"MT4Account/Trading_Actions/order_modify/#usage-snippets","title":"Usage Snippets","text":""},{"location":"MT4Account/Trading_Actions/order_modify/#1-guard-sl-against-minimum-distance","title":"1) Guard SL against minimum distance","text":"<pre><code>p = (await acct.symbol_params_many(\"EURUSD\")).params_info[0]\nmin_delta = max(p.StopsLevel, p.FreezeLevel) * p.Point\n# For a BUY position at price `open_price`:\nnew_sl = open_price + (-30) * p.Point  # 30 pts below\nassert (open_price - new_sl) &gt;= min_delta\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_modify/#2-extend-a-pending-order-expiration-by-24h","title":"2) Extend a pending order expiration by 24h","text":"<pre><code>from datetime import datetime, timedelta, timezone\nawait acct.order_modify(\n    order_ticket=ticket,\n    new_expiration=datetime.now(timezone.utc) + timedelta(days=1),\n)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_modify/#3-tighten-tp-only","title":"3) Tighten TP only","text":"<pre><code>await acct.order_modify(order_ticket=ticket, new_take_profit=tp_new)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_send/","title":"\u2705 Sending an Order","text":"<p>Request: place a market or pending order on a given symbol. Wrapper around the TradingHelper RPC that accepts volume, optional price (for pending), SL/TP, slippage, comment, magic, and expiration.</p> <p>Source files (SDK):</p> <ul> <li><code>MetaRpcMT4/mt4_account.py</code> \u2014 method <code>order_send(...)</code></li> <li><code>MetaRpcMT4/mt4_term_api_trading_helper_pb2.py</code> \u2014 <code>OrderSend*</code> messages, <code>OrderSendOperationType</code> enum</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_send/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt4_term_api.TradingHelper</code></li> <li>Method: <code>OrderSend(OrderSendRequest) \u2192 OrderSendReply</code></li> <li>Low\u2011level client: <code>TradingHelperStub.OrderSend(request, metadata, timeout)</code></li> <li>SDK wrapper:</li> </ul> <pre><code>MT4Account.order_send(\n    symbol: str,\n    operation_type: trading_helper_pb2.OrderSendOperationType,\n    volume: float,\n    price: float | None = None,\n    slippage: int | None = None,\n    stoploss: float | None = None,\n    takeprofit: float | None = None,\n    comment: str | None = None,\n    magic_number: int | None = None,\n    expiration: datetime | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderSendData\n</code></pre> <p>Request message: <code>OrderSendRequest { symbol, operation_type, volume, price?, slippage?, stoploss?, takeprofit?, comment?, magic_number?, expiration? }</code> Reply message: <code>OrderSendReply { data: OrderSendData }</code></p>"},{"location":"MT4Account/Trading_Actions/order_send/#code-examples","title":"\ud83d\udd17 Code Examples","text":"<pre><code>from MetaRpcMT4 import mt4_term_api_trading_helper_pb2 as trade_pb\n\n# 1) Market BUY 0.10 with SL/TP\nawait acct.order_send(\n    symbol=\"EURUSD\",\n    operation_type=trade_pb.OrderSendOperationType.OC_OP_BUY,  # BUY\n    volume=0.10,\n    stoploss=1.0820,\n    takeprofit=1.0870,\n    slippage=20,  # points\n    comment=\"bot v1\",\n    magic_number=12345,\n)\n\n# 2) Pending SELL LIMIT with expiration\nfrom datetime import datetime, timedelta, timezone\nawait acct.order_send(\n    symbol=\"XAUUSD\",\n    operation_type=trade_pb.OrderSendOperationType.OC_OP_SELLLIMIT,\n    volume=0.50,\n    price=2365.0,\n    stoploss=2378.0,\n    takeprofit=2325.0,\n    expiration=datetime.now(timezone.utc) + timedelta(hours=6),\n    comment=\"grid#7\",\n)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_send/#method-signature","title":"Method Signature","text":"<pre><code>async def order_send(\n    self,\n    symbol: str,\n    operation_type: trading_helper_pb2.OrderSendOperationType,\n    volume: float,\n    price: float | None = None,\n    slippage: int | None = None,\n    stoploss: float | None = None,\n    takeprofit: float | None = None,\n    comment: str | None = None,\n    magic_number: int | None = None,\n    expiration: datetime | None = None,\n    deadline: datetime | None = None,\n    cancellation_event: asyncio.Event | None = None,\n) -&gt; trading_helper_pb2.OrderSendData\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_send/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. A single call to place market or pending orders.</li> <li>Why. Primary entry\u2011point for strategy execution / manual actions.</li> <li>Validation. Always combine with <code>symbol_params_many(...)</code> to respect <code>VolumeMin/Max/Step</code>, <code>StopsLevel/FreezeLevel</code>, and with <code>quote(...)</code> for price sanity.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_send/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> Target symbol (e.g., <code>EURUSD</code>). <code>operation_type</code> <code>OrderSendOperationType</code> BUY / SELL / BUYLIMIT / SELLLIMIT / BUYSTOP / SELLSTOP. <code>volume</code> <code>float</code> Lots to trade (see <code>VolumeMin/Max/Step</code>). <code>price</code> <code>float                   | None</code> Entry price for pending orders; <code>None</code> for market. <code>slippage</code> <code>int                     | None</code> Max slippage in points for market orders. <code>stoploss</code> <code>float                   | None</code> Initial SL. <code>takeprofit</code> <code>float                   | None</code> Initial TP. <code>comment</code> <code>str                     | None</code> User/system comment. <code>magic_number</code> <code>int                     | None</code> EA magic for robots. <code>expiration</code> <code>datetime                | None</code> Expiration for pending orders. <code>deadline</code> <code>datetime                | None</code> Absolute per\u2011call deadline. <code>cancellation_event</code> <code>asyncio.Event           | None</code> Cooperative cancel for retry wrapper. <p>Price/SL/TP are raw prices; convert from points/pips with <code>Point</code> from <code>symbol_params_many(...)</code>.</p>"},{"location":"MT4Account/Trading_Actions/order_send/#output","title":"\u2b06\ufe0f Output","text":""},{"location":"MT4Account/Trading_Actions/order_send/#payload-ordersenddata","title":"Payload: <code>OrderSendData</code>","text":"Field Proto Type Description <code>ticket</code> <code>int32</code> Ticket assigned to the newly created order/position. <code>volume</code> <code>double</code> Volume (lots) of the order. <code>price</code> <code>double</code> Executed/placed price (market or pending). <code>open_time</code> <code>google.protobuf.Timestamp</code> Server timestamp of order opening. <p>On error, the wrapper raises per <code>error_selector</code> in <code>execute_with_reconnect(...)</code>.</p>"},{"location":"MT4Account/Trading_Actions/order_send/#related-enums-from-pb","title":"\ud83e\uddf1 Related enums (from pb)","text":""},{"location":"MT4Account/Trading_Actions/order_send/#ordersendoperationtype","title":"<code>OrderSendOperationType</code>","text":"<ul> <li><code>OC_OP_BUY = 0</code> \u2014 Market buy order</li> <li><code>OC_OP_SELL = 1</code> \u2014 Market sell order</li> <li><code>OC_OP_BUYLIMIT = 2</code> \u2014 Buy limit pending order</li> <li><code>OC_OP_SELLLIMIT = 3</code> \u2014 Sell limit pending order</li> <li><code>OC_OP_BUYSTOP = 4</code> \u2014 Buy stop pending order</li> <li><code>OC_OP_SELLSTOP = 5</code> \u2014 Sell stop pending order</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_send/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use this method to:</p> <ul> <li>Place entries from strategies or UI.</li> <li>Create bracket orders with initial SL/TP.</li> <li>Populate audit logs with ticket/price outcomes.</li> </ul>"},{"location":"MT4Account/Trading_Actions/order_send/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Respect StopsLevel/FreezeLevel: ensure <code>abs(entry - SL/TP) &gt;= min_points * Point</code>.</li> <li>Volume snapping: clamp and snap to <code>[VolumeMin, VolumeMax]</code> by <code>VolumeStep</code>.</li> <li>Prefer absolute UTC times for <code>expiration</code>. Ensure it\u2019s in the future relative to server time.</li> <li>For market orders, omit <code>price</code>; the server will fill at best available within <code>slippage</code>.</li> </ul> <p>See also: <code>order_modify(...)</code> \u2014 update SL/TP/expiration/price for pending. <code>order_close_delete(...)</code> \u2014 close market positions / delete pendings. <code>order_close_by(...)</code> \u2014 close one position by another (hedge accounts).</p>"},{"location":"MT4Account/Trading_Actions/order_send/#usage-snippets","title":"Usage Snippets","text":""},{"location":"MT4Account/Trading_Actions/order_send/#1-snap-validate-volume","title":"1) Snap &amp; validate volume","text":"<pre><code>p = (await acct.symbol_params_many(\"EURUSD\")).params_info[0]\n\ndef snap_volume(vol, p):\n    vol = max(p.VolumeMin, min(p.VolumeMax, vol))\n    steps = round((vol - p.VolumeMin) / p.VolumeStep)\n    return p.VolumeMin + steps * p.VolumeStep\n\nv = snap_volume(0.27, p)\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_send/#2-ensure-sltp-distances","title":"2) Ensure SL/TP distances","text":"<pre><code>q = await acct.quote(\"EURUSD\")\np = (await acct.symbol_params_many(\"EURUSD\")).params_info[0]\nmin_pts = max(p.StopsLevel, p.FreezeLevel)\nmin_delta = min_pts * p.Point\n\n# Example for BUY pending\nentry = q.ask - 10 * p.Point\nsl = entry - 20 * p.Point\nassert (entry - sl) &gt;= min_delta\n</code></pre>"},{"location":"MT4Account/Trading_Actions/order_send/#3-market-buy-with-tight-slippage-and-comment","title":"3) Market buy with tight slippage and comment","text":"<pre><code>from MetaRpcMT4 import mt4_term_api_trading_helper_pb2 as trade_pb\nawait acct.order_send(\n    symbol=\"GBPUSD\",\n    operation_type=trade_pb.OrderSendOperationType.OC_OP_BUY,\n    volume=0.20,\n    slippage=10,\n    comment=\"scalp#42\",\n)\n</code></pre>"},{"location":"MT4Sugar/Automation/","title":"Automation","text":""},{"location":"MT4Sugar/Automation/#async-set_trailing_stopticket-distance_pips-step_pipsnone","title":"\ud83c\udf00 <code>async set_trailing_stop(ticket, *, distance_pips, step_pips=None)</code>","text":"<p>What it does: Enables a trailing stop for the given position. The SL trails price by <code>distance_pips</code> and (optionally) updates in discrete <code>step_pips</code> increments.</p> <p>Used in:</p> <ul> <li>Letting winners run while automatically protecting gains.</li> <li>Hands\u2011off trend following and breakout strategies.</li> <li>Scalping strategies to lock in quick profits.</li> <li>Swing trading to maximize trend movements.</li> </ul> <p>Parameters:</p> <ul> <li><code>ticket</code> - Order ticket number to trail</li> <li><code>distance_pips</code> - Distance in pips between price and trailing stop</li> <li><code>step_pips</code> - (Optional) Minimum price movement in pips before updating SL. If not specified, updates on every price tick.</li> </ul> <p>How it works:</p> <ol> <li>Monitors the position in real-time</li> <li>As price moves favorably, moves SL to maintain <code>distance_pips</code> distance</li> <li>If <code>step_pips</code> is specified, only updates SL when price moves by that amount</li> <li>Returns a subscription ID that can be used to disable trailing later</li> <li>Stops automatically when position is closed</li> </ol> <p>Related to: order_modify.md, opened_orders_tickets.md</p> <p>Example 1: Basic trailing stop</p> <pre><code># Open a buy position\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20)\n\n# Trail 20 pips behind price; update every 2 pips\ntrail_id = await sugar.set_trailing_stop(\n    ticket=ticket,\n    distance_pips=20,\n    step_pips=2\n)\n</code></pre> <p>Example 2: Aggressive trailing for scalping</p> <pre><code># Scalp trade with tight trailing\nticket = await sugar.buy_market(\"EURUSD\", lots=0.2, sl_pips=10, tp_pips=15)\n\n# Trail very closely behind price (5 pips), update every pip\ntrail_id = await sugar.set_trailing_stop(\n    ticket=ticket,\n    distance_pips=5,\n    step_pips=1  # Update frequently\n)\n</code></pre> <p>Example 3: Wide trailing for swing trading</p> <pre><code># Swing trade - let it breathe\nticket = await sugar.buy_market(\"GBPUSD\", lots=0.1, sl_pips=50)\n\n# Trail 30 pips behind, update every 5 pips (reduce API calls)\ntrail_id = await sugar.set_trailing_stop(\n    ticket=ticket,\n    distance_pips=30,\n    step_pips=5  # Less frequent updates\n)\n</code></pre> <p>Example 4: Conditional trailing activation</p> <pre><code># Open position\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=60)\n\n# Wait for 20 pips profit before activating trailing\nawait sugar.auto_breakeven(ticket=ticket, trigger_pips=20)\n\n# Now enable trailing stop\ntrail_id = await sugar.set_trailing_stop(\n    ticket=ticket,\n    distance_pips=15,\n    step_pips=2\n)\n</code></pre> <p>Example 5: Multiple positions with different trailing strategies</p> <pre><code># Conservative position - wide trail\nticket1 = await sugar.buy_market(\"EURUSD\", lots=0.1)\ntrail_id1 = await sugar.set_trailing_stop(\n    ticket=ticket1,\n    distance_pips=30,\n    step_pips=5\n)\n\n# Aggressive position - tight trail\nticket2 = await sugar.buy_market(\"EURUSD\", lots=0.1)\ntrail_id2 = await sugar.set_trailing_stop(\n    ticket=ticket2,\n    distance_pips=10,\n    step_pips=1\n)\n\n# Store trail IDs for later management\ntrailing_positions = {\n    ticket1: trail_id1,\n    ticket2: trail_id2\n}\n</code></pre>"},{"location":"MT4Sugar/Automation/#async-unset_trailing_stopsubscription_id","title":"\ud83e\uddf9 <code>async unset_trailing_stop(subscription_id)</code>","text":"<p>What it does: Disables a previously set trailing stop by its subscription/handler id.</p> <p>Used in:</p> <ul> <li>Pausing automation around news events or switching strategy regime.</li> <li>Disabling trailing when profit target is reached.</li> <li>Manual intervention to take control of position management.</li> <li>Switching from automated to manual trailing strategy.</li> </ul> <p>Parameters:</p> <ul> <li><code>subscription_id</code> - The ID returned by <code>set_trailing_stop()</code></li> </ul> <p>Important notes:</p> <ul> <li>Trailing stops automatically when position is closed</li> <li>Current SL level remains in place after unsubscribing</li> <li>Can be called multiple times safely (idempotent)</li> <li>Does not close or modify the position itself</li> </ul> <p>Related to: order_modify.md</p> <p>Example 1: Basic unsubscribe</p> <pre><code># Enable trailing\ntrail_id = await sugar.set_trailing_stop(ticket=123456, distance_pips=20, step_pips=2)\n\n# Later: disable trailing\nawait sugar.unset_trailing_stop(subscription_id=trail_id)\n</code></pre> <p>Example 2: Pause trailing during news events</p> <pre><code>import datetime\n\n# Enable trailing\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1)\ntrail_id = await sugar.set_trailing_stop(ticket=ticket, distance_pips=20)\n\n# Check for upcoming news\nif is_news_time():\n    logger.info(\"News event upcoming - pausing trailing stop\")\n    await sugar.unset_trailing_stop(trail_id)\n\n    # Wait for news to pass\n    await asyncio.sleep(300)  # 5 minutes\n\n    # Resume trailing\n    trail_id = await sugar.set_trailing_stop(ticket=ticket, distance_pips=20)\n</code></pre> <p>Example 3: Disable trailing when profit target reached</p> <pre><code># Open position with trailing\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20)\ntrail_id = await sugar.set_trailing_stop(ticket=ticket, distance_pips=15, step_pips=2)\n\n# Monitor profit\nwhile True:\n    orders = await sugar._svc.opened_orders()\n    position = next((o for o in orders if o.ticket == ticket), None)\n\n    if position and position.profit &gt;= 100.0:  # $100 profit\n        logger.info(\"Profit target reached - locking in gains\")\n\n        # Disable trailing\n        await sugar.unset_trailing_stop(trail_id)\n\n        # Set tight manual SL\n        current_price = await sugar.last_quote(\"EURUSD\")\n        tight_sl = current_price[\"bid\"] - await sugar.pips_to_price(\"EURUSD\", 5)\n        await sugar.modify_sl_tp_by_price(ticket=ticket, sl_price=tight_sl)\n        break\n\n    await asyncio.sleep(5)\n</code></pre> <p>Example 4: Manage multiple trailing stops</p> <pre><code># Track all active trailing stops\nactive_trails = {}\n\n# Enable trailing for multiple positions\nfor ticket in [111111, 222222, 333333]:\n    trail_id = await sugar.set_trailing_stop(\n        ticket=ticket,\n        distance_pips=20,\n        step_pips=2\n    )\n    active_trails[ticket] = trail_id\n\n# Later: disable all trailing stops\nfor ticket, trail_id in active_trails.items():\n    logger.info(f\"Disabling trailing for ticket {ticket}\")\n    await sugar.unset_trailing_stop(trail_id)\n\nactive_trails.clear()\n</code></pre> <p>Example 5: Conditional trailing management</p> <pre><code># Enable trailing\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1)\ntrail_id = await sugar.set_trailing_stop(ticket=ticket, distance_pips=20)\n\n# Monitor market volatility\nwhile True:\n    spread = await sugar.spread_pips(\"EURUSD\")\n\n    if spread &gt; 5.0:\n        # High spread - pause trailing\n        logger.warning(\"High spread detected - pausing trailing\")\n        await sugar.unset_trailing_stop(trail_id)\n        trail_id = None\n\n    elif spread &lt; 2.0 and trail_id is None:\n        # Normal spread - resume trailing\n        logger.info(\"Spread normalized - resuming trailing\")\n        trail_id = await sugar.set_trailing_stop(ticket=ticket, distance_pips=20)\n\n    await asyncio.sleep(10)\n</code></pre>"},{"location":"MT4Sugar/Core_Defaults/","title":"Core &amp; Defaults","text":""},{"location":"MT4Sugar/Core_Defaults/#async-ensure_connected","title":"\ud83d\udd0c <code>async ensure_connected()</code>","text":"<p>What it does: Ensures that the connection to the terminal is alive; automatically reconnects if lost.</p> <p>Used in:</p> <ul> <li>Before any market operations (quotes, bars, orders).</li> <li>In long-running loops/workers to avoid silent disconnections.</li> <li>At the start of critical trading operations to guarantee connectivity.</li> <li>In scheduled tasks and background workers that run periodically.</li> </ul> <p>How it works:</p> <ol> <li>Checks if the current connection is active by attempting to get session headers</li> <li>If connection is alive, returns immediately</li> <li>If connection is lost, attempts to reconnect automatically</li> <li>Emits a <code>on_reconnect</code> hook event when reconnection succeeds</li> <li>Raises an error if reconnection fails</li> </ol> <p>Example 1: Basic usage before trading</p> <pre><code># Ensure connection before any market calls\nawait sugar.ensure_connected()\nprice = await api.quote(\"EURUSD\")\n</code></pre> <p>Example 2: In a long-running trading loop</p> <pre><code>while True:\n    # Guarantee connectivity at each iteration\n    await sugar.ensure_connected()\n\n    # Fetch market data\n    quote = await sugar.last_quote(\"EURUSD\")\n\n    # Execute trading logic\n    if quote[\"bid\"] &gt; target_price:\n        await sugar.buy_market(lots=0.1, sl_pips=20)\n\n    await asyncio.sleep(60)  # Wait 1 minute\n</code></pre> <p>Example 3: Error handling with fallback</p> <pre><code>try:\n    await sugar.ensure_connected()\n    # Proceed with trading operations\n    await sugar.buy_market(\"EURUSD\", 0.1)\nexcept ConnectivityError as e:\n    logger.error(f\"Failed to establish connection: {e}\")\n    # Notify admin or retry later\n    await notify_admin(\"MT4 connection lost\")\n</code></pre>"},{"location":"MT4Sugar/Core_Defaults/#get_defaultkey-fallbacknone","title":"\ud83d\udd0e <code>get_default(key, fallback=None)</code>","text":"<p>What it does: Returns a stored default value by key (<code>symbol</code>, <code>magic</code>, <code>deviation_pips</code>, <code>risk_percent</code>, etc.).</p> <p>Used in:</p> <ul> <li>When you need to read the current default for logic/logging.</li> <li>In wrappers where some parameters are auto-filled.</li> <li>For debugging and diagnostic purposes to verify current configuration.</li> <li>In multi-strategy applications to check active trading context.</li> </ul> <p>Available keys:</p> <ul> <li><code>symbol</code> - Default trading symbol (e.g., \"EURUSD\")</li> <li><code>magic</code> - Magic number for order identification</li> <li><code>deviation_pips</code> - Maximum allowed slippage in pips</li> <li><code>slippage_pips</code> - Alternative name for deviation</li> <li><code>risk_percent</code> - Default risk percentage per trade</li> </ul> <p>Example 1: Basic retrieval</p> <pre><code>magic = sugar.get_default(\"magic\", fallback=1001)\nprint(\"Current magic:\", magic)\n</code></pre> <p>Example 2: Logging current configuration</p> <pre><code>def log_trading_config():\n    \"\"\"Log current Sugar API defaults for debugging\"\"\"\n    config = {\n        \"symbol\": sugar.get_default(\"symbol\", \"NOT_SET\"),\n        \"magic\": sugar.get_default(\"magic\", \"NOT_SET\"),\n        \"deviation_pips\": sugar.get_default(\"deviation_pips\", 5),\n        \"risk_percent\": sugar.get_default(\"risk_percent\", 1.0),\n    }\n    logger.info(f\"Trading config: {config}\")\n</code></pre> <p>Example 3: Conditional logic based on defaults</p> <pre><code># Adjust strategy based on configured risk\nrisk_pct = sugar.get_default(\"risk_percent\", fallback=1.0)\n\nif risk_pct &gt; 2.0:\n    logger.warning(\"High risk mode activated!\")\n    # Use tighter stops\n    stop_pips = 15\nelse:\n    # Standard risk - wider stops\n    stop_pips = 30\n</code></pre>"},{"location":"MT4Sugar/Core_Defaults/#async-ping","title":"\ud83d\udce1 <code>async ping()</code>","text":"<p>What it does: Lightweight connection health check. Returns <code>True/False</code>.</p> <p>Used in:</p> <ul> <li>Monitoring, watchdog loops, readiness probes before executing critical actions.</li> <li>Together with <code>ensure_connected()</code> to quickly verify connectivity between operations.</li> <li>Health check endpoints in web APIs or monitoring systems.</li> <li>Pre-flight checks before executing expensive or critical operations.</li> </ul> <p>How it works:</p> <ol> <li>Attempts to get session headers (quick operation)</li> <li>If successful, returns <code>True</code> immediately</li> <li>If failed, attempts one reconnection attempt</li> <li>Returns <code>True</code> if reconnection succeeds, <code>False</code> otherwise</li> <li>Never raises exceptions - always returns boolean</li> </ol> <p>Example 1: Simple health check</p> <pre><code># Health check between tasks\nif not await sugar.ping():\n    await sugar.ensure_connected()\n</code></pre> <p>Example 2: Monitoring loop with alerting</p> <pre><code>async def health_monitor():\n    \"\"\"Monitor MT4 connection health every 30 seconds\"\"\"\n    while True:\n        is_healthy = await sugar.ping()\n\n        if not is_healthy:\n            logger.error(\"MT4 connection unhealthy!\")\n            await send_alert(\"MT4 connection down\")\n        else:\n            logger.debug(\"MT4 connection OK\")\n\n        await asyncio.sleep(30)\n</code></pre> <p>Example 3: Pre-flight check for critical operations</p> <pre><code>async def execute_large_order(symbol, lots):\n    \"\"\"Execute large order with pre-flight connectivity check\"\"\"\n\n    # Pre-flight check\n    if not await sugar.ping():\n        raise RuntimeError(\"Cannot execute: MT4 connection unavailable\")\n\n    # Connection OK - proceed with order\n    logger.info(f\"Executing large order: {symbol} {lots} lots\")\n    return await sugar.buy_market(symbol, lots)\n</code></pre> <p>Example 4: Web API health endpoint</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/health/mt4\")\nasync def mt4_health():\n    \"\"\"Health check endpoint for MT4 connectivity\"\"\"\n    is_connected = await sugar.ping()\n    return {\n        \"status\": \"healthy\" if is_connected else \"unhealthy\",\n        \"service\": \"MT4\",\n        \"connected\": is_connected\n    }\n</code></pre>"},{"location":"MT4Sugar/Core_Defaults/#set_defaultssymbolnone-magicnone-deviation_pipsnone-slippage_pipsnone-risk_percentnone","title":"\ud83e\uddec <code>set_defaults(symbol=None, magic=None, deviation_pips=None, slippage_pips=None, risk_percent=None)</code>","text":"<p>What it does: Sets human-friendly defaults that will be automatically injected into sugar calls.</p> <p>Used in:</p> <ul> <li>Once during app/script startup.</li> <li>When switching trading contexts (different symbol, different <code>magic</code>, etc.).</li> <li>When changing trading strategies or risk profiles.</li> <li>In multi-strategy environments to isolate different trading contexts.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Default trading symbol (e.g., \"EURUSD\", \"GBPUSD\")</li> <li><code>magic</code> - Magic number for order identification (integer)</li> <li><code>deviation_pips</code> - Maximum allowed price deviation/slippage in pips</li> <li><code>slippage_pips</code> - Alternative parameter name for deviation</li> <li><code>risk_percent</code> - Default risk percentage per trade (e.g., 1.0 = 1%)</li> </ul> <p>Important notes:</p> <ul> <li>Only non-None values are applied - existing defaults remain unchanged</li> <li>All parameters are optional</li> <li>Defaults persist until explicitly changed again</li> <li>Context-specific overrides can be done with <code>with_defaults()</code></li> </ul> <p>Example 1: App bootstrap configuration</p> <pre><code># App bootstrap: configure sane defaults\nsugar.set_defaults(\n    symbol=\"EURUSD\",\n    magic=1001,\n    deviation_pips=5,\n    slippage_pips=3,\n    risk_percent=1.0,\n)\n</code></pre> <p>Example 2: Switching trading contexts</p> <pre><code># Trade EURUSD with conservative settings\nsugar.set_defaults(\n    symbol=\"EURUSD\",\n    magic=1001,\n    risk_percent=0.5\n)\nawait sugar.buy_market(lots=0.1)  # Uses EURUSD, magic=1001\n\n# Switch to GBPUSD with aggressive settings\nsugar.set_defaults(\n    symbol=\"GBPUSD\",\n    magic=2002,\n    risk_percent=2.0\n)\nawait sugar.buy_market(lots=0.1)  # Uses GBPUSD, magic=2002\n</code></pre> <p>Example 3: Strategy-specific configuration</p> <pre><code>class ScalpingStrategy:\n    def __init__(self, sugar):\n        self.sugar = sugar\n\n        # Configure for scalping\n        self.sugar.set_defaults(\n            symbol=\"EURUSD\",\n            magic=5001,\n            deviation_pips=2,  # Tight slippage for scalping\n            risk_percent=0.5   # Conservative risk\n        )\n\nclass SwingStrategy:\n    def __init__(self, sugar):\n        self.sugar = sugar\n\n        # Configure for swing trading\n        self.sugar.set_defaults(\n            symbol=\"GBPUSD\",\n            magic=5002,\n            deviation_pips=10,  # Allow wider slippage\n            risk_percent=2.0    # Higher risk for swing trades\n        )\n</code></pre> <p>Example 4: Partial updates</p> <pre><code># Initial setup\nsugar.set_defaults(\n    symbol=\"EURUSD\",\n    magic=1001,\n    risk_percent=1.0\n)\n\n# Later: only update risk, keep symbol and magic unchanged\nsugar.set_defaults(risk_percent=2.0)\n\n# symbol=\"EURUSD\" and magic=1001 remain unchanged\n</code></pre>"},{"location":"MT4Sugar/Core_Defaults/#with_defaultsoverrides","title":"<code>with_defaults(**overrides)</code>","text":"<p>What it does: Temporarily override defaults in a limited context (within a code block).</p> <p>Used in:</p> <ul> <li>Local scenarios: \"for this section, trade GBPUSD with another magic.\"</li> <li>Tests/strategies where it's convenient to change context locally.</li> <li>Temporary context switches without affecting global configuration.</li> <li>Multi-symbol trading within a single strategy.</li> </ul> <p>Important notes:</p> <ul> <li>Changes only affect code within the <code>with</code> block</li> <li>Original defaults are automatically restored when exiting the block</li> <li>Can override multiple parameters simultaneously</li> <li>Nested contexts are supported</li> </ul> <p>Example 1: Temporary symbol switch</p> <pre><code># Global defaults: EURUSD\nsugar.set_defaults(symbol=\"EURUSD\", magic=1001)\n\n# Temporarily switch trading context\nwith sugar.with_defaults(symbol=\"GBPUSD\", magic=2002):\n    # Inside this block calls will use these defaults\n    await sugar.buy_market(lots=0.1)  # uses symbol=GBPUSD, magic=2002\n\n# Outside \u2014 back to EURUSD with magic=1001\nawait sugar.buy_market(lots=0.1)  # uses symbol=EURUSD, magic=1001\n</code></pre> <p>Example 2: Multi-symbol correlation trading</p> <pre><code># Main strategy on EURUSD\nsugar.set_defaults(symbol=\"EURUSD\", magic=1001)\n\n# Check correlation with GBPUSD\ngbpusd_spread = None\nwith sugar.with_defaults(symbol=\"GBPUSD\"):\n    gbpusd_spread = await sugar.spread_pips()\n\n# Check correlation with USDJPY\nusdjpy_spread = None\nwith sugar.with_defaults(symbol=\"USDJPY\"):\n    usdjpy_spread = await sugar.spread_pips()\n\n# Main symbol EURUSD still active\neurusd_spread = await sugar.spread_pips()  # Uses EURUSD\n\n# Trade based on correlation\nif eurusd_spread &lt; 2.0 and gbpusd_spread &lt; 3.0:\n    await sugar.buy_market(lots=0.1)  # EURUSD\n</code></pre> <p>Example 3: Risk-adjusted hedging</p> <pre><code># Main position with standard risk\nsugar.set_defaults(symbol=\"EURUSD\", risk_percent=1.0)\nticket_main = await sugar.buy_market(lots=0.1)\n\n# Hedge with lower risk\nwith sugar.with_defaults(symbol=\"EURUSD\", risk_percent=0.5):\n    lots_hedge = await sugar.calc_lot_by_risk(stop_pips=20)\n    ticket_hedge = await sugar.sell_market(lots=lots_hedge)\n\n# Back to standard risk for next trade\n# risk_percent=1.0 restored automatically\n</code></pre> <p>Example 4: Nested contexts</p> <pre><code>sugar.set_defaults(symbol=\"EURUSD\", magic=1001, risk_percent=1.0)\n\nwith sugar.with_defaults(symbol=\"GBPUSD\"):\n    # GBPUSD, magic=1001, risk_percent=1.0\n    await sugar.buy_market(lots=0.1)\n\n    with sugar.with_defaults(risk_percent=2.0):\n        # GBPUSD, magic=1001, risk_percent=2.0 (nested)\n        lots = await sugar.calc_lot_by_risk(stop_pips=20)\n        await sugar.buy_market(lots=lots)\n\n    # Back to GBPUSD, magic=1001, risk_percent=1.0\n\n# Back to EURUSD, magic=1001, risk_percent=1.0\n</code></pre> <p>Example 5: Testing with different configurations</p> <pre><code>async def test_strategy_with_different_risks():\n    \"\"\"Test how strategy performs with different risk levels\"\"\"\n\n    for risk_pct in [0.5, 1.0, 2.0, 3.0]:\n        with sugar.with_defaults(risk_percent=risk_pct):\n            lots = await sugar.calc_lot_by_risk(stop_pips=20)\n            logger.info(f\"Risk {risk_pct}% -&gt; Lot size: {lots}\")\n\n    # Original risk_percent restored after loop\n</code></pre>"},{"location":"MT4Sugar/Market_Data/","title":"Market Data","text":""},{"location":"MT4Sugar/Market_Data/#async-barssymbol-timeframe-countnone-sincenone-untilnone","title":"\ud83d\udcca <code>async bars(symbol, timeframe, *, count=None, since=None, until=None)</code>","text":"<p>What it does: Fetches historical OHLC bars for the given symbol and timeframe.</p> <p>Used in:</p> <ul> <li>Technical analysis, backtesting, visualization.</li> <li>Indicator calculations and statistical modeling.</li> <li>Pattern recognition and machine learning features.</li> <li>Strategy development and optimization.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol (e.g., \"EURUSD\")</li> <li><code>timeframe</code> - Bar period: \"M1\", \"M5\", \"M15\", \"M30\", \"H1\", \"H4\", \"D1\", \"W1\", \"MN\"</li> <li><code>count</code> - (Optional) Number of most recent bars to fetch</li> <li><code>since</code> - (Optional) Start timestamp (epoch milliseconds)</li> <li><code>until</code> - (Optional) End timestamp (epoch milliseconds)</li> </ul> <p>Returns: List of dictionaries with keys: <code>time</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code></p> <p>Important notes:</p> <ul> <li>If backend doesn't support bars API, aggregates from ticks automatically</li> <li>Returns bars in chronological order (oldest first)</li> <li>Use <code>count</code> for simple \"last N bars\" queries</li> <li>Use <code>since</code>/<code>until</code> for date range queries</li> </ul> <p>Related to: quote_history.md</p> <p>Example 1: Get last 500 hourly bars</p> <pre><code>bars = await sugar.bars(\"EURUSD\", timeframe=\"H1\", count=500)\nfor b in bars:\n    print(b[\"time\"], b[\"open\"], b[\"high\"], b[\"low\"], b[\"close\"])\n</code></pre> <p>Example 2: Calculate simple moving average</p> <pre><code># Get last 20 bars\nbars = await sugar.bars(\"EURUSD\", timeframe=\"H1\", count=20)\n\n# Calculate SMA\ncloses = [b[\"close\"] for b in bars]\nsma_20 = sum(closes) / len(closes)\nprint(f\"SMA(20): {sma_20}\")\n</code></pre> <p>Example 3: Find support/resistance levels</p> <pre><code># Get last 100 daily bars\nbars = await sugar.bars(\"EURUSD\", timeframe=\"D1\", count=100)\n\n# Find highest high and lowest low\nhighs = [b[\"high\"] for b in bars]\nlows = [b[\"low\"] for b in bars]\n\nresistance = max(highs)\nsupport = min(lows)\n\nprint(f\"Resistance: {resistance}, Support: {support}\")\n</code></pre> <p>Example 4: Multi-timeframe analysis</p> <pre><code># Get bars from different timeframes\nh1_bars = await sugar.bars(\"EURUSD\", timeframe=\"H1\", count=100)\nh4_bars = await sugar.bars(\"EURUSD\", timeframe=\"H4\", count=100)\nd1_bars = await sugar.bars(\"EURUSD\", timeframe=\"D1\", count=100)\n\n# Analyze trend across timeframes\nh1_trend = \"up\" if h1_bars[-1][\"close\"] &gt; h1_bars[-20][\"close\"] else \"down\"\nh4_trend = \"up\" if h4_bars[-1][\"close\"] &gt; h4_bars[-20][\"close\"] else \"down\"\nd1_trend = \"up\" if d1_bars[-1][\"close\"] &gt; d1_bars[-20][\"close\"] else \"down\"\n\nif h1_trend == h4_trend == d1_trend:\n    print(f\"Strong {h1_trend}trend across all timeframes\")\n</code></pre>"},{"location":"MT4Sugar/Market_Data/#async-tickssymbol-sincenone-untilnone-limitnone","title":"\ud83e\udeb6 <code>async ticks(symbol, *, since=None, until=None, limit=None)</code>","text":"<p>What it does: Returns historical tick data for the symbol starting from <code>since</code> (if provided).</p> <p>Used in:</p> <ul> <li>High\u2011frequency analysis, custom bar building.</li> <li>Testing trading logic on raw tick data.</li> <li>Spread analysis and liquidity studies.</li> <li>Microsecond-level market microstructure analysis.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>since</code> - (Optional) Start timestamp (epoch milliseconds)</li> <li><code>until</code> - (Optional) End timestamp (epoch milliseconds)</li> <li><code>limit</code> - (Optional) Maximum number of ticks to return</li> </ul> <p>Returns: List of dictionaries with keys: <code>time</code>, <code>bid</code>, <code>ask</code></p> <p>Important notes:</p> <ul> <li>Tick data can be very large - use <code>limit</code> to control size</li> <li>Returns ticks in chronological order</li> <li>Time is in epoch milliseconds</li> </ul> <p>Related to: quote_history.md</p> <p>Example 1: Get last 100 ticks</p> <pre><code>ticks = await sugar.ticks(\"EURUSD\", limit=100)\nfor t in ticks:\n    print(t[\"time\"], t[\"bid\"], t[\"ask\"])\n</code></pre> <p>Example 2: Analyze spread over time</p> <pre><code># Get last 1000 ticks\nticks = await sugar.ticks(\"EURUSD\", limit=1000)\n\n# Calculate spread for each tick\nspreads = [(t[\"ask\"] - t[\"bid\"]) * 10000 for t in ticks]  # in pips\n\navg_spread = sum(spreads) / len(spreads)\nmax_spread = max(spreads)\nmin_spread = min(spreads)\n\nprint(f\"Average spread: {avg_spread:.1f} pips\")\nprint(f\"Max spread: {max_spread:.1f} pips\")\nprint(f\"Min spread: {min_spread:.1f} pips\")\n</code></pre> <p>Example 3: Build custom 1-second bars from ticks</p> <pre><code>import time\n\n# Get ticks for last 5 minutes\nsince_time = int((time.time() - 300) * 1000)  # 5 minutes ago\nticks = await sugar.ticks(\"EURUSD\", since=since_time)\n\n# Group ticks into 1-second bars\nbars = {}\nfor t in ticks:\n    second = t[\"time\"] // 1000  # Round to second\n    if second not in bars:\n        bars[second] = {\"open\": t[\"bid\"], \"high\": t[\"bid\"], \"low\": t[\"bid\"], \"close\": t[\"bid\"]}\n    else:\n        bars[second][\"high\"] = max(bars[second][\"high\"], t[\"bid\"])\n        bars[second][\"low\"] = min(bars[second][\"low\"], t[\"bid\"])\n        bars[second][\"close\"] = t[\"bid\"]\n\nprint(f\"Created {len(bars)} 1-second bars\")\n</code></pre>"},{"location":"MT4Sugar/Market_Data/#async-wait_pricesymbol-target-direction-timeout_snone","title":"\u23f3 <code>async wait_price(symbol, target, direction='&gt;=', timeout_s=None)</code>","text":"<p>What it does: Waits until price crosses a target level in the specified direction. Returns the actual trigger price if satisfied within timeout, otherwise raises TimeoutError.</p> <p>Used in:</p> <ul> <li>Automation flows that must \"wait for price\" before placing/closing orders.</li> <li>Syncing with real market movement without busy polling.</li> <li>Implementing price alerts and notifications.</li> <li>Conditional order placement strategies.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>target</code> - Target price level to wait for</li> <li><code>direction</code> - Comparison operator: \"&gt;=\", \"&lt;=\", \"&gt;\", \"&lt;\"</li> <li><code>timeout_s</code> - (Optional) Timeout in seconds. If None, waits indefinitely.</li> </ul> <p>Returns: Actual mid-price that triggered the condition (float)</p> <p>Raises: <code>TimeoutError</code> if timeout is reached before condition is met</p> <p>Important notes:</p> <ul> <li>Uses mid price: (bid + ask) / 2</li> <li>Polls every 0.25 seconds (non-blocking)</li> <li>Raises TimeoutError on timeout (not returns False)</li> </ul> <p>Related to: on_symbol_tick.md</p> <p>Example 1: Wait for breakout above resistance</p> <pre><code># Wait until price breaks 1.1050 resistance\ntry:\n    trigger_price = await sugar.wait_price(\n        \"EURUSD\",\n        target=1.1050,\n        direction=\"&gt;=\",\n        timeout_s=300  # 5 minutes\n    )\n    print(f\"Breakout! Price: {trigger_price}\")\n\n    # Enter long on breakout\n    await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=60)\nexcept TimeoutError:\n    print(\"Timeout - no breakout occurred\")\n</code></pre> <p>Example 2: Wait for pullback to support</p> <pre><code># Wait for price to pull back to 1.0950 support\ntry:\n    trigger_price = await sugar.wait_price(\n        \"EURUSD\",\n        target=1.0950,\n        direction=\"&lt;=\",\n        timeout_s=600  # 10 minutes\n    )\n    print(f\"Support reached at {trigger_price}\")\n    await sugar.buy_limit(\"EURUSD\", lots=0.1, price=1.0950, sl_pips=25)\nexcept TimeoutError:\n    print(\"Support not reached within 10 minutes\")\n</code></pre> <p>Example 3: Price alert system</p> <pre><code>async def price_alert(symbol, level, direction, message):\n    \"\"\"Send alert when price reaches level\"\"\"\n    try:\n        trigger_price = await sugar.wait_price(\n            symbol,\n            target=level,\n            direction=direction,\n            timeout_s=None  # Wait indefinitely\n        )\n        logger.info(f\"ALERT: {message} - Price: {trigger_price}\")\n        await send_notification(message)\n    except Exception as e:\n        logger.error(f\"Alert error: {e}\")\n\n# Run multiple alerts concurrently\nimport asyncio\nawait asyncio.gather(\n    price_alert(\"EURUSD\", 1.1000, \"&gt;=\", \"EURUSD broke 1.1000!\"),\n    price_alert(\"GBPUSD\", 1.2500, \"&lt;=\", \"GBPUSD dropped to 1.2500!\"),\n    price_alert(\"USDJPY\", 150.00, \"&gt;=\", \"USDJPY hit 150!\"),\n)\n</code></pre> <p>Example 4: Conditional order entry</p> <pre><code># Wait for price to reach specific level before entering\nentry_level = 1.1000\n\n# Wait for level to be reached\ntrigger_price = await sugar.wait_price(\"EURUSD\", target=entry_level, direction=\"&gt;=\")\n\n# Verify we still want to enter (conditions haven't changed)\nspread = await sugar.spread_pips(\"EURUSD\")\nif spread &lt; 2.0:\n    await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20)\nelse:\n    logger.warning(\"Spread too high - skipping entry\")\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/","title":"Math &amp; Risk","text":""},{"location":"MT4Sugar/Math_Risk/#async-auto_breakeventicket-trigger_pips-plus_pips00","title":"\ud83e\udd16 <code>async auto_breakeven(ticket, *, trigger_pips, plus_pips=0.0)</code>","text":"<p>What it does: Automatically moves SL to breakeven once price advances by <code>trigger_pips</code>; sets SL to <code>entry \u00b1 plus_pips</code> depending on direction.</p> <p>Used in:</p> <ul> <li>Semi\u2011automated strategies/scalping to lock in breakeven without manual intervention.</li> </ul> <p>Related to: order_modify.md, opened_orders.md</p> <p>Example</p> <pre><code>await sugar.auto_breakeven(ticket=123456, trigger_pips=15, plus_pips=1.0)\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#breakeven_priceentry_price-commission00-swap00","title":"\u2696\ufe0f <code>breakeven_price(entry_price, commission=0.0, swap=0.0)</code>","text":"<p>What it does: Computes breakeven price considering commission/swap.</p> <p>Used in:</p> <ul> <li>Determining the level to pull SL to when targeting \"flat\" (zero P/L).</li> </ul> <p>Related to: pure math helper</p> <p>Example</p> <pre><code>be = sugar.breakeven_price(entry_price=1.10000, commission=0.5, swap=0.0)\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-calc_cash_risksymbol-lots-stop_pips","title":"\ud83d\udcb5 <code>async calc_cash_risk(symbol, lots, stop_pips)</code>","text":"<p>What it does: Calculates cash risk for a position if SL is placed <code>stop_pips</code> away.</p> <p>Used in:</p> <ul> <li>Risk control / money management before order placement.</li> <li>Validating position sizes don't exceed risk limits.</li> <li>Portfolio risk aggregation.</li> <li>Risk reporting and monitoring.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>lots</code> - Position size in lots</li> <li><code>stop_pips</code> - Stop loss distance in pips</li> </ul> <p>Returns: Cash risk amount in account currency (float)</p> <p>Related to: tick_value_with_size.md</p> <p>Example 1: Verify risk before opening</p> <pre><code># Check if risk is acceptable\nrisk_cash = await sugar.calc_cash_risk(\"EURUSD\", lots=0.2, stop_pips=25)\nprint(f\"This trade risks ${risk_cash:.2f}\")\n\nif risk_cash &gt; 100:\n    logger.warning(\"Risk too high - reducing position size\")\nelse:\n    await sugar.buy_market(\"EURUSD\", lots=0.2, sl_pips=25)\n</code></pre> <p>Example 2: Calculate total portfolio risk</p> <pre><code># Get all open positions\norders = await sugar._svc.opened_orders()\n\ntotal_risk = 0\nfor order in orders:\n    # Calculate risk for each position\n    risk = await sugar.calc_cash_risk(\n        symbol=order.symbol,\n        lots=order.lots,\n        stop_pips=abs(order.stop_loss - order.open_price) / pip_size\n    )\n    total_risk += risk\n\nprint(f\"Total portfolio risk: ${total_risk:.2f}\")\n</code></pre> <p>Example 3: Risk as percentage of balance</p> <pre><code>balance = 10000  # Account balance\nrisk_cash = await sugar.calc_cash_risk(\"EURUSD\", lots=0.1, stop_pips=20)\nrisk_pct = (risk_cash / balance) * 100\n\nprint(f\"Risk: ${risk_cash:.2f} ({risk_pct:.2f}% of balance)\")\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-calc_lot_by_risksymbol-risk_percent-stop_pips-balancenone","title":"\ud83e\uddee <code>async calc_lot_by_risk(symbol, risk_percent, stop_pips, *, balance=None)</code>","text":"<p>What it does: Derives lot size from desired <code>%</code> risk of balance and SL distance in pips. This is THE MOST IMPORTANT method for proper position sizing.</p> <p>Used in:</p> <ul> <li>Auto\u2011sizing position before sending an order.</li> <li>Implementing consistent risk management across all trades.</li> <li>Adjusting position size based on stop loss distance.</li> <li>Portfolio risk management.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>risk_percent</code> - Percentage of balance to risk (e.g., 1.0 = 1%, 2.5 = 2.5%)</li> <li><code>stop_pips</code> - Stop loss distance in pips</li> <li><code>balance</code> - (Optional) Account balance. If None, fetches current balance automatically.</li> </ul> <p>Returns: Lot size (float) that risks exactly the specified percentage</p> <p>Important notes:</p> <ul> <li>Automatically fetches account balance if not provided</li> <li>Accounts for symbol-specific tick values</li> <li>Returns normalized lot size (valid for broker)</li> <li>Higher risk_percent = larger position</li> <li>Wider stop_pips = smaller position (for same risk)</li> </ul> <p>Related to: tick_value_with_size.md</p> <p>Example 1: Risk 1% on each trade</p> <pre><code># Risk 1% of balance with 20 pip stop\nlots = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=1.0, stop_pips=20)\nawait sugar.buy_market(\"EURUSD\", lots=lots, sl_pips=20)\n</code></pre> <p>Example 2: Adaptive position sizing</p> <pre><code># Tighter stops = larger position\n# Wider stops = smaller position\n\n# Volatile market - wide stop, automatically smaller position\nlots_volatile = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=1.0, stop_pips=50)\n\n# Calm market - tight stop, automatically larger position\nlots_calm = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=1.0, stop_pips=10)\n\nprint(f\"50 pip stop = {lots_volatile} lots\")  # e.g., 0.04\nprint(f\"10 pip stop = {lots_calm} lots\")      # e.g., 0.20\n</code></pre> <p>Example 3: Different risk levels for different strategies</p> <pre><code># Conservative: 0.5% risk\nconservative_lots = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=0.5, stop_pips=20)\n\n# Standard: 1% risk\nstandard_lots = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=1.0, stop_pips=20)\n\n# Aggressive: 2% risk\naggressive_lots = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=2.0, stop_pips=20)\n\n# Use based on signal confidence\nif signal_confidence &gt; 0.8:\n    lots = aggressive_lots\nelif signal_confidence &gt; 0.5:\n    lots = standard_lots\nelse:\n    lots = conservative_lots\n</code></pre> <p>Example 4: Portfolio risk management</p> <pre><code># Never risk more than 5% total across all positions\nMAX_TOTAL_RISK = 5.0\ncurrent_risk = 2.5  # Already 2.5% at risk in other positions\n\nremaining_risk = MAX_TOTAL_RISK - current_risk  # 2.5%\n\nif remaining_risk &gt; 0:\n    lots = await sugar.calc_lot_by_risk(\"EURUSD\", risk_percent=remaining_risk, stop_pips=20)\n    await sugar.buy_market(\"EURUSD\", lots=lots, sl_pips=20)\nelse:\n    logger.warning(\"Max portfolio risk reached - no new positions\")\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-close_by_breakeventicket-plus_pips00","title":"\ud83e\uddf7 <code>async close_by_breakeven(ticket, plus_pips=0.0)</code>","text":"<p>What it does: Closes a position if price returns to entry (adjusted by <code>plus_pips</code>).</p> <p>Used in:</p> <ul> <li>\"Don\u2019t give back\" logic: from profit either continue or exit flat.</li> </ul> <p>Related to: order_close_delete.md, opened_orders_tickets.md</p> <p>Example</p> <pre><code>await sugar.close_by_breakeven(ticket=123456, plus_pips=0.5)\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-normalize_lotsymbol-lots","title":"\ud83e\uddef <code>async normalize_lot(symbol, lots)</code>","text":"<p>What it does: Normalizes lot to the instrument's step/min/max constraints.</p> <p>Used in:</p> <ul> <li>Before <code>order_send</code> / <code>order_modify</code> to avoid broker rejections.</li> <li>Ensuring lot sizes comply with broker requirements.</li> <li>Rounding calculated lot sizes to valid values.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>lots</code> - Lot size to normalize</li> </ul> <p>Returns: Normalized lot size (float) that meets broker requirements</p> <p>Important notes:</p> <ul> <li>Rounds to nearest valid lot step (usually 0.01)</li> <li>Clamps to min/max lot sizes</li> <li>Essential to avoid \"invalid volume\" errors</li> </ul> <p>Related to: symbol_params_many.md</p> <p>Example 1: Normalize calculated lots</p> <pre><code>lots_ok = await sugar.normalize_lot(\"XAUUSD\", lots=0.033)  # \u2192 0.03\n</code></pre> <p>Example 2: Normalize before order placement</p> <pre><code># Calculate ideal lot size\nideal_lots = 0.1234\n\n# Normalize to broker requirements\nactual_lots = await sugar.normalize_lot(\"EURUSD\", ideal_lots)\n\nawait sugar.buy_market(\"EURUSD\", lots=actual_lots)\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-normalize_pricesymbol-price","title":"\ud83c\udfaf <code>async normalize_price(symbol, price)</code>","text":"<p>What it does: Normalizes price to the instrument's precision (<code>digits/point</code>).</p> <p>Used in:</p> <ul> <li>Before setting SL/TP/limit/stop orders.</li> <li>Ensuring prices comply with broker requirements.</li> <li>Rounding calculated prices to valid tick sizes.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>price</code> - Price to normalize</li> </ul> <p>Returns: Normalized price (float) rounded to valid tick size</p> <p>Important notes:</p> <ul> <li>Rounds to nearest valid tick</li> <li>Essential to avoid order rejections</li> <li>Different symbols have different precision (EURUSD: 5 digits, USDJPY: 3 digits)</li> </ul> <p>Related to: symbol_params_many.md</p> <p>Example 1: Normalize calculated price</p> <pre><code>p = await sugar.normalize_price(\"GBPUSD\", 1.279991)  # \u2192 1.27999\n</code></pre> <p>Example 2: Normalize SL/TP before order</p> <pre><code># Calculate ideal SL price\nideal_sl = 1.095678\n\n# Normalize to broker precision\nactual_sl = await sugar.normalize_price(\"EURUSD\", ideal_sl)\n\nawait sugar.buy_market(\"EURUSD\", lots=0.1)\nawait sugar.modify_sl_tp_by_price(ticket=ticket, sl_price=actual_sl)\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-pips_to_pricesymbol-pips","title":"\ud83d\udccf <code>async pips_to_price(symbol, pips)</code>","text":"<p>What it does: Converts a distance in pips to a price delta for the symbol.</p> <p>Used in:</p> <ul> <li>Computing SL/TP/entry levels from pip values.</li> <li>Converting pip-based calculations to actual price levels.</li> <li>Setting orders at specific pip distances from current price.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>pips</code> - Number of pips to convert</li> </ul> <p>Returns: Price delta (float) equivalent to the pip distance</p> <p>Important notes:</p> <ul> <li>Accounts for symbol-specific pip sizes</li> <li>For 5-digit brokers (EURUSD): 10 pips = 0.00100</li> <li>For 3-digit brokers (USDJPY): 10 pips = 0.100</li> </ul> <p>Related to: symbol_params_many.md, tick_value_with_size.md</p> <p>Example 1: Basic conversion</p> <pre><code>delta = await sugar.pips_to_price(\"EURUSD\", 15)  # ~0.0015 on 5-digit\n</code></pre> <p>Example 2: Calculate SL/TP prices</p> <pre><code># Get current price\nquote = await sugar.last_quote(\"EURUSD\")\nentry_price = quote[\"ask\"]\n\n# Calculate SL and TP prices\nsl_distance = await sugar.pips_to_price(\"EURUSD\", 20)\ntp_distance = await sugar.pips_to_price(\"EURUSD\", 60)\n\nsl_price = entry_price - sl_distance  # For buy order\ntp_price = entry_price + tp_distance  # For buy order\n\nprint(f\"Entry: {entry_price}, SL: {sl_price}, TP: {tp_price}\")\n</code></pre> <p>Example 3: Place order at specific pip distance</p> <pre><code># Place buy stop 30 pips above current price\nquote = await sugar.last_quote(\"EURUSD\")\ncurrent_ask = quote[\"ask\"]\n\npip_distance = await sugar.pips_to_price(\"EURUSD\", 30)\nentry_price = current_ask + pip_distance\n\nawait sugar.buy_stop(\"EURUSD\", lots=0.1, price=entry_price, sl_pips=20)\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-price_to_pipssymbol-price_delta","title":"\ud83d\udd01 <code>async price_to_pips(symbol, price_delta)</code>","text":"<p>What it does: Converts a price delta back into pips for the symbol.</p> <p>Used in:</p> <ul> <li>Expressing spread/profit/risk in pips.</li> <li>Calculating profit/loss in pips.</li> <li>Converting technical levels to pip distances.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol</li> <li><code>price_delta</code> - Price difference to convert</li> </ul> <p>Returns: Number of pips (float)</p> <p>Related to: symbol_params_many.md</p> <p>Example 1: Convert price to pips</p> <pre><code>pips = await sugar.price_to_pips(\"EURUSD\", 0.0007)  # ~7 pips\n</code></pre> <p>Example 2: Calculate profit in pips</p> <pre><code># Get position details\nentry_price = 1.09500\ncurrent_price = 1.09750\nprice_move = current_price - entry_price\n\n# Convert to pips\nprofit_pips = await sugar.price_to_pips(\"EURUSD\", price_move)\nprint(f\"Profit: {profit_pips:.1f} pips\")  # ~25 pips\n</code></pre> <p>Example 3: Measure distance to key levels</p> <pre><code># Technical analysis\nquote = await sugar.last_quote(\"EURUSD\")\ncurrent_price = quote[\"bid\"]\n\nresistance = 1.1000\ndistance_to_resistance = resistance - current_price\npips_to_resistance = await sugar.price_to_pips(\"EURUSD\", distance_to_resistance)\n\nprint(f\"{pips_to_resistance:.1f} pips to resistance\")\n</code></pre>"},{"location":"MT4Sugar/Math_Risk/#async-tick_valuesymbol-lots10","title":"\ud83c\udfab <code>async tick_value(symbol, lots=1.0)</code>","text":"<p>What it does: Cash value of one tick move for the symbol at the given lot.</p> <p>Used in:</p> <ul> <li>Risk management, expected P/L per tick.</li> </ul> <p>Related to: tick_value_with_size.md</p> <p>Example</p> <pre><code>tv = await sugar.tick_value(\"USDJPY\", lots=0.5)\n</code></pre>"},{"location":"MT4Sugar/Order_Management/","title":"Order Management","text":""},{"location":"MT4Sugar/Order_Management/#async-modify_sl_tp_by_pipsticket-sl_pipsnone-tp_pipsnone","title":"\ud83d\udcdd <code>async modify_sl_tp_by_pips(ticket, *, sl_pips=None, tp_pips=None)</code>","text":"<p>What it does: Modifies an existing order or position by setting SL/TP in pips relative to the entry price.</p> <p>Used in:</p> <ul> <li>Quickly adjusting protective levels without manually converting to price.</li> <li>Moving stop loss to breakeven after reaching profit targets.</li> <li>Tightening stops as price moves favorably.</li> <li>Extending take profit targets in trending markets.</li> </ul> <p>Parameters:</p> <ul> <li><code>ticket</code> - Order ticket number to modify</li> <li><code>sl_pips</code> - (Optional) Stop Loss distance in pips from entry price</li> <li><code>tp_pips</code> - (Optional) Take Profit distance in pips from entry price</li> </ul> <p>Important notes:</p> <ul> <li>Pips are calculated from the entry price, not current price</li> <li>Pass <code>None</code> to keep existing SL or TP unchanged</li> <li>Pass <code>0</code> to remove SL or TP completely</li> <li>Method automatically handles buy vs sell direction</li> </ul> <p>Related to: order_modify.md, opened_orders_tickets.md</p> <p>Example 1: Move to breakeven</p> <pre><code># Move SL to breakeven (0 pips from entry)\nawait sugar.modify_sl_tp_by_pips(ticket=123456, sl_pips=0)\n</code></pre> <p>Example 2: Tighten both SL and TP</p> <pre><code>await sugar.modify_sl_tp_by_pips(ticket=123456, sl_pips=20, tp_pips=40)\n</code></pre> <p>Example 3: Only modify SL, keep TP unchanged</p> <pre><code># Only change SL, TP remains as is\nawait sugar.modify_sl_tp_by_pips(ticket=123456, sl_pips=30)\n</code></pre> <p>Example 4: Progressive stop tightening</p> <pre><code># Open position\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=50, tp_pips=100)\n\n# After 20 pips profit, tighten to 30 pips\nawait asyncio.sleep(60)\nawait sugar.modify_sl_tp_by_pips(ticket=ticket, sl_pips=30)\n\n# After 40 pips profit, tighten to 15 pips\nawait asyncio.sleep(60)\nawait sugar.modify_sl_tp_by_pips(ticket=ticket, sl_pips=15)\n\n# After 60 pips profit, move to breakeven\nawait asyncio.sleep(60)\nawait sugar.modify_sl_tp_by_pips(ticket=ticket, sl_pips=0)\n</code></pre> <p>Example 5: Remove TP to let position run</p> <pre><code># Remove TP, keep SL\nawait sugar.modify_sl_tp_by_pips(ticket=123456, sl_pips=20, tp_pips=0)\n</code></pre>"},{"location":"MT4Sugar/Order_Management/#async-modify_sl_tp_by_priceticket-sl_pricenone-tp_pricenone","title":"\ud83d\udcdd <code>async modify_sl_tp_by_price(ticket, *, sl_price=None, tp_price=None)</code>","text":"<p>What it does: Modifies SL/TP by specifying exact price levels.</p> <p>Used in:</p> <ul> <li>Precise SL/TP placement from external calculations or strategy logic.</li> <li>Setting stops at specific support/resistance levels.</li> <li>Aligning stops with technical indicators (e.g., moving averages).</li> </ul> <p>Parameters:</p> <ul> <li><code>ticket</code> - Order ticket number to modify</li> <li><code>sl_price</code> - (Optional) Exact Stop Loss price level</li> <li><code>tp_price</code> - (Optional) Exact Take Profit price level</li> </ul> <p>Important notes:</p> <ul> <li>Prices must be valid for the order direction (SL below entry for buy, above for sell)</li> <li>Pass <code>None</code> to keep existing SL or TP unchanged</li> <li>Pass <code>0</code> to remove SL or TP</li> </ul> <p>Related to: order_modify.md</p> <p>Example 1: Set to specific levels</p> <pre><code>await sugar.modify_sl_tp_by_price(ticket=123456, sl_price=1.0925, tp_price=1.1010)\n</code></pre> <p>Example 2: Set SL to previous day's low</p> <pre><code># Get yesterday's bars\nbars = await sugar.bars(\"EURUSD\", timeframe=\"D1\", count=2)\nyesterday_low = bars[-2][\"low\"]\n\n# Set SL at yesterday's low\nawait sugar.modify_sl_tp_by_price(ticket=ticket, sl_price=yesterday_low)\n</code></pre> <p>Example 3: Set SL at moving average</p> <pre><code># Calculate 20 EMA\nbars = await sugar.bars(\"EURUSD\", timeframe=\"H1\", count=20)\ncloses = [b[\"close\"] for b in bars]\nema_20 = sum(closes) / len(closes)  # Simplified\n\n# Set SL at EMA\nawait sugar.modify_sl_tp_by_price(ticket=ticket, sl_price=ema_20)\n</code></pre>"},{"location":"MT4Sugar/Order_Management/#async-closeticket","title":"\u274c <code>async close(ticket)</code>","text":"<p>What it does: Closes a specific order or position by ticket.</p> <p>Used in:</p> <ul> <li>Manual or automated close actions triggered by strategy conditions.</li> <li>Taking profit at predetermined levels.</li> <li>Emergency exits based on news or market conditions.</li> </ul> <p>Parameters:</p> <ul> <li><code>ticket</code> - Order ticket number to close</li> </ul> <p>Important notes:</p> <ul> <li>Closes the entire position</li> <li>For partial closes, use <code>close_partial()</code></li> <li>Works for both market positions and pending orders (pending orders are deleted)</li> </ul> <p>Related to: order_close_delete.md</p> <p>Example 1: Simple close</p> <pre><code>await sugar.close(123456)\n</code></pre> <p>Example 2: Close on signal reversal</p> <pre><code># Monitor for exit signal\nwhile True:\n    if exit_signal_detected():\n        logger.info(\"Exit signal - closing position\")\n        await sugar.close(ticket)\n        break\n    await asyncio.sleep(5)\n</code></pre> <p>Example 3: Time-based exit</p> <pre><code>import asyncio\n\n# Open position\nticket = await sugar.buy_market(\"EURUSD\", lots=0.1)\n\n# Close after 1 hour\nawait asyncio.sleep(3600)\nawait sugar.close(ticket)\n</code></pre>"},{"location":"MT4Sugar/Order_Management/#async-close_partialticket-lots","title":"\u2702\ufe0f <code>async close_partial(ticket, lots)</code>","text":"<p>What it does: Partially closes a position by the specified lot size.</p> <p>Used in:</p> <ul> <li>Taking partial profit or reducing exposure while keeping trade open.</li> <li>Scaling out of positions as profit targets are reached.</li> <li>Risk reduction while maintaining market exposure.</li> </ul> <p>Parameters:</p> <ul> <li><code>ticket</code> - Order ticket number</li> <li><code>lots</code> - Amount of lots to close (must be less than position size)</li> </ul> <p>Important notes:</p> <ul> <li>Remaining position keeps the same ticket number (in MT4)</li> <li>Closed portion creates a new history entry</li> <li>Useful for pyramiding strategies</li> </ul> <p>Related to: order_close_delete.md</p> <p>Example 1: Close half the position</p> <pre><code>await sugar.close_partial(ticket=123456, lots=0.05)\n</code></pre> <p>Example 2: Scale out at multiple profit levels</p> <pre><code># Open 0.3 lot position\nticket = await sugar.buy_market(\"EURUSD\", lots=0.3, sl_pips=30)\n\n# Take 1/3 profit at 20 pips\nawait sugar.wait_price(\"EURUSD\", target=entry + 0.0020, direction=\"&gt;=\")\nawait sugar.close_partial(ticket=ticket, lots=0.1)\n\n# Take another 1/3 at 40 pips\nawait sugar.wait_price(\"EURUSD\", target=entry + 0.0040, direction=\"&gt;=\")\nawait sugar.close_partial(ticket=ticket, lots=0.1)\n\n# Let final 1/3 run with trailing stop\nawait sugar.set_trailing_stop(ticket=ticket, distance_pips=20)\n</code></pre> <p>Example 3: Reduce exposure on high volatility</p> <pre><code># Monitor spread\nspread = await sugar.spread_pips(\"EURUSD\")\n\nif spread &gt; 5.0:\n    # High spread - reduce exposure by 50%\n    logger.warning(\"High spread - reducing position\")\n    await sugar.close_partial(ticket=ticket, lots=0.05)\n</code></pre>"},{"location":"MT4Sugar/Order_Management/#async-close_byticket_a-ticket_b","title":"\ud83d\udd01 <code>async close_by(ticket_a, ticket_b)</code>","text":"<p>What it does: Closes position <code>ticket_a</code> by opposite position <code>ticket_b</code> (Close By).</p> <p>Used in:</p> <ul> <li>Reducing commission and swap by netting opposite trades.</li> <li>Hedging strategies where you want to close offsetting positions.</li> <li>Avoiding spread costs when closing opposite positions.</li> </ul> <p>Parameters:</p> <ul> <li><code>ticket_a</code> - First position ticket</li> <li><code>ticket_b</code> - Opposite position ticket (must be opposite direction on same symbol)</li> </ul> <p>Important notes:</p> <ul> <li>Both positions must be on the same symbol</li> <li>Positions must be opposite directions (one buy, one sell)</li> <li>Saves spread costs compared to closing each separately</li> <li>If positions are different sizes, smaller one closes completely, larger one is reduced</li> </ul> <p>Related to: order_close_by.md</p> <p>Example 1: Close hedged positions</p> <pre><code>await sugar.close_by(ticket_a=111111, ticket_b=222222)\n</code></pre> <p>Example 2: Hedge and close strategy</p> <pre><code># Open long position\nlong_ticket = await sugar.buy_market(\"EURUSD\", lots=0.1)\n\n# Market turns against us - hedge with short\nshort_ticket = await sugar.sell_market(\"EURUSD\", lots=0.1)\n\n# Wait for favorable conditions\nawait asyncio.sleep(300)\n\n# Close both positions by netting\nawait sugar.close_by(ticket_a=long_ticket, ticket_b=short_ticket)\n</code></pre>"},{"location":"MT4Sugar/Order_Management/#async-close_all-symbolnone-magicnone-only_profitnone","title":"\ud83e\uddf9 <code>async close_all(*, symbol=None, magic=None, only_profit=None)</code>","text":"<p>What it does: Closes multiple open positions filtered by symbol/magic. If <code>only_profit</code> is True/False, closes only profitable or losing positions.</p> <p>Used in:</p> <ul> <li>Emergency flattening, portfolio resets, strategy exits.</li> <li>End-of-day position closure.</li> <li>Closing all positions before major news events.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - (Optional) Filter by specific symbol</li> <li><code>magic</code> - (Optional) Filter by magic number</li> <li><code>only_profit</code> - (Optional) <code>True</code>=only profitable, <code>False</code>=only losing, <code>None</code>=all</li> </ul> <p>Important notes:</p> <ul> <li>If no filters provided, closes all positions in the account</li> <li>Use filters carefully to avoid closing unintended positions</li> <li>Pending orders are not affected (use <code>cancel_pendings()</code> for those)</li> </ul> <p>Related to: opened_orders.md, order_close_delete.md</p> <p>Example 1: Close all profitable positions for specific symbol</p> <pre><code># Close all profitable EURUSD with given magic\nawait sugar.close_all(symbol=\"EURUSD\", magic=1001, only_profit=True)\n</code></pre> <p>Example 2: Emergency flatten all positions</p> <pre><code># Major news event - close everything\nlogger.warning(\"Major news event - closing all positions\")\nawait sugar.close_all()\n</code></pre> <p>Example 3: End of day routine</p> <pre><code># Close all positions at end of trading day\nif is_end_of_day():\n    await sugar.close_all(magic=1001)\n    logger.info(\"All positions closed for end of day\")\n</code></pre> <p>Example 4: Close only losing positions</p> <pre><code># Cut all losses before weekend\nif is_friday_evening():\n    await sugar.close_all(only_profit=False)\n    logger.info(\"All losing positions closed before weekend\")\n</code></pre>"},{"location":"MT4Sugar/Order_Management/#async-cancel_pendings-symbolnone-magicnone","title":"\ud83d\uddd1\ufe0f <code>async cancel_pendings(*, symbol=None, magic=None)</code>","text":"<p>What it does: Cancels pending orders filtered by symbol and magic.</p> <p>Used in:</p> <ul> <li>Cleaning up hanging limit/stop orders before context change.</li> <li>Removing unfilled orders after strategy change.</li> <li>Canceling breakout orders when range-bound conditions detected.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - (Optional) Filter by specific symbol</li> <li><code>magic</code> - (Optional) Filter by magic number</li> </ul> <p>Important notes:</p> <ul> <li>Only affects pending orders (buy/sell limit/stop)</li> <li>Does not close market positions (use <code>close_all()</code> for that)</li> <li>If no filters provided, cancels all pending orders</li> </ul> <p>Related to: order_close_delete.md</p> <p>Example 1: Cancel symbol-specific pendings</p> <pre><code>await sugar.cancel_pendings(symbol=\"GBPUSD\", magic=2002)\n</code></pre> <p>Example 2: Clean up before strategy switch</p> <pre><code># Switching from breakout to range strategy\nlogger.info(\"Switching strategy - canceling all pending orders\")\nawait sugar.cancel_pendings(magic=1001)\n\n# Now place new range-bound orders\nawait sugar.buy_limit(\"EURUSD\", lots=0.1, price=1.0900)\nawait sugar.sell_limit(\"EURUSD\", lots=0.1, price=1.1100)\n</code></pre> <p>Example 3: Cancel unfilled orders after timeout</p> <pre><code># Place limit orders\ntickets = []\nfor price in [1.0900, 1.0850, 1.0800]:\n    ticket = await sugar.buy_limit(\"EURUSD\", lots=0.1, price=price)\n    tickets.append(ticket)\n\n# Wait 1 hour\nawait asyncio.sleep(3600)\n\n# Cancel any unfilled orders\nawait sugar.cancel_pendings(symbol=\"EURUSD\", magic=1001)\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/","title":"Order Placement","text":""},{"location":"MT4Sugar/Order_Placement/#async-buy_marketsymbol-lots-sl_pipsnone-tp_pipsnone-commentnone","title":"\ud83d\udfe2 <code>async buy_market(symbol, lots, *, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Opens a BUY market order with the specified lot size. Optionally sets SL/TP in pips.</p> <p>Used in:</p> <ul> <li>Core trading scenarios for immediate execution.</li> <li>Fast entries at current market price.</li> <li>Breakout strategies when price crosses key levels.</li> <li>Momentum trading and trend following.</li> </ul> <p>Parameters:</p> <ul> <li><code>symbol</code> - Trading symbol (e.g., \"EURUSD\")</li> <li><code>lots</code> - Position size in lots</li> <li><code>sl_pips</code> - (Optional) Stop Loss in pips from entry</li> <li><code>tp_pips</code> - (Optional) Take Profit in pips from entry</li> <li><code>comment</code> - (Optional) Order comment for identification</li> </ul> <p>Returns: Order ticket number (integer)</p> <p>Related to: order_send.md</p> <p>Example 1: Basic market buy</p> <pre><code>await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40, comment=\"scalp entry\")\n</code></pre> <p>Example 2: Buy with risk-based lot sizing</p> <pre><code># Calculate lot size for 2% risk\nlots = await sugar.calc_lot_by_risk(\"EURUSD\", stop_pips=20, risk_percent=2.0)\n\n# Execute market buy\nticket = await sugar.buy_market(\"EURUSD\", lots=lots, sl_pips=20, tp_pips=60)\nprint(f\"Order opened: {ticket}\")\n</code></pre> <p>Example 3: Conditional entry on breakout</p> <pre><code># Wait for price to break resistance\nresistance = 1.1000\nreached = await sugar.wait_price(\"EURUSD\", target=resistance, direction=\"&gt;=\", timeout_s=300)\n\nif reached:\n    # Breakout confirmed - enter long\n    ticket = await sugar.buy_market(\n        \"EURUSD\",\n        lots=0.2,\n        sl_pips=15,\n        tp_pips=45,\n        comment=\"Resistance breakout\"\n    )\n</code></pre> <p>Example 4: Multiple orders with different parameters</p> <pre><code># Scalp trade\nticket1 = await sugar.buy_market(\"EURUSD\", lots=0.1, sl_pips=10, tp_pips=15, comment=\"Scalp\")\n\n# Swing trade\nticket2 = await sugar.buy_market(\"EURUSD\", lots=0.05, sl_pips=50, tp_pips=150, comment=\"Swing\")\n\n# Position trade (no TP - let it run)\nticket3 = await sugar.buy_market(\"EURUSD\", lots=0.03, sl_pips=100, comment=\"Position\")\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/#async-sell_marketsymbol-lots-sl_pipsnone-tp_pipsnone-commentnone","title":"\ud83d\udd34 <code>async sell_market(symbol, lots, *, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Opens a SELL market order.</p> <p>Used in:</p> <ul> <li>Same usage as <code>buy_market</code>, but in the opposite direction.</li> <li>Short selling, range trading, mean reversion strategies.</li> <li>Hedging existing long positions.</li> </ul> <p>Parameters:  Same as <code>buy_market</code></p> <p>Returns: Order ticket number (integer)</p> <p>Related to: order_send.md</p> <p>Example 1: Basic market sell</p> <pre><code>await sugar.sell_market(\"EURUSD\", lots=0.1, sl_pips=20, tp_pips=40)\n</code></pre> <p>Example 2: Sell on resistance rejection</p> <pre><code># Price rejected resistance - go short\nif price_rejected_resistance():\n    ticket = await sugar.sell_market(\n        \"EURUSD\",\n        lots=0.15,\n        sl_pips=25,\n        tp_pips=75,\n        comment=\"Resistance rejection\"\n    )\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/#async-buy_limitsymbol-lots-price-sl_pipsnone-tp_pipsnone-commentnone","title":"\ud83e\uddf1 <code>async buy_limit(symbol, lots, price, *, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Places a BUY LIMIT pending order at the given price (below current market).</p> <p>Used in:</p> <ul> <li>Pending entries below the current market.</li> <li>Buy\u2011the\u2011dip or limit\u2011reversal strategies.</li> <li>Support level entries.</li> </ul> <p>Parameters:</p> <ul> <li><code>price</code> - Order entry price (must be below current Ask for buy limit)</li> <li>Other parameters same as <code>buy_market</code></li> </ul> <p>Returns: Order ticket number (integer)</p> <p>Related to: order_send.md, order_modify.md</p> <p>Example 1: Buy at support level</p> <pre><code>await sugar.buy_limit(\"EURUSD\", lots=0.2, price=1.0850, sl_pips=25, tp_pips=50)\n</code></pre> <p>Example 2: Multiple limit orders (grid/ladder)</p> <pre><code># Place buy limits at multiple support levels\nsupport_levels = [1.0900, 1.0850, 1.0800]\n\nfor level in support_levels:\n    ticket = await sugar.buy_limit(\n        \"EURUSD\",\n        lots=0.1,\n        price=level,\n        sl_pips=30,\n        tp_pips=60,\n        comment=f\"Support {level}\"\n    )\n    print(f\"Buy limit placed at {level}: {ticket}\")\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/#async-sell_limitsymbol-lots-price-sl_pipsnone-tp_pipsnone-commentnone","title":"\ud83e\uddf1 <code>async sell_limit(symbol, lots, price, *, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Places a SELL LIMIT pending order above the current price.</p> <p>Used in:</p> <ul> <li>Entries on pullbacks to resistance levels.</li> <li>Selling at overbought conditions.</li> </ul> <p>Parameters: Same as <code>buy_limit</code></p> <p>Returns: Order ticket number (integer)</p> <p>Related to: order_send.md</p> <p>Example 1: Sell at resistance</p> <pre><code>await sugar.sell_limit(\"EURUSD\", lots=0.2, price=1.1150, sl_pips=25, tp_pips=50)\n</code></pre> <p>Example 2: Resistance zone ladder</p> <pre><code># Place sells across resistance zone\nresistance_zone = [1.1100, 1.1120, 1.1150]\n\nfor level in resistance_zone:\n    await sugar.sell_limit(\"EURUSD\", lots=0.05, price=level, sl_pips=20, tp_pips=40)\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/#async-buy_stopsymbol-lots-price-sl_pipsnone-tp_pipsnone-commentnone","title":"\ud83e\udde8 <code>async buy_stop(symbol, lots, price, *, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Places a BUY STOP order above the current price to enter on breakout.</p> <p>Used in:</p> <ul> <li>Breakout and momentum strategies.</li> <li>Entering on upside price confirmation.</li> </ul> <p>Parameters: Same as <code>buy_limit</code> but price must be above current Ask</p> <p>Returns: Order ticket number (integer)</p> <p>Related to: order_send.md</p> <p>Example 1: Breakout entry</p> <pre><code>await sugar.buy_stop(\"GBPUSD\", lots=0.1, price=1.2800, sl_pips=30, tp_pips=60)\n</code></pre> <p>Example 2: Range breakout with OCO</p> <pre><code># Place both buy stop (upside) and sell stop (downside)\ncurrent_price = (await sugar.last_quote(\"EURUSD\"))[\"bid\"]\n\n# Buy stop above range\nbuy_ticket = await sugar.buy_stop(\"EURUSD\", lots=0.1, price=current_price + 0.0050, sl_pips=20)\n\n# Sell stop below range\nsell_ticket = await sugar.sell_stop(\"EURUSD\", lots=0.1, price=current_price - 0.0050, sl_pips=20)\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/#async-sell_stopsymbol-lots-price-sl_pipsnone-tp_pipsnone-commentnone","title":"\ud83e\udde8 <code>async sell_stop(symbol, lots, price, *, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Places a SELL STOP order below the current price to enter on downside breakout.</p> <p>Used in:</p> <ul> <li>Breakout strategies and continuation trades.</li> <li>Entering short on downside confirmation.</li> </ul> <p>Parameters: Same as <code>sell_limit</code> but price must be below current Bid</p> <p>Returns: Order ticket number (integer)</p> <p>Related to: order_send.md</p> <p>Example 1: Downside breakout</p> <pre><code>await sugar.sell_stop(\"GBPUSD\", lots=0.1, price=1.2700, sl_pips=30, tp_pips=60)\n</code></pre> <p>Example 2: Support break entry</p> <pre><code># Enter short if support breaks\nsupport = 1.0950\nticket = await sugar.sell_stop(\"EURUSD\", lots=0.15, price=support - 0.0010, sl_pips=25, tp_pips=75, comment=\"Support break\")\n</code></pre>"},{"location":"MT4Sugar/Order_Placement/#async-place_ordersymbol-side-order_type-lots-pricenone-sl_pipsnone-tp_pipsnone-commentnone","title":"\u2699\ufe0f <code>async place_order(symbol, side, order_type, lots, *, price=None, sl_pips=None, tp_pips=None, comment=None)</code>","text":"<p>What it does: Generic order placement method \u2014 supports both market and pending orders.</p> <p>Used in:</p> <ul> <li>Strategies that dynamically choose order type and direction.</li> <li>Universal trading templates and deal generators.</li> </ul> <p>Related to: order_send.md</p> <p>Example</p> <pre><code>await sugar.place_order(\n    symbol=\"EURUSD\",\n    side=\"buy\",\n    order_type=\"limit\",\n    lots=0.2,\n    price=1.0900,\n    sl_pips=20,\n    tp_pips=40,\n)\n</code></pre>"},{"location":"MT4Sugar/Overview/","title":"\ud83c\udf6c Sugar API - Overview","text":"<p>Welcome to the Sugar API! This is PyMT4's high-level interface that wraps raw RPC calls into readable, pip-based operations with sane defaults.</p>"},{"location":"MT4Sugar/Overview/#what-is-sugar-api","title":"\ud83c\udfaf What is Sugar API?","text":"<p>The Sugar API is designed to make your trading code: - \u2705 Readable - Methods named like <code>buy_market()</code>, <code>calc_lot_by_risk()</code>, <code>spread_pips()</code> - \u2705 Pip-based - Work with pips instead of raw price values - \u2705 Smart defaults - Set symbol/magic once, use everywhere - \u2705 Less boilerplate - Auto-normalization, auto-reconnect, auto-symbol-enable - \u2705 Production-ready - Error handling, retries, validation built-in</p>"},{"location":"MT4Sugar/Overview/#sugar-vs-low-level","title":"Sugar vs Low-Level","text":"Aspect Sugar API Low-Level API Syntax <code>await sugar.buy_market(\"EURUSD\", 0.1, sl_pips=20)</code> <code>await api.order_send(symbol=\"EURUSD\", cmd=0, volume=0.1, price=quote.ask, sl=price-20*pip)</code> Defaults Uses stored defaults Every parameter explicit Pips Native pip support Manual price calculations Readability High Medium Control Simplified Complete Best for Rapid development Fine-tuned optimization"},{"location":"MT4Sugar/Overview/#api-categories","title":"\ud83d\udcda API Categories","text":"<p>The Sugar API is organized into 7 functional categories:</p> Category Methods Purpose Core &amp; Defaults 4 methods Connection, defaults management Symbols &amp; Quotes 8 methods Symbol info, quotes, prices Market Data 3 methods Bars, ticks, price waiting Order Placement 6 methods Market and pending orders Order Management 5 methods Modify, close, partial close Math &amp; Risk 8 methods Lot sizing, risk calculation, conversions Automation 2 methods Trailing stops, auto-breakeven <p>Total: 36 sugar methods to cover all your trading needs!</p>"},{"location":"MT4Sugar/Overview/#core-defaults","title":"\ud83d\udd0c Core &amp; Defaults","text":"<p>\u2192 Full Documentation</p> <p>Foundation methods for connection and configuration management.</p>"},{"location":"MT4Sugar/Overview/#methods-overview","title":"Methods Overview","text":"Method Purpose Use Case <code>ensure_connected()</code> Auto-reconnect if lost Before market operations <code>ping()</code> Health check Monitoring loops <code>get_default(key)</code> Read stored default Logic/logging <code>set_defaults(...)</code> Configure defaults Setup phase"},{"location":"MT4Sugar/Overview/#quick-example","title":"Quick Example","text":"<pre><code># Set defaults once\nsugar.set_defaults(\n    symbol=\"EURUSD\",\n    magic=1001,\n    deviation_pips=3\n)\n\n# Use everywhere without repeating\nawait sugar.buy_market(lots=0.1)  # Uses EURUSD, magic=1001\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use","title":"When to use","text":"<p>\u2705 Start of every script - set defaults \u2705 Before long operations - ensure connection \u2705 Monitoring systems - ping for health checks</p>"},{"location":"MT4Sugar/Overview/#symbols-quotes","title":"\ud83d\udcc8 Symbols &amp; Quotes","text":"<p>\u2192 Full Documentation</p> <p>Get symbol information and current market prices.</p>"},{"location":"MT4Sugar/Overview/#methods-overview_1","title":"Methods Overview","text":"Method Returns Use Case <code>digits(symbol)</code> Decimal places Price formatting <code>point(symbol)</code> Minimum tick Normalization <code>pip_size(symbol)</code> Pip value Pip calculations <code>ensure_symbol(symbol)</code> None Before trading <code>last_quote(symbol)</code> Quote object Current price <code>mid_price(symbol)</code> Float Fair price <code>spread_pips(symbol)</code> Float Cost check <code>spread_points(symbol)</code> Int Raw spread"},{"location":"MT4Sugar/Overview/#quick-example_1","title":"Quick Example","text":"<pre><code># Check spread before trading\nspread = await sugar.spread_pips(\"EURUSD\")\nif spread &lt; 2.0:\n    await sugar.buy_market(\"EURUSD\", 0.1)\n\n# Get current prices\nquote = await sugar.last_quote(\"EURUSD\")\nprint(f\"Bid: {quote.bid}, Ask: {quote.ask}\")\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use_1","title":"When to use","text":"<p>\u2705 Before order placement - check spread \u2705 Symbol validation - ensure symbol exists \u2705 Price formatting - use digits/point \u2705 Analytics - mid_price for fair value</p>"},{"location":"MT4Sugar/Overview/#market-data","title":"\ud83d\udcca Market Data","text":"<p>\u2192 Full Documentation</p> <p>Historical data and price monitoring.</p>"},{"location":"MT4Sugar/Overview/#methods-overview_2","title":"Methods Overview","text":"Method Returns Use Case <code>bars(symbol, tf, count)</code> OHLC bars Technical analysis <code>ticks(symbol, limit)</code> Tick data HFT, custom bars <code>wait_price(symbol, target)</code> Boolean Price alerts"},{"location":"MT4Sugar/Overview/#quick-example_2","title":"Quick Example","text":"<pre><code># Get last 100 H1 bars\nbars = await sugar.bars(\"EURUSD\", timeframe=\"H1\", count=100)\ncloses = [b.close for b in bars]\n\n# Wait for price to reach level\nreached = await sugar.wait_price(\"EURUSD\", target=1.1000, direction=\"&gt;=\", timeout_s=60)\nif reached:\n    await sugar.sell_market(\"EURUSD\", 0.1)\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use_2","title":"When to use","text":"<p>\u2705 Indicators - calculate from bars \u2705 Backtesting - historical data analysis \u2705 Price alerts - wait for specific levels \u2705 HFT strategies - tick-level data</p>"},{"location":"MT4Sugar/Overview/#order-placement","title":"\ud83c\udfaf Order Placement","text":"<p>\u2192 Full Documentation</p> <p>Open market and pending orders.</p>"},{"location":"MT4Sugar/Overview/#methods-overview_3","title":"Methods Overview","text":"Method Order Type Use Case <code>buy_market(...)</code> Market BUY Immediate long entry <code>sell_market(...)</code> Market SELL Immediate short entry <code>buy_limit(...)</code> Pending BUY LIMIT Buy below market <code>sell_limit(...)</code> Pending SELL LIMIT Sell above market <code>buy_stop(...)</code> Pending BUY STOP Breakout long <code>sell_stop(...)</code> Pending SELL STOP Breakout short"},{"location":"MT4Sugar/Overview/#quick-example_3","title":"Quick Example","text":"<pre><code># Market order with SL/TP in pips\nticket = await sugar.buy_market(\n    symbol=\"EURUSD\",\n    lots=0.1,\n    sl_pips=20,\n    tp_pips=40,\n    comment=\"Scalp trade\"\n)\n\n# Pending order at specific price\nticket = await sugar.buy_limit(\n    symbol=\"EURUSD\",\n    lots=0.1,\n    price=1.0950,\n    sl_pips=15,\n    tp_pips=30\n)\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use_3","title":"When to use","text":"<p>\u2705 Strategy entries - market/pending orders \u2705 Quick trades - minimal parameters \u2705 SL/TP in pips - easy risk management \u2705 Comments - track trade reasons</p>"},{"location":"MT4Sugar/Overview/#order-management","title":"\u270f\ufe0f Order Management","text":"<p>\u2192 Full Documentation</p> <p>Modify and close existing positions.</p>"},{"location":"MT4Sugar/Overview/#methods-overview_4","title":"Methods Overview","text":"Method Action Use Case <code>modify_sl_tp_by_pips(...)</code> Modify by pips Adjust protection <code>modify_sl_tp_by_price(...)</code> Modify by price Exact levels <code>close(ticket)</code> Close position Exit trade <code>close_partial(ticket, lots)</code> Partial close Scale out <code>close_all(symbol, magic)</code> Close multiple Emergency exit"},{"location":"MT4Sugar/Overview/#quick-example_4","title":"Quick Example","text":"<pre><code># Move SL to breakeven\nawait sugar.modify_sl_tp_by_pips(ticket=123456, sl_pips=0)\n\n# Tighten SL by price\nawait sugar.modify_sl_tp_by_price(ticket=123456, sl_price=1.0985)\n\n# Partial close - take 50% profit\nawait sugar.close_partial(ticket=123456, lots=0.05)\n\n# Close all EURUSD positions\nawait sugar.close_all(symbol=\"EURUSD\")\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use_4","title":"When to use","text":"<p>\u2705 Trailing stops - manual or automated \u2705 Scaling out - partial closes \u2705 Emergency exits - close_all \u2705 Breakeven moves - modify SL</p>"},{"location":"MT4Sugar/Overview/#math-risk","title":"\ud83e\uddee Math &amp; Risk","text":"<p>\u2192 Full Documentation</p> <p>Position sizing, risk calculation, and conversions.</p>"},{"location":"MT4Sugar/Overview/#methods-overview_5","title":"Methods Overview","text":"Method Returns Use Case <code>calc_lot_by_risk(symbol, stop_pips, risk_pct)</code> Float Position sizing <code>calc_cash_risk(symbol, lots, stop_pips)</code> Float Risk calculation <code>pips_to_price(symbol, pips, direction)</code> Float Convert pips\u2192price <code>price_to_pips(symbol, price1, price2)</code> Float Convert price\u2192pips <code>normalize_price(symbol, price)</code> Float Round to tick <code>normalize_lots(symbol, lots)</code> Float Valid lot size <code>breakeven_price(entry, commission, swap)</code> Float Breakeven level <code>auto_breakeven(ticket, trigger_pips)</code> None Auto SL move"},{"location":"MT4Sugar/Overview/#quick-example_5","title":"Quick Example","text":"<pre><code># Calculate lot size for 2% risk\nlots = await sugar.calc_lot_by_risk(\n    symbol=\"EURUSD\",\n    stop_pips=20,\n    risk_percent=2.0\n)\nprint(f\"Trade {lots} lots for 2% risk\")\n\n# Convert 20 pips to price distance\nprice_dist = await sugar.pips_to_price(\"EURUSD\", pips=20, direction=\"buy\")\n\n# Auto-move to breakeven after 15 pips profit\nawait sugar.auto_breakeven(ticket=123456, trigger_pips=15, plus_pips=1.0)\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use_5","title":"When to use","text":"<p>\u2705 Every trade - calculate proper lot size \u2705 Risk management - validate exposure \u2705 Price conversions - pip\u2194price \u2705 Normalization - ensure valid values \u2705 Automation - auto-breakeven</p>"},{"location":"MT4Sugar/Overview/#automation","title":"\ud83e\udd16 Automation","text":"<p>\u2192 Full Documentation</p> <p>Automated trade management.</p>"},{"location":"MT4Sugar/Overview/#methods-overview_6","title":"Methods Overview","text":"Method Action Use Case <code>set_trailing_stop(ticket, distance_pips)</code> Start trailing Let winners run <code>unset_trailing_stop(subscription_id)</code> Stop trailing Pause automation"},{"location":"MT4Sugar/Overview/#quick-example_6","title":"Quick Example","text":"<pre><code># Open position\nticket = await sugar.buy_market(\"EURUSD\", 0.1, sl_pips=20)\n\n# Enable trailing stop - 15 pips behind price\ntrail_id = await sugar.set_trailing_stop(\n    ticket=ticket,\n    distance_pips=15,\n    step_pips=2  # Update every 2 pips\n)\n\n# Later: disable trailing\nawait sugar.unset_trailing_stop(trail_id)\n</code></pre>"},{"location":"MT4Sugar/Overview/#when-to-use_6","title":"When to use","text":"<p>\u2705 Trend following - trail behind price \u2705 Breakouts - protect running profits \u2705 Hands-free trading - automated management</p>"},{"location":"MT4Sugar/Overview/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"MT4Sugar/Overview/#1-import-and-initialize","title":"1. Import and Initialize","text":"<pre><code>from pymt4 import MT4Account\nfrom pymt4.sugar import Sugar\n\n# Connect to MT4\napi = MT4Account(host=\"localhost\", port=15555)\nawait api.connect()\n\n# Create sugar instance\nsugar = Sugar(api)\n</code></pre>"},{"location":"MT4Sugar/Overview/#2-set-defaults","title":"2. Set Defaults","text":"<pre><code># Configure once, use everywhere\nsugar.set_defaults(\n    symbol=\"EURUSD\",\n    magic=1001,\n    deviation_pips=3,\n    risk_percent=2.0\n)\n</code></pre>"},{"location":"MT4Sugar/Overview/#3-start-trading","title":"3. Start Trading","text":"<pre><code># Simple market order\nticket = await sugar.buy_market(lots=0.1, sl_pips=20, tp_pips=40)\n\n# Check spread first\nspread = await sugar.spread_pips()\nif spread &lt; 2.0:\n    # Calculate lot size by risk\n    lots = await sugar.calc_lot_by_risk(stop_pips=20, risk_percent=2.0)\n    ticket = await sugar.buy_market(lots=lots, sl_pips=20)\n</code></pre>"},{"location":"MT4Sugar/Overview/#complete-method-index","title":"\ud83d\udcd6 Complete Method Index","text":""},{"location":"MT4Sugar/Overview/#core-4-methods","title":"Core (4 methods)","text":"<ul> <li><code>ensure_connected()</code> - Auto-reconnect</li> <li><code>ping()</code> - Health check</li> <li><code>get_default(key)</code> - Read default</li> <li><code>set_defaults(...)</code> - Configure defaults</li> </ul>"},{"location":"MT4Sugar/Overview/#symbols-quotes-8-methods","title":"Symbols &amp; Quotes (8 methods)","text":"<ul> <li><code>digits(symbol)</code> - Decimal places</li> <li><code>point(symbol)</code> - Minimum tick</li> <li><code>pip_size(symbol)</code> - Pip value</li> <li><code>ensure_symbol(symbol)</code> - Enable symbol</li> <li><code>last_quote(symbol)</code> - Current quote</li> <li><code>mid_price(symbol)</code> - Mid price</li> <li><code>spread_pips(symbol)</code> - Spread in pips</li> <li><code>spread_points(symbol)</code> - Spread in points</li> </ul>"},{"location":"MT4Sugar/Overview/#market-data-3-methods","title":"Market Data (3 methods)","text":"<ul> <li><code>bars(symbol, tf, count)</code> - OHLC data</li> <li><code>ticks(symbol, limit)</code> - Tick data</li> <li><code>wait_price(symbol, target)</code> - Price alert</li> </ul>"},{"location":"MT4Sugar/Overview/#order-placement-6-methods","title":"Order Placement (6 methods)","text":"<ul> <li><code>buy_market(...)</code> - Market BUY</li> <li><code>sell_market(...)</code> - Market SELL</li> <li><code>buy_limit(...)</code> - Pending BUY LIMIT</li> <li><code>sell_limit(...)</code> - Pending SELL LIMIT</li> <li><code>buy_stop(...)</code> - Pending BUY STOP</li> <li><code>sell_stop(...)</code> - Pending SELL STOP</li> </ul>"},{"location":"MT4Sugar/Overview/#order-management-5-methods","title":"Order Management (5 methods)","text":"<ul> <li><code>modify_sl_tp_by_pips(...)</code> - Modify by pips</li> <li><code>modify_sl_tp_by_price(...)</code> - Modify by price</li> <li><code>close(ticket)</code> - Close position</li> <li><code>close_partial(ticket, lots)</code> - Partial close</li> <li><code>close_all(symbol, magic)</code> - Close multiple</li> </ul>"},{"location":"MT4Sugar/Overview/#math-risk-8-methods","title":"Math &amp; Risk (8 methods)","text":"<ul> <li><code>calc_lot_by_risk(...)</code> - Position sizing</li> <li><code>calc_cash_risk(...)</code> - Risk calculation</li> <li><code>pips_to_price(...)</code> - Pips\u2192Price</li> <li><code>price_to_pips(...)</code> - Price\u2192Pips</li> <li><code>normalize_price(...)</code> - Round price</li> <li><code>normalize_lots(...)</code> - Valid lots</li> <li><code>breakeven_price(...)</code> - Breakeven calc</li> <li><code>auto_breakeven(...)</code> - Auto SL move</li> </ul>"},{"location":"MT4Sugar/Overview/#automation-2-methods","title":"Automation (2 methods)","text":"<ul> <li><code>set_trailing_stop(...)</code> - Enable trailing</li> <li><code>unset_trailing_stop(...)</code> - Disable trailing</li> </ul>"},{"location":"MT4Sugar/Overview/#best-practices","title":"\ud83d\udca1 Best Practices","text":""},{"location":"MT4Sugar/Overview/#1-always-set-defaults","title":"1. Always Set Defaults","text":"<pre><code># Do this at startup\nsugar.set_defaults(symbol=\"EURUSD\", magic=1001)\n</code></pre>"},{"location":"MT4Sugar/Overview/#2-check-spread-before-trading","title":"2. Check Spread Before Trading","text":"<pre><code>spread = await sugar.spread_pips()\nif spread &gt; MAX_SPREAD:\n    return  # Skip trade\n</code></pre>"},{"location":"MT4Sugar/Overview/#3-calculate-lot-size-by-risk","title":"3. Calculate Lot Size by Risk","text":"<pre><code>lots = await sugar.calc_lot_by_risk(stop_pips=20, risk_percent=2.0)\n</code></pre>"},{"location":"MT4Sugar/Overview/#4-normalize-everything","title":"4. Normalize Everything","text":"<pre><code>price = sugar.normalize_price(\"EURUSD\", 1.095678)  # \u2192 1.09568\nlots = sugar.normalize_lots(\"EURUSD\", 0.123)       # \u2192 0.12\n</code></pre>"},{"location":"MT4Sugar/Overview/#5-use-context-overrides-for-multi-symbol","title":"5. Use Context Overrides for Multi-Symbol","text":"<pre><code># Default: EURUSD\nsugar.set_defaults(symbol=\"EURUSD\")\n\n# Trade other symbol temporarily\nwith sugar.with_defaults(symbol=\"GBPUSD\"):\n    await sugar.buy_market(lots=0.1)\n</code></pre> <p>Happy Trading with Sugar! \ud83d\udcc8</p>"},{"location":"MT4Sugar/Symbols_Quotes/","title":"Symbols &amp; Quotes","text":""},{"location":"MT4Sugar/Symbols_Quotes/#digitssymbolnone","title":"\ud83d\udcc8 <code>digits(symbol=None)</code>","text":"<p>What it does: Returns the number of decimal places for a symbol.</p> <p>Used in: * Price formatting and display * Level normalization and rounding * SL/TP calculations * Determining price precision requirements</p> <p>Parameters: * <code>symbol</code> - (Optional) Trading symbol. If None, uses default symbol.</p> <p>Returns: Number of decimal places (int)</p> <p>Important notes: * EURUSD, GBPUSD: typically 5 digits (1.09567) * USDJPY: typically 3 digits (150.123) * Gold (XAUUSD): typically 2 digits (1850.25)</p> <p>Related to: symbol_params_many.md (symbol parameters)</p> <p>Example 1: Get digits for formatting</p> <pre><code>d = sugar.digits(\"EURUSD\")  # -&gt; 5\nprint(f\"Price: {price:.{d}f}\")  # Format with correct decimals\n</code></pre> <p>Example 2: Multi-symbol display</p> <pre><code>symbols = [\"EURUSD\", \"USDJPY\", \"XAUUSD\"]\nfor sym in symbols:\n    digits = await sugar.digits(sym)\n    quote = await sugar.last_quote(sym)\n    print(f\"{sym}: {quote['bid']:.{digits}f}\")\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#ensure_symbolsymbol","title":"\ud83e\udde9 <code>ensure_symbol(symbol)</code>","text":"<p>What it does: Ensures the symbol is available in the terminal (loaded/enabled). Used in: before quotes/orders, during strategy initialization. Related to: symbols.md (symbol list and availability)</p> <p>Example</p> <pre><code>sugar.ensure_symbol(\"EURUSD\")\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#last_quotesymbolnone","title":"\ud83d\udcac <code>last_quote(symbol=None)</code>","text":"<p>What it does: Returns the latest quote (bid/ask/time) for the symbol.</p> <p>Used in: * Logging and diagnostics * Fetching current price before order placement * Real-time price monitoring * Spread analysis</p> <p>Parameters: * <code>symbol</code> - (Optional) Trading symbol. If None, uses default symbol.</p> <p>Returns: Dictionary with keys: <code>bid</code>, <code>ask</code>, <code>time</code></p> <p>Related to: quote.md (single quote)</p> <p>Example 1: Get current price</p> <pre><code>q = await sugar.last_quote(\"EURUSD\")\nprint(f\"Bid: {q['bid']}, Ask: {q['ask']}, Time: {q['time']}\")\n</code></pre> <p>Example 2: Check spread before trading</p> <pre><code>quote = await sugar.last_quote(\"EURUSD\")\nspread = quote[\"ask\"] - quote[\"bid\"]\npip_size = await sugar.pip_size(\"EURUSD\")\nspread_pips = spread / pip_size\n\nif spread_pips &lt; 2.0:\n    await sugar.buy_market(\"EURUSD\", lots=0.1)\nelse:\n    logger.warning(f\"Spread too high: {spread_pips:.1f} pips\")\n</code></pre> <p>Example 3: Price logging loop</p> <pre><code>while True:\n    quote = await sugar.last_quote(\"EURUSD\")\n    logger.info(f\"EURUSD: {quote['bid']}/{quote['ask']}\")\n    await asyncio.sleep(5)\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#mid_pricesymbolnone","title":"\u2696\ufe0f <code>mid_price(symbol=None)</code>","text":"<p>What it does: Returns the mid price = (bid + ask) / 2. Used in: analytics without spread bias, fair price estimation. Related to: quote.md (bid/ask base fields)</p> <p>Example</p> <pre><code>m = sugar.mid_price(\"EURUSD\")\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#pip_sizesymbolnone","title":"\ud83d\udccf <code>pip_size(symbol=None)</code>","text":"<p>What it does: Returns the pip size for the symbol. Used in: converting pips to price and back, SL/TP and risk calculations. Related to: tick_value_with_size.md (tick size/value)</p> <p>Example</p> <pre><code>pip = sugar.pip_size(\"EURUSD\")  # -&gt; 0.0001 for most majors\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#pointsymbolnone","title":"\ud83c\udfaf <code>point(symbol=None)</code>","text":"<p>What it does: Returns the smallest possible price increment (point). Often equals <code>pip_size / 10</code> depending on the broker. Used in: price rounding, normalization, internal calculations. Related to: symbol_params_many.md (symbol parameters)</p> <p>Example</p> <pre><code>pt = sugar.point(\"EURUSD\")\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#quotessymbols-liststr-none-none","title":"\ud83d\udcca <code>quotes(symbols: list[str] | None = None)</code>","text":"<p>What it does: Retrieves quotes for multiple symbols in a single call (or all active ones if None).</p> <p>Used in: * Bulk data refresh and dashboards * Pre-decision analytics * Multi-symbol monitoring * Portfolio analysis</p> <p>Parameters: * <code>symbols</code> - (Optional) List of symbol names. If None, returns all active symbols.</p> <p>Returns: Dictionary mapping symbol names to quote dicts: <code>{\"EURUSD\": {\"bid\": 1.09, \"ask\": 1.091, \"time\": ...}, ...}</code></p> <p>Important notes: * More efficient than calling <code>last_quote()</code> multiple times * Returns dict, not list * Useful for dashboards and monitoring systems</p> <p>Related to: quote_many.md (multi-quote)</p> <p>Example 1: Get multiple quotes</p> <pre><code>quotes_dict = await sugar.quotes([\"EURUSD\", \"GBPUSD\", \"USDJPY\"])\nfor symbol, quote in quotes_dict.items():\n    print(f\"{symbol}: Bid={quote['bid']}, Ask={quote['ask']}\")\n</code></pre> <p>Example 2: Trading dashboard</p> <pre><code>async def show_dashboard():\n    \"\"\"Display real-time trading dashboard\"\"\"\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n\n    while True:\n        quotes = await sugar.quotes(symbols)\n\n        print(\"\\n===== TRADING DASHBOARD =====\")\n        for sym in symbols:\n            q = quotes.get(sym)\n            if q:\n                spread = q[\"ask\"] - q[\"bid\"]\n                pip_size = await sugar.pip_size(sym)\n                spread_pips = spread / pip_size\n                print(f\"{sym:8} | Bid: {q['bid']:8.5f} | Ask: {q['ask']:8.5f} | Spread: {spread_pips:.1f} pips\")\n\n        await asyncio.sleep(2)\n</code></pre> <p>Example 3: Correlation analysis</p> <pre><code># Monitor correlated pairs\ncorrelated_pairs = [\"EURUSD\", \"GBPUSD\", \"EURGBP\"]\nquotes = await sugar.quotes(correlated_pairs)\n\n# Calculate mid prices\nmids = {sym: (q[\"bid\"] + q[\"ask\"]) / 2 for sym, q in quotes.items()}\n\n# Check if correlation holds\neurusd_gbpusd_ratio = mids[\"EURUSD\"] / mids[\"GBPUSD\"]\neurgbp_price = mids[\"EURGBP\"]\n\nprint(f\"EURUSD/GBPUSD ratio: {eurusd_gbpusd_ratio:.5f}\")\nprint(f\"EURGBP price: {eurgbp_price:.5f}\")\nprint(f\"Correlation delta: {abs(eurusd_gbpusd_ratio - eurgbp_price):.5f}\")\n</code></pre>"},{"location":"MT4Sugar/Symbols_Quotes/#spread_pipssymbolnone","title":"\ud83d\udcb8 <code>spread_pips(symbol=None)</code>","text":"<p>What it does: Returns the current spread in pips for the symbol.</p> <p>Used in: * Market quality filters and trade entry conditions * Spread alerts and monitoring * Cost analysis and optimization * Broker comparison</p> <p>Parameters: * <code>symbol</code> - (Optional) Trading symbol. If None, uses default symbol.</p> <p>Returns: Current spread in pips (float)</p> <p>Important notes: * Low spread: &lt; 1.5 pips (good for scalping) * Normal spread: 1.5-3 pips * High spread: &gt; 3 pips (avoid trading) * Spread increases during news and low liquidity periods</p> <p>Related to: quote.md (bid/ask source)</p> <p>Example 1: Check spread</p> <pre><code>sp = await sugar.spread_pips(\"EURUSD\")\nprint(f\"Spread: {sp:.1f} pips\")\n</code></pre> <p>Example 2: Spread filter for entries</p> <pre><code># Only trade when spread is acceptable\nspread = await sugar.spread_pips(\"EURUSD\")\n\nif spread &lt; 2.0:\n    await sugar.buy_market(\"EURUSD\", lots=0.1)\nelse:\n    logger.warning(f\"Spread too high: {spread:.1f} pips - skipping trade\")\n</code></pre> <p>Example 3: Monitor spread across multiple symbols</p> <pre><code>symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n\nwhile True:\n    print(\"\\n=== Spread Monitor ===\")\n    for symbol in symbols:\n        spread = await sugar.spread_pips(symbol)\n        status = \"GOOD\" if spread &lt; 2.0 else \"HIGH\"\n        print(f\"{symbol}: {spread:.1f} pips [{status}]\")\n\n    await asyncio.sleep(10)\n</code></pre> <p>Example 4: Spread alert system</p> <pre><code>MAX_SPREAD = 3.0\n\nasync def monitor_spread(symbol):\n    while True:\n        spread = await sugar.spread_pips(symbol)\n        if spread &gt; MAX_SPREAD:\n            logger.error(f\"ALERT: {symbol} spread={spread:.1f} pips!\")\n            await send_alert(f\"High spread on {symbol}\")\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"Main/Overview/","title":"\ud83c\udfaf Main Demo Scripts - Overview","text":"<p>Welcome to the Main folder! This is your starting point for understanding how to use PyMT4 SDK through practical, runnable examples.</p>"},{"location":"Main/Overview/#whats-in-this-folder","title":"\ud83d\udcda What's in this folder?","text":"<p>This folder contains 4 demonstration scripts that showcase different aspects of the PyMT4 SDK:</p> Script Purpose Complexity Best For main_low_level.py Raw MT4 RPC calls \ud83d\udd34 Advanced Full control, learning internals main_sugar.py High-level Sugar API \ud83d\udfe2 Beginner Quick development, readable code main_streams.py Real-time streaming \ud83d\udfe1 Intermediate Live data, event-driven apps main_trade_mod.py Order modifications \ud83d\udfe1 Intermediate Trade management workflows"},{"location":"Main/Overview/#main_low_levelpy","title":"\ud83d\udd27 main_low_level.py","text":"<p>\u2192 Full Documentation</p>"},{"location":"Main/Overview/#what-it-does","title":"What it does","text":"<p>Demonstrates low-level MT4 SDK methods without any sugar wrappers. This is the raw RPC surface that gives you complete control over every operation.</p>"},{"location":"Main/Overview/#key-features","title":"Key Features","text":"<ul> <li>Direct access to all MT4 RPC methods</li> <li>Quote fetching (<code>quote</code>, <code>quote_many</code>, <code>quote_history</code>)</li> <li>Symbol management (<code>symbols</code>, <code>symbol_params_many</code>)</li> <li>Order operations (<code>order_send</code>, <code>order_modify</code>, <code>order_close_delete</code>)</li> <li>Streaming APIs (<code>on_symbol_tick</code>, <code>on_trade</code>, <code>on_opened_orders_tickets</code>)</li> <li>Account information (<code>account_summary</code>)</li> </ul>"},{"location":"Main/Overview/#when-to-use","title":"When to use","text":"<p>\u2705 When you need maximum control over every parameter \u2705 When building custom trading logic that doesn't fit sugar abstractions \u2705 When learning the SDK internals and understanding how things work under the hood \u2705 When optimizing performance by avoiding wrapper overhead</p>"},{"location":"Main/Overview/#example-output","title":"Example Output","text":""},{"location":"Main/Overview/#main_sugarpy","title":"\ud83c\udf6c main_sugar.py","text":"<p>\u2192 Full Documentation</p>"},{"location":"Main/Overview/#what-it-does_1","title":"What it does","text":"<p>Showcases high-level sugar methods that wrap low-level calls with sane defaults and readable syntax. Perfect for rapid development and quick prototyping.</p>"},{"location":"Main/Overview/#key-features_1","title":"Key Features","text":"<ul> <li>Simplified connectivity (<code>ensure_connected</code>, <code>ping</code>)</li> <li>Symbol helpers (<code>ensure_symbol</code>, <code>digits</code>, <code>point</code>, <code>pip_size</code>)</li> <li>Market calculations (<code>spread_pips</code>, <code>mid_price</code>, <code>calc_lot_by_risk</code>)</li> <li>Easy order placement (<code>buy_market</code>, <code>sell_market</code>, <code>buy_limit</code>)</li> <li>Quick modifications (<code>modify_sl_tp_by_pips</code>, <code>modify_sl_tp_by_price</code>)</li> <li>Batch operations (<code>close</code>, <code>close_all</code>)</li> </ul>"},{"location":"Main/Overview/#when-to-use_1","title":"When to use","text":"<p>\u2705 When you want fast development with minimal boilerplate \u2705 When readability is more important than fine-grained control \u2705 When building simple strategies without complex edge cases \u2705 When onboarding new developers who need quick wins \u2705 When prototyping ideas before optimizing</p>"},{"location":"Main/Overview/#example-output_1","title":"Example Output","text":""},{"location":"Main/Overview/#main_streamspy","title":"\ud83d\udce1 main_streams.py","text":"<p>\u2192 Full Documentation</p>"},{"location":"Main/Overview/#what-it-does_2","title":"What it does","text":"<p>Demonstrates server-streaming APIs for real-time subscriptions. Shows how to consume async streams and handle cooperative cancellation.</p>"},{"location":"Main/Overview/#key-features_2","title":"Key Features","text":"<ul> <li>Real-time tick streaming (<code>on_symbol_tick</code>)</li> <li>Trade event monitoring (<code>on_trade</code>)</li> <li>Order ticket updates (<code>on_opened_orders_tickets</code>)</li> <li>Profit/loss tracking (<code>on_opened_orders_profit</code>)</li> <li>Cooperative shutdown with cancellation events</li> <li>Back-pressure handling and debouncing</li> </ul>"},{"location":"Main/Overview/#when-to-use_2","title":"When to use","text":"<p>\u2705 When you need real-time market data without polling \u2705 When building event-driven applications that react to changes \u2705 When monitoring positions and need instant updates \u2705 When creating live dashboards or charting applications \u2705 When tracking P&amp;L in real-time</p>"},{"location":"Main/Overview/#example-output_2","title":"Example Output","text":""},{"location":"Main/Overview/#main_trade_modpy","title":"\u270f\ufe0f main_trade_mod.py","text":"<p>\u2192 Full Documentation</p>"},{"location":"Main/Overview/#what-it-does_3","title":"What it does","text":"<p>Focuses on trade modification flows: placing, modifying, and closing orders. Shows common sequences like <code>order_send \u2192 order_modify \u2192 order_close</code>.</p>"},{"location":"Main/Overview/#key-features_3","title":"Key Features","text":"<ul> <li>Market and pending order placement</li> <li>Stop-loss and take-profit modifications</li> <li>Partial position closing (<code>close_partial</code>)</li> <li>Position hedging (<code>close_by</code>)</li> <li>Order state verification (<code>opened_orders</code>)</li> <li>Price and lot normalization</li> </ul>"},{"location":"Main/Overview/#when-to-use_3","title":"When to use","text":"<p>\u2705 When building trade management systems \u2705 When implementing trailing stops or dynamic SL/TP \u2705 When scaling in/out of positions \u2705 When hedging positions with opposite orders \u2705 When testing order modification logic</p>"},{"location":"Main/Overview/#example-output_3","title":"Example Output","text":""},{"location":"Main/Overview/#quick-start-guide","title":"\ud83d\ude80 Quick Start Guide","text":""},{"location":"Main/Overview/#1-choose-your-starting-point","title":"1. Choose your starting point","text":"<p>New to PyMT4? \u2192 Start with main_sugar.py Need real-time data? \u2192 Check out main_streams.py Building trade logic? \u2192 Look at main_trade_mod.py Want full control? \u2192 Explore main_low_level.py</p>"},{"location":"Main/Overview/#2-run-the-script","title":"2. Run the script","text":"<pre><code># Make sure PyMT4 is installed\npip install PyMT4\n\n# Run any demo script\npython main_sugar.py\npython main_streams.py\npython main_low_level.py\npython main_trade_mod.py\n</code></pre>"},{"location":"Main/Overview/#3-modify-and-experiment","title":"3. Modify and experiment","text":"<p>All scripts are designed to be: - \u2705 Self-contained - Run without external dependencies - \u2705 Well-commented - Understand what each line does - \u2705 Easy to modify - Change symbols, lots, parameters - \u2705 Production-ready patterns - Use as templates for your own code</p>"},{"location":"Main/Overview/#learning-path","title":"\ud83c\udf93 Learning Path","text":""},{"location":"Main/Overview/#beginner-path","title":"Beginner Path","text":"<ol> <li>Start with main_sugar.py to understand high-level concepts</li> <li>Experiment with different symbols and lot sizes</li> <li>Add your own calculations and logic</li> <li>Read the Sugar API documentation</li> </ol>"},{"location":"Main/Overview/#intermediate-path","title":"Intermediate Path","text":"<ol> <li>Study main_streams.py for real-time data handling</li> <li>Learn main_trade_mod.py for order management</li> <li>Combine sugar methods with custom logic</li> <li>Explore Strategy System</li> </ol>"},{"location":"Main/Overview/#advanced-path","title":"Advanced Path","text":"<ol> <li>Dive into main_low_level.py for full control</li> <li>Read Low-Level API documentation</li> <li>Build custom wrappers for your specific needs</li> <li>Optimize performance with direct RPC calls</li> </ol>"},{"location":"Main/Overview/#related-documentation","title":"\ud83d\udcd6 Related Documentation","text":""},{"location":"Main/Overview/#core-concepts","title":"Core Concepts","text":"<ul> <li>Sugar API Overview - High-level API reference</li> <li>Low-Level API Overview - Complete RPC method list</li> <li>Architecture Guide - How everything fits together</li> </ul>"},{"location":"Main/Overview/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Orchestrators - Pre-built trading workflows</li> <li>Presets - Risk and strategy configurations</li> <li>Project Map - Full project structure</li> </ul>"},{"location":"Main/Overview/#reference","title":"Reference","text":"<ul> <li>Glossary - All trading and technical terms explained</li> <li>Examples Guide - Complete examples overview</li> </ul>"},{"location":"Main/Overview/#tips-for-success","title":"\ud83d\udca1 Tips for Success","text":""},{"location":"Main/Overview/#1-start-small","title":"1. Start Small","text":"<p>Don't try to understand everything at once. Pick one script, run it, modify it, break it, fix it.</p>"},{"location":"Main/Overview/#2-use-print-statements","title":"2. Use Print Statements","text":"<p>Add <code>print()</code> calls to see what's happening at each step. Understanding data flow is key.</p>"},{"location":"Main/Overview/#3-check-error-messages","title":"3. Check Error Messages","text":"<p>MT4 errors are descriptive. Read them carefully - they usually tell you exactly what's wrong.</p>"},{"location":"Main/Overview/#4-test-on-demo-account","title":"4. Test on Demo Account","text":"<p>Always test new code on a demo account first. Real money comes after thorough testing.</p>"},{"location":"Main/Overview/#5-keep-it-simple","title":"5. Keep It Simple","text":"<p>Start with simple strategies. Complexity should emerge from proven simple components.</p>"},{"location":"Main/Overview/#6-version-control","title":"6. Version Control","text":"<p>Use git to track your experiments. You'll want to roll back changes sometimes.</p>"},{"location":"Main/Overview/#quick-links","title":"\ud83d\udd17 Quick Links","text":"Topic Link Full Examples Guide All_about_examples.md Sugar API Reference MT4Sugar Overview Low-Level API Reference MT4Account BASE Architecture &amp; Data Flow ARCHITECTURE.md Glossary GLOSSARY.md Project Structure PROJECT_MAP.md"},{"location":"Main/main_low_level/","title":"main_low_level.py","text":""},{"location":"Main/main_low_level/#what-this-file-is","title":"What this file is","text":"<p>Demonstration script showcasing low\u2011level MT4 SDK methods (no sugar wrappers). Use it to understand the raw RPC surface \u2014 quotes, symbols, order actions, and streams.</p>"},{"location":"Main/main_low_level/#lowlevel-methods-used-here","title":"Low\u2011level methods used here","text":"<ul> <li>This list comes from a static scan of the script. If you add more calls, extend the list accordingly.</li> <li>Each item links to its detailed low\u2011level documentation under <code>docs/MT4Account/...</code>.</li> </ul> <ul> <li><code>quote(...)</code> \u2192 see quote.md</li> <li><code>quote_many(...)</code> \u2192 see quote_many.md</li> <li><code>quote_history(...)</code> \u2192 see quote_history.md</li> <li><code>symbols(...)</code> \u2192 see symbols.md</li> <li><code>symbol_params_many(...)</code> \u2192 see symbol_params_many.md</li> <li><code>tick_value_with_size(...)</code> \u2192 see tick_value_with_size.md</li> <li><code>opened_orders(...)</code> \u2192 see opened_orders.md</li> <li><code>opened_orders_tickets(...)</code> \u2192 see opened_orders_tickets.md</li> <li><code>order_send(...)</code> \u2192 see order_send.md</li> <li><code>order_modify(...)</code> \u2192 see order_modify.md</li> <li><code>order_close_delete(...)</code> \u2192 see order_close_delete.md</li> <li><code>order_close_by(...)</code> \u2192 see order_close_by.md</li> <li><code>on_symbol_tick(...)</code> \u2192 see on_symbol_tick.md</li> <li><code>on_trade(...)</code> \u2192 see on_trade.md</li> <li><code>on_opened_orders_tickets(...)</code> \u2192 see on_opened_orders_tickets.md</li> <li><code>on_opened_orders_profit(...)</code> \u2192 see on_opened_orders_profit.md</li> <li><code>account_summary(...)</code> \u2192 see account_summary.md</li> </ul>"},{"location":"Main/main_low_level/#tips-for-working-with-this-demo","title":"Tips for working with this demo","text":"<ul> <li>Connect first, then call. Always ensure the session is alive before market requests.</li> <li>Enable symbols. If a symbol is missing, call the symbol\u2011enable routine in advance.</li> <li>Handle latency and retries. Use simple health checks and re\u2011connect logic for transient errors.</li> <li>Separate I/O from math. Keep pip/lot computations outside of low\u2011level calls.</li> <li>Log minimally but meaningfully. Print concise snapshots: symbol, bid/ask, time, operation result.</li> </ul>"},{"location":"Main/main_low_level/#output","title":"Output","text":"<p>You should see structured prints in your terminal (quotes, order results, etc.).</p> <p></p>"},{"location":"Main/main_streams/","title":"main_streams.py","text":""},{"location":"Main/main_streams/#what-this-file-is","title":"What this file is","text":"<p>Demonstration script for server-streaming APIs (real-time subscriptions). Shows how to consume async streams and handle cooperative cancellation.</p>"},{"location":"Main/main_streams/#lowlevel-methods-used-here","title":"Low\u2011level methods used here","text":"<ul> <li><code>on_symbol_tick(...)</code> \u2192 see on_symbol_tick.md</li> <li><code>on_trade(...)</code> \u2192 see on_trade.md</li> <li><code>on_opened_orders_tickets(...)</code> \u2192 see on_opened_orders_tickets.md</li> <li><code>on_opened_orders_profit(...)</code> \u2192 see on_opened_orders_profit.md</li> </ul>"},{"location":"Main/main_streams/#tips-for-working-with-stream-demos","title":"Tips for working with stream demos","text":"<ul> <li>Cooperative shutdown. Pass a cancellation event and stop cleanly.</li> <li>Back-pressure. Debounce or sample incoming ticks to avoid UI/CPU spikes.</li> <li>Scoped subscriptions. Keep symbol lists compact; use snapshots (<code>quote_many</code>) for refills.</li> <li>Structured logging. Log symbol, bid/ask, latency markers; avoid per-tick verbose logs.</li> </ul>"},{"location":"Main/main_streams/#output","title":"Output","text":"<p>You should see a rolling log of streamed updates (ticks, trades, tickets, etc.).</p> <p></p>"},{"location":"Main/main_sugar/","title":"main_sugar.py","text":""},{"location":"Main/main_sugar/#what-this-file-is","title":"What this file is","text":"<p>Demonstration script showcasing high-level sugar methods that wrap low-level MT4 RPC calls. It\u2019s meant for quick onboarding: readable calls, sane defaults, and concise examples.</p>"},{"location":"Main/main_sugar/#methods-used-here-with-lowlevel-links","title":"Methods used here (with low\u2011level links)","text":"<ul> <li><code>ensure_connected(...)</code> \u2192 low\u2011level: n/a (in-memory helper or connectivity check)</li> <li><code>ping(...)</code> \u2192 low\u2011level: n/a (in-memory helper or connectivity check)</li> <li><code>ensure_symbol(...)</code> \u2192 low\u2011level: symbols.md</li> <li><code>digits(...)</code> \u2192 low\u2011level: symbol_params_many.md</li> <li><code>point(...)</code> \u2192 low\u2011level: symbol_params_many.md</li> <li><code>pip_size(...)</code> \u2192 low\u2011level: tick_value_with_size.md</li> <li><code>spread_pips(...)</code> \u2192 low\u2011level: quote.md</li> <li><code>mid_price(...)</code> \u2192 low\u2011level: quote.md</li> <li><code>last_quote(...)</code> \u2192 low\u2011level: quote.md</li> <li><code>calc_lot_by_risk(...)</code> \u2192 low\u2011level: tick_value_with_size.md</li> <li><code>calc_cash_risk(...)</code> \u2192 low\u2011level: tick_value_with_size.md</li> <li><code>buy_market(...)</code> \u2192 low\u2011level: order_send.md</li> <li><code>modify_sl_tp_by_pips(...)</code> \u2192 low\u2011level: order_modify.md</li> <li><code>close(...)</code> \u2192 low\u2011level: order_close_delete.md</li> <li><code>buy_limit(...)</code> \u2192 low\u2011level: order_send.md</li> <li><code>sell_market(...)</code> \u2192 low\u2011level: order_send.md</li> <li><code>modify_sl_tp_by_price(...)</code> \u2192 low\u2011level: order_modify.md</li> <li><code>close_all(...)</code> \u2192 low\u2011level: order_close_delete.md</li> </ul>"},{"location":"Main/main_sugar/#tips-for-working-with-this-demo","title":"Tips for working with this demo","text":"<ul> <li>Set defaults first. Call <code>set_defaults(...)</code> for symbol/magic/pip settings to reduce noise.</li> <li>Ensure connectivity. Use <code>await ensure_connected()</code> and occasional <code>await ping()</code> in loops.</li> <li>Normalize before send. Normalize <code>price</code> and <code>lots</code>; convert pips\u2194price with helpers.</li> <li>Use context overrides. <code>with_defaults(...)</code> for temporary symbol/magic in a scoped block.</li> <li>Log outcomes. Print compact results (ticket, price, sl/tp) rather than raw objects.</li> </ul>"},{"location":"Main/main_sugar/#output","title":"Output","text":"<p>You should see readable prints for each sugar call (quotes, placements, modifications, etc.).</p> <p> </p>"},{"location":"Main/main_trade_mod/","title":"main_trade_mod.py","text":""},{"location":"Main/main_trade_mod/#what-this-file-is","title":"What this file is","text":"<p>Demonstration script focused on trade modification flows: placing, modifying, and closing orders. It shows common sequences like <code>order_send \u2192 order_modify \u2192 order_close</code> with minimal boilerplate.</p>"},{"location":"Main/main_trade_mod/#methods-used-here-with-lowlevel-links","title":"Methods used here (with low\u2011level links)","text":"<ul> <li><code>quote(...)</code> \u2192 low\u2011level: quote.md</li> <li><code>buy_market(...)</code> \u2192 low\u2011level: order_send.md</li> <li><code>buy_limit(...)</code> \u2192 low\u2011level: order_send.md</li> <li><code>close(...)</code> \u2192 low\u2011level: order_close_delete.md</li> <li><code>close_partial(...)</code> \u2192 low\u2011level: order_close_delete.md</li> <li><code>sell_market(...)</code> \u2192 low\u2011level: order_send.md</li> <li><code>close_by(...)</code> \u2192 low\u2011level: order_close_by.md</li> <li><code>opened_orders(...)</code> \u2192 low\u2011level: opened_orders.md</li> </ul>"},{"location":"Main/main_trade_mod/#tips-for-working-with-this-demo","title":"Tips for working with this demo","text":"<ul> <li>Normalize before modify. Use price/lot normalization helpers to satisfy broker constraints.</li> <li>Convert pips\u2194price consistently to avoid off-by-one tick rejections.</li> <li>Respect freeze levels. Some brokers block SL/TP changes near current price \u2014 plan distances.</li> <li>Check order state. Re\u2011query tickets before modifying; ensure it's still open and prices changed.</li> <li>Log results. Store the returned ticket and the final SL/TP to trace outcomes.</li> </ul>"},{"location":"Main/main_trade_mod/#output","title":"Output","text":"<p>Expect a short log of placement \u2192 modification \u2192 close results (ticket, prices, statuses).</p> <p></p>"},{"location":"Strategy/All_about_orchestrator/","title":"\ud83c\udfad Strategy Orchestrators Guide","text":"<p>What is an Orchestrator? An orchestrator is a ready-to-use trading scenario that combines order execution, risk management, and automated position handling into a single, reusable workflow.</p> <p>Think of it as a \"trading recipe\" \u2014 you provide the ingredients (symbol, risk parameters), and the orchestrator handles the entire execution flow automatically.</p>"},{"location":"Strategy/All_about_orchestrator/#quick-comparison","title":"\ud83c\udfaf Quick Comparison","text":"Orchestrator Type When to Use Key Feature market_one_shot \ud83d\ude80 Market Instant entries, scalping Fast execution + auto management pending_bracket \u23f0 Limit/Stop Precise entry price Wait for fill + timeout protection spread_guard \ud83d\udcb0 Filter Cost control Block trades when spreads too wide session_guard \ud83d\udd50 Time filter Session-specific trading Trade only during defined hours oco_straddle \ud83d\udd00 Breakout Two-way entry (OCO) Buy stop + Sell stop, cancel other bracket_trailing_activation \ud83d\udcc8 Trail Conditional trailing Activate trail only after threshold equity_circuit_breaker \ud83d\uded1 Safety Drawdown protection Emergency stop on equity drop dynamic_deviation_guard \ud83c\udfaf Slippage Adaptive deviation Adjust slippage based on volatility rollover_avoidance \ud83d\udcb8 Cost Swap time protection Block trades near rollover grid_dca_common_sl \ud83d\udcca Grid DCA/Grid strategies Multiple entries, shared stop loss kill_switch_review \ud83d\udd34 Emergency Manual intervention Review and kill all positions ladder_builder \ud83e\ude9c Scaling Scale in/out Build position gradually cleanup \ud83e\uddf9 Maintenance Close/cancel all Clean slate for new strategy"},{"location":"Strategy/All_about_orchestrator/#core-orchestrators-demonstrated-in-examples","title":"\ud83d\udcda Core Orchestrators (Demonstrated in Examples)","text":""},{"location":"Strategy/All_about_orchestrator/#1-market_one_shot-instant-market-execution","title":"1. \ud83d\ude80 market_one_shot - Instant Market Execution","text":"<p>Purpose: Fast market entry with automatic management.</p> <p>Perfect for: - Scalping and quick entries - Breakout trading (immediate execution) - News trading (fast during volatility) - \"Set and forget\" style</p> <p>What it does: <pre><code>from Strategy.orchestrator.market_one_shot import run_market_one_shot\nfrom Strategy.presets import MarketEURUSD, Balanced\n\nresult = await run_market_one_shot(svc, MarketEURUSD, Balanced)\n</code></pre></p> <p>Flow: 1. Buy at current market price 2. Set SL/TP automatically 3. Activate trailing stop (if configured) 4. Move to breakeven when profitable (if configured) 5. Return execution report</p> <p>Related: market_one_shot.py</p>"},{"location":"Strategy/All_about_orchestrator/#2-pending_bracket-limit-order-with-timeout","title":"2. \u23f0 pending_bracket - Limit Order with Timeout","text":"<p>Purpose: Enter at specific price, wait patiently for fill.</p> <p>Perfect for: - Support/resistance trading - Buy dips / sell rallies - Mean reversion strategies - Better entry price than market</p> <p>What it does: <pre><code>from Strategy.orchestrator.pending_bracket import run_pending_bracket\nfrom Strategy.presets import LimitEURUSD, Conservative\n\nstrategy = LimitEURUSD(price=1.0850)\nresult = await run_pending_bracket(svc, strategy, Conservative, timeout_s=900)\n</code></pre></p> <p>Flow: 1. Place limit order at specified price 2. Wait for market to reach your level (max: timeout_s) 3. Once filled \u2192 set SL/TP 4. Activate trailing/breakeven (if configured) 5. If timeout expires \u2192 cancel order</p> <p>Visual: <pre><code>Current: 1.1020  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  (Market here)\n                     \u2193\nTarget:  1.1000  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  (Your limit order)\n                     \u2193\nFilled!  1.1000  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  (SL/TP set automatically)\n</code></pre></p> <p>Related: pending_bracket.py</p>"},{"location":"Strategy/All_about_orchestrator/#3-spread_guard-cost-protection-filter","title":"3. \ud83d\udcb0 spread_guard - Cost Protection Filter","text":"<p>Purpose: Block trades when spreads are too wide (expensive).</p> <p>Perfect for: - Scalping (where spread = major cost) - News trading protection (spreads spike) - Rollover avoidance (spreads widen) - Cost-conscious trading</p> <p>What it does: <pre><code>from Strategy.orchestrator.spread_guard import market_with_spread_guard\n\nresult = await market_with_spread_guard(\n    svc, strategy, risk,\n    max_spread_pips=1.5  # Trade only if spread \u2264 1.5 pips\n)\n</code></pre></p> <p>Example: - \u2705 Spread: 0.8 pips \u2192 TRADE (good conditions) - \u2705 Spread: 1.5 pips \u2192 TRADE (acceptable) - \u274c Spread: 3.0 pips \u2192 BLOCKED (too expensive)</p> <p>Why it matters: <pre><code>Normal spread (2 pips):  Need 1.10040 for 2 pip profit\nWide spread (10 pips):   Need 1.10200 for 2 pip profit\n                        \u2192 5x more movement required!\n</code></pre></p> <p>Related: spread_guard.py</p>"},{"location":"Strategy/All_about_orchestrator/#4-session_guard-time-window-control","title":"4. \ud83d\udd50 session_guard - Time Window Control","text":"<p>Purpose: Trade only during specific hours/sessions.</p> <p>Perfect for: - Session-specific strategies (London breakout, NY reversal) - Avoiding low-liquidity periods (Asian session) - Overlap trading (London + NY = max volume) - Weekend/overnight risk avoidance</p> <p>What it does: <pre><code>from Strategy.orchestrator.session_guard import run_with_session_guard\n\nwindows = [('08:00', '11:30'), ('13:00', '17:00')]\nresult = await run_with_session_guard(\n    svc=svc,\n    runner_coro_factory=lambda: run_market_one_shot(svc, strategy, risk),\n    windows=windows,\n    tz='Europe/London',\n    weekdays=[0,1,2,3,4]  # Mon-Fri\n)\n</code></pre></p> <p>Visual: <pre><code>00:00 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u274c Blocked (outside windows)\n08:00 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2713 Window 1: Trading allowed\n11:30 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n12:00 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u274c Blocked (lunch break)\n13:00 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2713 Window 2: Trading allowed\n17:00 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n18:00 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u274c Blocked (after hours)\n</code></pre></p> <p>Trading Sessions: - \ud83c\uddef\ud83c\uddf5 Tokyo: 00:00-08:00 GMT (low volatility) - \ud83c\uddec\ud83c\udde7 London: 07:00-16:30 GMT (high liquidity) - \ud83c\uddfa\ud83c\uddf8 New York: 12:00-21:00 GMT (highest volume) - Overlap: 12:00-16:30 GMT (best time)</p> <p>Related: session_guard.py</p>"},{"location":"Strategy/All_about_orchestrator/#advanced-orchestrators","title":"\ud83d\udd27 Advanced Orchestrators","text":""},{"location":"Strategy/All_about_orchestrator/#5-oco_straddle-two-way-breakout-entry","title":"5. \ud83d\udd00 oco_straddle - Two-Way Breakout Entry","text":"<p>Purpose: Place both buy stop and sell stop, cancel the other when one fills.</p> <p>Perfect for: - Breakout strategies (don't know direction) - Range breakouts - News trading (catch the move either way)</p> <p>Flow: 1. Place buy stop above current price 2. Place sell stop below current price 3. When one fills \u2192 cancel the other 4. Continue with filled position</p> <p>Related: oco_straddle.py</p>"},{"location":"Strategy/All_about_orchestrator/#6-bracket_trailing_activation-conditional-trailing","title":"6. \ud83d\udcc8 bracket_trailing_activation - Conditional Trailing","text":"<p>Purpose: Activate trailing stop only after price moves X pips in profit.</p> <p>Perfect for: - Letting winners run initially - Avoiding early exits - Trend-following strategies</p> <p>Related: bracket_trailing_activation.py</p>"},{"location":"Strategy/All_about_orchestrator/#7-equity_circuit_breaker-drawdown-protection","title":"7. \ud83d\uded1 equity_circuit_breaker - Drawdown Protection","text":"<p>Purpose: Emergency stop when equity drops below threshold.</p> <p>Perfect for: - Risk management - Preventing catastrophic losses - Automated safety net</p> <p>Related: equity_circuit_breaker.py</p>"},{"location":"Strategy/All_about_orchestrator/#8-dynamic_deviation_guard-adaptive-slippage","title":"8. \ud83c\udfaf dynamic_deviation_guard - Adaptive Slippage","text":"<p>Purpose: Adjust allowed slippage based on market volatility.</p> <p>Perfect for: - Fast markets (news, open) - Preventing rejections - Adaptive execution</p> <p>Related: dynamic_deviation_guard.py</p>"},{"location":"Strategy/All_about_orchestrator/#9-rollover_avoidance-swap-time-protection","title":"9. \ud83d\udcb8 rollover_avoidance - Swap Time Protection","text":"<p>Purpose: Block trades near daily rollover when spreads widen.</p> <p>Perfect for: - Avoiding expensive swap time - Preventing wide-spread entries - Scalping protection</p> <p>Related: rollover_avoidance.py</p>"},{"location":"Strategy/All_about_orchestrator/#10-grid_dca_common_sl-grid-trading-with-shared-sl","title":"10. \ud83d\udcca grid_dca_common_sl - Grid Trading with Shared SL","text":"<p>Purpose: Build grid of positions with one shared stop loss.</p> <p>Perfect for: - DCA (Dollar Cost Averaging) - Grid strategies - Range-bound trading</p> <p>Related: grid_dca_common_sl.py</p>"},{"location":"Strategy/All_about_orchestrator/#11-kill_switch_review-emergency-stop","title":"11. \ud83d\udd34 kill_switch_review - Emergency Stop","text":"<p>Purpose: Review all open positions and close them manually.</p> <p>Perfect for: - Emergency situations - Manual intervention - Clean slate before strategy change</p> <p>Related: kill_switch_review.py</p>"},{"location":"Strategy/All_about_orchestrator/#12-ladder_builder-gradual-position-building","title":"12. \ud83e\ude9c ladder_builder - Gradual Position Building","text":"<p>Purpose: Scale into position gradually (multiple entries).</p> <p>Perfect for: - Large positions (reduce slippage) - Trend following (add to winners) - Risk averaging</p> <p>Related: ladder_builder.py</p>"},{"location":"Strategy/All_about_orchestrator/#13-cleanup-closecancel-all","title":"13. \ud83e\uddf9 cleanup - Close/Cancel All","text":"<p>Purpose: Utility to close all positions and cancel all pending orders.</p> <p>Perfect for: - End of day cleanup - Strategy reset - Emergency flatten</p> <p>Related: cleanup.py</p>"},{"location":"Strategy/All_about_orchestrator/#how-to-use-in-examples","title":"\ud83c\udfac How to Use in Examples","text":"<p>All orchestrators are demonstrated in examples/Orchestrator_demo.py:</p> <pre><code>python examples/Orchestrator_demo.py\n</code></pre> <p>Quick example: <pre><code>from Strategy.orchestrator.market_one_shot import run_market_one_shot\nfrom Strategy.presets import MarketEURUSD, Balanced\n\n# Execute market order with Balanced risk profile\nresult = await run_market_one_shot(\n    svc=svc,\n    strategy=MarketEURUSD,\n    risk=Balanced\n)\n\nprint(f\"Ticket: {result.ticket}\")\nprint(f\"Entry Price: {result.entry_price}\")\nprint(f\"SL: {result.sl_price}, TP: {result.tp_price}\")\n</code></pre></p>"},{"location":"Strategy/All_about_orchestrator/#combining-orchestrators","title":"\ud83e\udde9 Combining Orchestrators","text":"<p>Orchestrators can be combined for complex scenarios:</p> <pre><code># Example: Market entry with spread + session guards\nfrom Strategy.orchestrator.spread_guard import market_with_spread_guard\nfrom Strategy.orchestrator.session_guard import run_with_session_guard\n\n# 1. Session guard (only trade 08:00-17:00)\n# 2. Inside session \u2192 spread guard (only if spread \u2264 2 pips)\n# 3. Inside spread guard \u2192 market_one_shot execution\n\nresult = await run_with_session_guard(\n    svc=svc,\n    runner_coro_factory=lambda: market_with_spread_guard(\n        svc, MarketEURUSD, Balanced, max_spread_pips=2.0\n    ),\n    windows=[('08:00', '17:00')],\n    tz='Europe/London'\n)\n</code></pre>"},{"location":"Strategy/All_about_orchestrator/#related-documentation","title":"\ud83d\udcd6 Related Documentation","text":"<ul> <li>Strategy Presets Guide - Configure strategies and risk</li> <li>Examples Overview - See orchestrators in action</li> <li>MT4Sugar API - Low-level functions used by orchestrators</li> </ul>"},{"location":"Strategy/All_about_orchestrator/#quick-decision-guide","title":"\ud83c\udfaf Quick Decision Guide","text":"<p>I want to...</p> <ul> <li>\u2705 Trade immediately \u2192 <code>market_one_shot</code></li> <li>\u2705 Wait for specific price \u2192 <code>pending_bracket</code></li> <li>\u2705 Control costs \u2192 <code>spread_guard</code></li> <li>\u2705 Trade only certain hours \u2192 <code>session_guard</code></li> <li>\u2705 Catch breakout (either direction) \u2192 <code>oco_straddle</code></li> <li>\u2705 Protect from drawdown \u2192 <code>equity_circuit_breaker</code></li> <li>\u2705 Avoid swap time \u2192 <code>rollover_avoidance</code></li> <li>\u2705 Build position gradually \u2192 <code>ladder_builder</code> or <code>grid_dca_common_sl</code></li> <li>\u2705 Close everything \u2192 <code>cleanup</code> or <code>kill_switch_review</code></li> </ul> <p>\ud83d\udca1 Tip: All orchestrators work with Strategy Presets for easy configuration: <pre><code>from Strategy.presets import MarketEURUSD, Balanced, Conservative, Aggressive\n\n# Same orchestrator, different risk profiles\nawait run_market_one_shot(svc, MarketEURUSD, Conservative)  # 0.5% risk\nawait run_market_one_shot(svc, MarketEURUSD, Balanced)      # 1.0% risk\nawait run_market_one_shot(svc, MarketEURUSD, Aggressive)    # 2.0% risk\n</code></pre></p>"},{"location":"Strategy/All_about_presets/","title":"\u2699\ufe0f Strategy Presets Guide","text":"<p>What is a Preset? A preset is a pre-configured trading parameter set that you can use instantly without manual setup. It's like a \"trading profile\" button \u2014 click it, and all your risk, symbol, and strategy settings are ready to go.</p> <p>Think of presets as LEGO blocks \u2014 combine Strategy + Risk presets to build any trading scenario.</p>"},{"location":"Strategy/All_about_presets/#two-main-types-of-presets","title":"\ud83c\udfaf Two Main Types of Presets","text":""},{"location":"Strategy/All_about_presets/#strategy-presets-what-to-trade","title":"\ud83d\udccb Strategy Presets (WHAT to trade)","text":"<p>Defines what you're trading and how to enter: - Symbol (EURUSD, XAUUSD, BTCUSD...) - Entry type (Market, Limit, Breakout) - Magic number (for order organization) - Deviation/slippage tolerance</p>"},{"location":"Strategy/All_about_presets/#risk-presets-how-much-to-risk","title":"\ud83c\udfb2 Risk Presets (HOW MUCH to risk)","text":"<p>Defines how much to risk and where to place stops: - Risk percent (0.5%, 1.0%, 2.0%...) - Stop Loss distance (pips) - Take Profit distance (pips) - Trailing stop, Auto-breakeven</p>"},{"location":"Strategy/All_about_presets/#quick-combination-example","title":"\ud83e\udde9 Quick Combination Example","text":"<pre><code>from Strategy.presets import MarketEURUSD, Balanced\nfrom Strategy.orchestrator.market_one_shot import run_market_one_shot\n\n# MarketEURUSD = WHAT to trade (EUR/USD, market entry)\n# Balanced = HOW MUCH to risk (1% risk, SL=20, TP=40)\n\nresult = await run_market_one_shot(svc, MarketEURUSD, Balanced)\n</code></pre> <p>Result: Market buy on EURUSD with 1% risk, 20 pip SL, 40 pip TP \u2705</p>"},{"location":"Strategy/All_about_presets/#available-preset-categories","title":"\ud83d\udcda Available Preset Categories","text":"Category File Presets Purpose \ud83c\udfaf Basic Risk <code>risk.py</code> 5 profiles Fixed pip-based risk (Conservative, Balanced, Aggressive, Scalper, Walker) \ud83d\udcc8 ATR Risk <code>risk_atr.py</code> 3 dynamic Volatility-adaptive risk (ATR_Scalper, ATR_Balanced, ATR_Swing) \ud83c\udfb2 Risk Profiles <code>risk_profiles.py</code> 8+ combos Symbol+style combinations (ScalperEURUSD, SwingXAUUSD...) \ud83d\udd50 Session Risk <code>risk_session.py</code> 4 sessions Time-based risk (Asia, London, NewYork, Overlap) \ud83d\udcb1 Symbol Strategies <code>strategy_symbols.py</code> 30+ symbols Pre-configured symbols (MarketEURUSD, LimitXAUUSD...)"},{"location":"Strategy/All_about_presets/#basic-risk-presets-riskpy","title":"\ud83c\udfaf Basic Risk Presets (risk.py)","text":"<p>Fixed pip-based risk profiles \u2014 the foundation of risk management.</p> Preset Risk % SL (pips) TP (pips) R:R Best For Conservative 0.5% 25 50 1:2 Safe trading, large accounts Balanced 1.0% 20 40 1:2 Standard, general use Aggressive 2.0% 15 30 1:2 Experienced traders Scalper 1.0% 8 12 1:1.5 Quick in/out, tight stops + trailing Walker 0.75% 30 60 1:2 Patient, auto-breakeven at 20+2 pips"},{"location":"Strategy/All_about_presets/#usage","title":"Usage:","text":"<pre><code>from Strategy.presets import Conservative, Balanced, Aggressive, Scalper, Walker\n\n# Mix with any strategy\nawait run_market_one_shot(svc, MarketEURUSD, Conservative)  # Safe\nawait run_market_one_shot(svc, MarketEURUSD, Balanced)      # Standard\nawait run_market_one_shot(svc, MarketEURUSD, Aggressive)    # Risky\nawait run_market_one_shot(svc, MarketEURUSD, Scalper)       # Fast trading\nawait run_market_one_shot(svc, MarketEURUSD, Walker)        # Patience + BE\n</code></pre> <p>Related: risk.py</p>"},{"location":"Strategy/All_about_presets/#atr-based-risk-presets-risk_atrpy","title":"\ud83d\udcc8 ATR-Based Risk Presets (risk_atr.py)","text":"<p>Dynamic risk that adapts to market volatility.</p>"},{"location":"Strategy/All_about_presets/#what-is-atr","title":"What is ATR?","text":"<p>ATR (Average True Range) = Volatility indicator measuring average price movement. - Higher ATR = More volatile \u2192 Wider stops needed - Lower ATR = Less volatile \u2192 Tighter stops possible</p>"},{"location":"Strategy/All_about_presets/#why-use-atr-risk","title":"Why Use ATR Risk?","text":"<p>\u2705 Adaptive: Stops adjust to current market conditions automatically \u2705 Smart: Wider stops in volatile markets (avoid premature stop-outs) \u2705 Efficient: Tighter stops in calm markets (better R:R) \u2705 Universal: Works across all symbols and timeframes</p>"},{"location":"Strategy/All_about_presets/#example","title":"Example:","text":"<pre><code>EUR/USD ATR = 8 pips (calm market)\n\u2192 SL = 1.5 \u00d7 8 = 12 pips \u2713 (efficient)\n\nEUR/USD ATR = 25 pips (volatile market)\n\u2192 SL = 1.5 \u00d7 25 = 37 pips \u2713 (safe, won't get stopped out)\n</code></pre>"},{"location":"Strategy/All_about_presets/#available-presets","title":"Available Presets:","text":"Preset ATR Mult Min SL Max SL TP Ratio Best For ATR_Scalper 1.0x 6 15 1.5x Short-term, tight adaptive stops ATR_Balanced 1.5x 10 30 2.0x Medium-term, standard volatility ATR_Swing 2.0x 20 60 2.5x Long-term, wide volatility buffer"},{"location":"Strategy/All_about_presets/#usage_1","title":"Usage:","text":"<pre><code>from Strategy.presets.risk_atr import ATR_Scalper, ATR_Balanced, ATR_Swing\n\n# Risk auto-calculates from current ATR\nrisk = await ATR_Balanced(svc, \"EURUSD\", risk_percent=1.0)\nresult = await run_market_one_shot(svc, MarketEURUSD, risk)\n</code></pre> <p>Visual Flow: <pre><code>1. Fetch ATR(14) from market data\n2. Calculate: SL = ATR \u00d7 multiplier\n3. Clamp to min/max range\n4. Calculate: TP = SL \u00d7 ratio\n5. Return RiskPreset with calculated values\n</code></pre></p> <p>Related: risk_atr.py</p>"},{"location":"Strategy/All_about_presets/#risk-profiles-risk_profilespy","title":"\ud83c\udfb2 Risk Profiles (risk_profiles.py)","text":"<p>Pre-combined symbol + trading style risk configurations.</p> <p>Specialized risk profiles optimized for specific symbol/style combinations.</p>"},{"location":"Strategy/All_about_presets/#available-profiles","title":"Available Profiles:","text":"Profile Symbol Style Risk % SL TP Features ScalperEURUSD EURUSD Scalp 1.0% 8p 12p Tight + trailing 6p ScalperXAUUSD XAUUSD Scalp 0.75% 15p 22p Gold scalp, wider DayTraderEURUSD EURUSD Intraday 1.0% 20p 40p Standard day trade SwingEURUSD EURUSD Swing 0.5% 40p 100p Patient, BE at 25p SwingXAUUSD XAUUSD Swing 0.5% 60p 150p Gold swing, wide ConservativeXAUUSD XAUUSD Safe 0.3% 50p 100p Very safe gold"},{"location":"Strategy/All_about_presets/#usage_2","title":"Usage:","text":"<pre><code>from Strategy.presets.risk_profiles import ScalperEURUSD, SwingXAUUSD\n\n# Symbol-specific optimized risk\nawait run_market_one_shot(svc, MarketEURUSD, ScalperEURUSD)\nawait run_market_one_shot(svc, MarketXAUUSD, SwingXAUUSD)\n</code></pre> <p>Related: risk_profiles.py</p>"},{"location":"Strategy/All_about_presets/#session-based-risk-risk_sessionpy","title":"\ud83d\udd50 Session-Based Risk (risk_session.py)","text":"<p>Time-based risk that adapts to trading sessions.</p> <p>Different trading sessions have different characteristics:</p> Session Time (GMT) Characteristics Risk Approach \ud83c\uddef\ud83c\uddf5 Tokyo 00:00-08:00 Low volatility, range-bound Tighter stops, scalping \ud83c\uddec\ud83c\udde7 London 07:00-16:30 High liquidity, major moves Standard risk \ud83c\uddfa\ud83c\uddf8 New York 12:00-21:00 Highest volume, trending Wider stops, trend follow \ud83c\udf0d Overlap 12:00-16:30 London+NY, max volatility Conservative, wider stops"},{"location":"Strategy/All_about_presets/#available-functions","title":"Available Functions:","text":"<pre><code>from Strategy.presets.risk_session import (\n    session_risk_auto,  # Auto-detect current session\n    tokyo_risk,         # Asian session\n    london_risk,        # European session\n    newyork_risk,       # American session\n    overlap_risk        # High volatility period\n)\n\n# Auto-select based on current time\nrisk = await session_risk_auto(svc, \"EURUSD\", tz=\"Europe/London\")\n\n# Or specific session\nrisk = await london_risk(svc, \"EURUSD\", risk_percent=1.0)\n</code></pre> <p>Example Auto-Selection: <pre><code>Current time: 08:30 GMT in London timezone\n\u2192 Detects: London session\n\u2192 Returns: Standard risk (SL=20, TP=40)\n\nCurrent time: 14:00 GMT\n\u2192 Detects: Overlap (London + NY)\n\u2192 Returns: Conservative risk (SL=30, TP=60)\n</code></pre></p> <p>Related: risk_session.py</p>"},{"location":"Strategy/All_about_presets/#symbol-strategy-presets-strategy_symbolspy","title":"\ud83d\udcb1 Symbol Strategy Presets (strategy_symbols.py)","text":"<p>Pre-configured strategies for 30+ trading symbols.</p> <p>Each symbol has 3 entry type variants:</p>"},{"location":"Strategy/All_about_presets/#entry-types","title":"Entry Types:","text":"Type Magic Range Purpose Example Market{Symbol} X01 Instant market orders <code>MarketEURUSD</code> Limit{Symbol}(price) X02 Patient limit orders <code>LimitEURUSD(1.0850)</code> Breakout{Symbol} X03 Dynamic stop orders <code>BreakoutEURUSD</code>"},{"location":"Strategy/All_about_presets/#symbol-coverage","title":"Symbol Coverage:","text":""},{"location":"Strategy/All_about_presets/#forex-majors","title":"\ud83d\udcb1 Forex Majors","text":"<pre><code>from Strategy.presets.strategy_symbols import (\n    MarketEURUSD, LimitEURUSD, BreakoutEURUSD,  # Magic: 771-773\n    MarketGBPUSD, LimitGBPUSD, BreakoutGBPUSD,  # Magic: 781-783\n    MarketUSDJPY, LimitUSDJPY, BreakoutUSDJPY,  # Magic: 791-793\n)\n</code></pre>"},{"location":"Strategy/All_about_presets/#precious-metals","title":"\ud83e\udd47 Precious Metals","text":"<pre><code>from Strategy.presets.strategy_symbols import (\n    MarketXAUUSD, LimitXAUUSD, BreakoutXAUUSD,  # Gold, Magic: 801-803\n    MarketXAGUSD, LimitXAGUSD, BreakoutXAGUSD,  # Silver, Magic: 811-813\n)\n</code></pre>"},{"location":"Strategy/All_about_presets/#indices","title":"\ud83d\udcca Indices","text":"<pre><code>from Strategy.presets.strategy_symbols import (\n    MarketUS100, LimitUS100, BreakoutUS100,      # Nasdaq, Magic: 821-823\n    MarketUS500, LimitUS500, BreakoutUS500,      # S&amp;P 500, Magic: 831-833\n    MarketGER40, LimitGER40, BreakoutGER40,      # DAX, Magic: 841-843\n)\n</code></pre>"},{"location":"Strategy/All_about_presets/#crypto","title":"\u20bf Crypto","text":"<pre><code>from Strategy.presets.strategy_symbols import (\n    MarketBTCUSD, LimitBTCUSD, BreakoutBTCUSD,  # Bitcoin, Magic: 851-853\n)\n</code></pre>"},{"location":"Strategy/All_about_presets/#deviation-tuning-by-volatility","title":"Deviation Tuning by Volatility:","text":"<p>Different symbols need different slippage tolerance:</p> Symbol Type Deviation (pips) Reason Forex Majors 2.0-2.5 Low-medium volatility Precious Metals 4.0-5.0 High volatility Indices 6.0-12.0 Very high volatility Crypto 20.0 Extreme volatility"},{"location":"Strategy/All_about_presets/#usage-examples","title":"Usage Examples:","text":"<p>Market Order: <pre><code>from Strategy.presets import MarketXAUUSD, Balanced\n\n# Instant gold trade\nresult = await run_market_one_shot(svc, MarketXAUUSD, Balanced)\n</code></pre></p> <p>Limit Order: <pre><code>from Strategy.presets import LimitEURUSD, Scalper\n\n# Wait for specific price\nstrategy = LimitEURUSD(price=1.0850)\nresult = await run_pending_bracket(svc, strategy, Scalper, timeout_s=900)\n</code></pre></p> <p>Multi-Symbol Portfolio: <pre><code>from Strategy.presets import MarketEURUSD, MarketGBPUSD, MarketXAUUSD, Balanced\n\nsymbols = [MarketEURUSD, MarketGBPUSD, MarketXAUUSD]\nfor strategy in symbols:\n    result = await run_market_one_shot(svc, strategy, Balanced)\n</code></pre></p> <p>Related: strategy_symbols.py</p>"},{"location":"Strategy/All_about_presets/#how-to-use-in-examples","title":"\ud83c\udfac How to Use in Examples","text":"<p>All presets are demonstrated in examples/Presets_demo.py:</p> <pre><code>python examples/Presets_demo.py\n</code></pre>"},{"location":"Strategy/All_about_presets/#mixing-and-matching-presets","title":"\ud83e\udde9 Mixing and Matching Presets","text":"<p>The power of presets is flexibility \u2014 mix any Strategy with any Risk:</p> <pre><code>from Strategy.presets import (\n    MarketEURUSD, MarketXAUUSD, LimitGBPUSD,\n    Conservative, Balanced, Aggressive, Scalper\n)\n\n# Same strategy, different risk profiles\nawait run_market_one_shot(svc, MarketEURUSD, Conservative)  # 0.5% safe\nawait run_market_one_shot(svc, MarketEURUSD, Balanced)      # 1.0% standard\nawait run_market_one_shot(svc, MarketEURUSD, Aggressive)    # 2.0% risky\n\n# Same risk, different strategies\nawait run_market_one_shot(svc, MarketEURUSD, Scalper)       # EURUSD scalp\nawait run_market_one_shot(svc, MarketXAUUSD, Scalper)       # Gold scalp\nawait run_market_one_shot(svc, MarketBTCUSD, Scalper)       # BTC scalp\n\n# Adaptive risk with ATR\nrisk_eur = await ATR_Balanced(svc, \"EURUSD\", risk_percent=1.0)\nrisk_gold = await ATR_Balanced(svc, \"XAUUSD\", risk_percent=1.0)\nawait run_market_one_shot(svc, MarketEURUSD, risk_eur)\nawait run_market_one_shot(svc, MarketXAUUSD, risk_gold)\n</code></pre>"},{"location":"Strategy/All_about_presets/#preset-comparison-tables","title":"\ud83d\udcca Preset Comparison Tables","text":""},{"location":"Strategy/All_about_presets/#risk-preset-comparison","title":"Risk Preset Comparison","text":"Preset Type Risk % Adaptability Best For Conservative Fixed 0.5% Static Safe, large accounts Balanced Fixed 1.0% Static General trading Aggressive Fixed 2.0% Static High risk appetite Scalper Fixed 1.0% Static Fast trading Walker Fixed 0.75% Static Patient trading ATR_Scalper Dynamic Custom High Volatile scalping ATR_Balanced Dynamic Custom High Adaptive day trading ATR_Swing Dynamic Custom High Volatile swing trading ScalperEURUSD Optimized 1.0% Medium EUR scalping SwingXAUUSD Optimized 0.5% Medium Gold swing"},{"location":"Strategy/All_about_presets/#quick-decision-guide","title":"\ud83c\udfaf Quick Decision Guide","text":"<p>I want to...</p> <ul> <li>\u2705 Trade safely \u2192 <code>Conservative</code></li> <li>\u2705 Standard risk \u2192 <code>Balanced</code></li> <li>\u2705 Take more risk \u2192 <code>Aggressive</code></li> <li>\u2705 Scalp quickly \u2192 <code>Scalper</code></li> <li>\u2705 Be patient \u2192 <code>Walker</code></li> <li>\u2705 Adapt to volatility \u2192 <code>ATR_Balanced</code>, <code>ATR_Scalper</code>, <code>ATR_Swing</code></li> <li>\u2705 Symbol-optimized risk \u2192 <code>ScalperEURUSD</code>, <code>SwingXAUUSD</code>, etc.</li> <li>\u2705 Trade by session \u2192 <code>session_risk_auto()</code></li> <li>\u2705 Trade specific symbol \u2192 <code>MarketEURUSD</code>, <code>LimitXAUUSD</code>, etc.</li> </ul>"},{"location":"Strategy/All_about_presets/#pro-tips","title":"\ud83d\udca1 Pro Tips","text":"<ol> <li>Start with Balanced \u2014 it's the industry standard (1% risk, 1:2 R:R)</li> <li>Use ATR risk for volatile symbols (Gold, Bitcoin, indices)</li> <li>Combine session guards with session risk for optimal timing</li> <li>Test deviation settings with your broker (can vary by broker)</li> <li>Use unique magic numbers per strategy for easy filtering</li> <li>Limit orders save spread costs (better average entry price)</li> <li>Mix and match freely \u2014 any Strategy + any Risk preset works</li> </ol> <p>\ud83d\udce6 Summary:</p> <p>Presets are building blocks: - Strategy Presets = WHAT to trade (symbol, entry type) - Risk Presets = HOW MUCH to risk (%, SL, TP) - Combine them = Complete trading setup in one line</p> <pre><code># One line = complete trading configuration\nawait run_market_one_shot(svc, MarketEURUSD, Balanced)\n</code></pre>"}]}